<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
</head>
<!-- <script src="rands.js"></script> -->
<script>
    let icons = []
    let tadpoles = []
    let ws
    let rands = {}
    const busta = fetch('http://ditzbitz.com/rands.json')
  .then(response => response.json()).then(data => {rands = data});



    window.addEventListener('DOMContentLoaded', (event) => {


        let alpha = 1
        let chatsetup = 0
        let HOST = location.origin.replace(/^http/, 'ws')
        ws = new WebSocket(HOST);
        let enterlock = 0
        let typing = 0

        let racersId = Math.random()
        let racersIds = [racersId]

        let digId = Math.random()
        let pomaoId = Math.random()
        let diggerIds = [digId]
        let pomaoIds = [pomaoId]


        let textcanvas = document.getElementById("textcanvas"); //getting canvas from document



        class Listener {
            constructor() {
                this.command = ''
                this.clear = 0
                this.flies = 0
            }
            listen(){
                if(this.command == '--clear'){
                    this.command = ''
                    this.clear = 1
                }

                if(this.flies == 1){
                    this.flies = 0
                    this.num = parseInt(this.command, 10)

                    this.command = ''
                }
                if(this.command == '--flies'){
                    this.command = ''
                    this.flies = 1
                }
            
                if(this.command == '--execute'){
                    this.execute = 1
                }
                console.log(this)

            }
        }
        // }
        let globalListener = new Listener()

        textcanvas.style.background = "#00FF00"
        textcanvas.width = 640
        textcanvas.height = 36000
        let textcanvas_context = textcanvas.getContext('2d');
        let textscroll = 12
        textcanvas.hidden = true


        let textstring = ""
        let frogid = Math.random()
        let windowspares = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}]
        // let globalListener = {}


        const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
        for (let t = 0; t < 10000000; t++) {
            squaretable[`${t}`] = Math.sqrt(t)
            if (t > 999) {
                t += 9
            }
        }
        const gamepadAPI = {
            controller: {},
            turbo: true,
            connect: function(evt) {
                if (navigator.getGamepads()[0] != null) {
                    gamepadAPI.controller = navigator.getGamepads()[0]
                    gamepadAPI.turbo = true;
                } else if (navigator.getGamepads()[1] != null) {
                    gamepadAPI.controller = navigator.getGamepads()[0]
                    gamepadAPI.turbo = true;
                } else if (navigator.getGamepads()[2] != null) {
                    gamepadAPI.controller = navigator.getGamepads()[0]
                    gamepadAPI.turbo = true;
                } else if (navigator.getGamepads()[3] != null) {
                    gamepadAPI.controller = navigator.getGamepads()[0]
                    gamepadAPI.turbo = true;
                }
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i] === null) {
                        continue;
                    }
                    if (!gamepads[i].connected) {
                        continue;
                    }
                }
            },
            disconnect: function(evt) {
                gamepadAPI.turbo = false;
                delete gamepadAPI.controller;
            },
            update: function() {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.buttonsCache = []; // clear the buttons cache
                for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) { // move the buttons status from the previous frame to the cache
                    gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
                }
                gamepadAPI.buttonsStatus = []; // clear the buttons status
                var c = gamepadAPI.controller || {}; // get the gamepad object
                var pressed = [];
                if (c.buttons) {
                    for (var b = 0, t = c.buttons.length; b < t; b++) { // loop through buttons and push the pressed ones to the array
                        if (c.buttons[b].pressed) {
                            pressed.push(gamepadAPI.buttons[b]);
                        }
                    }
                }
                var axes = [];
                if (c.axes) {
                    for (var a = 0, x = c.axes.length; a < x; a++) { // loop through axes and push their values to the array
                        axes.push(c.axes[a].toFixed(2));
                    }
                }
                gamepadAPI.axesStatus = axes; // assign received values
                gamepadAPI.buttonsStatus = pressed;
                // //console.log(pressed); // return buttons for debugging purposes
                return pressed;
            },
            buttonPressed: function(button, hold) {
                var newPress = false;
                for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) { // loop through pressed buttons
                    if (gamepadAPI.buttonsStatus[i] == button) { // if we found the button we're looking for...
                        newPress = true; // set the boolean variable to true
                        if (!hold) { // if we want to check the single press
                            for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) { // loop through the cached states from the previous frame
                                if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                    newPress = false;
                                }
                            }
                        }
                    }
                }
                return newPress;
            },
            buttons: [
                'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
            ],
            buttonsCache: [],
            buttonsStatus: [],
            axesStatus: []
        };
        let canvas
        let canvas_context
        let keysPressed = {}
        let FLEX_engine
        let TIP_engine = {}
        let XS_engine
        let YS_engine
            // TIP_engine.x = 350
            // TIP_engine.y = 350
        class Point {
            constructor(x, y) {
                this.x = x
                this.y = y
                this.radius = 0
            }
            pointDistance(point) {
                return (new LineOP(this, point, "transparent", 0)).hypotenuse()
            }
        }

        class Vector { // vector math and physics if you prefer this over vector components on circles
            constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
                this.xmom = xmom
                this.ymom = ymom
                this.object = object
            }
            isToward(point) {
                let link = new LineOP(this.object, point)
                let dis1 = link.sqrDis()
                let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                let link2 = new LineOP(dummy, point)
                let dis2 = link2.sqrDis()
                if (dis2 < dis1) {
                    return true
                } else {
                    return false
                }
            }
            rotate(angleGoal) {
                let link = new Line(this.xmom, this.ymom, 0, 0)
                let length = link.hypotenuse()
                let x = (length * Math.cos(angleGoal))
                let y = (length * Math.sin(angleGoal))
                this.xmom = x
                this.ymom = y
            }
            magnitude() {
                return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
            }
            normalize(size = 1) {
                let magnitude = this.magnitude()
                this.xmom /= magnitude
                this.ymom /= magnitude
                this.xmom *= size
                this.ymom *= size
            }
            multiply(vect) {
                let point = new Point(0, 0)
                let end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
                return point.pointDistance(end)
            }
            add(vect) {
                return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
            }
            subtract(vect) {
                return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
            }
            divide(vect) {
                return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
            }
            draw() {
                let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
                link.draw()
            }
        }
        class Line {
            constructor(x, y, x2, y2, color, width) {
                this.x1 = x
                this.y1 = y
                this.x2 = x2
                this.y2 = y2
                this.color = color
                this.width = width
            }
            angle() {
                return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
            }
            squareDistance() {
                let xdif = this.x1 - this.x2
                let ydif = this.y1 - this.y2
                let squareDistance = (xdif * xdif) + (ydif * ydif)
                return squareDistance
            }
            hypotenuse() {
                let xdif = this.x1 - this.x2
                let ydif = this.y1 - this.y2
                let hypotenuse = (xdif * xdif) + (ydif * ydif)
                if (hypotenuse < 10000000 - 1) {
                    if (hypotenuse > 1000) {
                        return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                    } else {
                        return squaretable[`${Math.round(hypotenuse)}`]
                    }
                } else {
                    return Math.sqrt(hypotenuse)
                }
            }
            draw() {
                let linewidthstorage = canvas_context.lineWidth
                canvas_context.strokeStyle = this.color
                canvas_context.lineWidth = this.width
                canvas_context.beginPath()
                canvas_context.moveTo(this.x1, this.y1)
                canvas_context.lineTo(this.x2, this.y2)
                canvas_context.stroke()
                canvas_context.lineWidth = linewidthstorage
            }
        }
        class LineOP {
            constructor(object, target, color, width) {
                this.object = object
                this.target = target
                this.color = color
                this.width = width
            }
            squareDistance() {
                let xdif = this.object.x - this.target.x
                let ydif = this.object.y - this.target.y
                let squareDistance = (xdif * xdif) + (ydif * ydif)
                return squareDistance
            }
            hypotenuse() {
                let xdif = this.object.x - this.target.x
                let ydif = this.object.y - this.target.y
                let hypotenuse = (xdif * xdif) + (ydif * ydif)
                if (hypotenuse < 10000000 - 1) {
                    if (hypotenuse > 1000) {
                        return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                    } else {
                        return squaretable[`${Math.round(hypotenuse)}`]
                    }
                } else {
                    return Math.sqrt(hypotenuse)
                }
            }
            angle() {
                return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
            }
            draw() {
                let linewidthstorage = canvas_context.lineWidth
                canvas_context.strokeStyle = this.color
                canvas_context.lineWidth = this.width
                canvas_context.beginPath()
                canvas_context.moveTo(this.object.x, this.object.y)
                canvas_context.lineTo(this.target.x, this.target.y)
                canvas_context.stroke()
                canvas_context.lineWidth = linewidthstorage
            }
        }
        class Triangle {
            constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
                this.x = x
                this.y = y
                this.color = color
                this.length = length
                this.x1 = this.x + this.length * leg1Ratio
                this.x2 = this.x - this.length * leg2Ratio
                this.tip = this.y - this.length * heightRatio
                this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                this.fill = fill
                this.stroke = strokeWidth
            }
            draw() {
                canvas_context.strokeStyle = this.color
                canvas_context.stokeWidth = this.stroke
                canvas_context.beginPath()
                canvas_context.moveTo(this.x, this.y)
                canvas_context.lineTo(this.x1, this.y)
                canvas_context.lineTo(this.x, this.tip)
                canvas_context.lineTo(this.x2, this.y)
                canvas_context.lineTo(this.x, this.y)
                if (this.fill == 1) {
                    canvas_context.fill()
                }
                canvas_context.stroke()
                canvas_context.closePath()
            }
            isPointInside(point) {
                if (point.x <= this.x1) {
                    if (point.y >= this.tip) {
                        if (point.y <= this.y) {
                            if (point.x >= this.x2) {
                                this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                                this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                                this.basey = point.y - this.tip
                                this.basex = point.x - this.x
                                if (this.basex == 0) {
                                    return true
                                }
                                this.slope = this.basey / this.basex
                                if (this.slope >= this.accept1) {
                                    return true
                                } else if (this.slope <= this.accept2) {
                                    return true
                                }
                            }
                        }
                    }
                }
                return false
            }
        }
        class Rectangle {
            constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
                this.x = x
                this.y = y
                this.height = height
                this.width = width
                this.color = color
                this.xmom = 0
                this.ymom = 0
                this.stroke = stroke
                this.strokeWidth = strokeWidth
                this.fill = fill
            }
            draw() {
                canvas_context.fillStyle = this.color
                canvas_context.fillRect(this.x, this.y, this.width, this.height)
                canvas_context.strokeStyle = "#FFFFFF"
                canvas_context.lineWidth = 1


                canvas_context.strokeRect(this.x, this.y, this.width, this.height)
            }
            move() {
                this.x += this.xmom
                this.y += this.ymom
            }
            isPointInside(point) {
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
                                return true
                            }
                        }
                    }
                }
                return false
            }
            doesPerimeterTouch(point) {
                if (point.x + point.radius >= this.x) {
                    if (point.y + point.radius >= this.y) {
                        if (point.x - point.radius <= this.x + this.width) {
                            if (point.y - point.radius <= this.y + this.height) {
                                return true
                            }
                        }
                    }
                }
                return false
            }
        }
        class Circle {
            constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                this.x = x
                this.y = y
                this.radius = radius
                this.color = color
                this.xmom = xmom
                this.ymom = ymom
                this.friction = friction
                this.reflect = reflect
                this.strokeWidth = strokeWidth
                this.strokeColor = strokeColor
            }
            draw() {
                canvas_context.lineWidth = this.strokeWidth
                canvas_context.strokeStyle = this.color
                canvas_context.beginPath();
                if (this.radius > 0) {
                    canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                    canvas_context.fillStyle = this.color
                    canvas_context.fill()
                    canvas_context.stroke();
                } else {
                    //console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                }
            }
            move() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x += this.xmom
                this.y += this.ymom
            }
            unmove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x -= this.xmom
                this.y -= this.ymom
            }
            frictiveMove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x += this.xmom
                this.y += this.ymom
                this.xmom *= this.friction
                this.ymom *= this.friction
            }
            frictiveunMove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.xmom /= this.friction
                this.ymom /= this.friction
                this.x -= this.xmom
                this.y -= this.ymom
            }
            isPointInside(point) {
                this.areaY = point.y - this.y
                this.areaX = point.x - this.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                    return true
                }
                return false
            }
            doesPerimeterTouch(point) {
                this.areaY = point.y - this.y
                this.areaX = point.x - this.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                    return true
                }
                return false
            }
        }
        class CircleRing {
            constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                this.x = x
                this.y = y
                this.radius = radius
                this.color = color
                this.xmom = xmom
                this.ymom = ymom
                this.friction = friction
                this.reflect = reflect
                this.strokeWidth = 10
                this.strokeColor = strokeColor
            }
            draw() {
                canvas_context.lineWidth = this.strokeWidth
                canvas_context.strokeStyle = this.color
                canvas_context.beginPath();
                if (this.radius > 0) {
                    canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                    canvas_context.fillStyle = this.color
                    canvas_context.fill()
                    canvas_context.stroke();
                } else {
                    // //console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                }
            }
            move() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x += this.xmom
                this.y += this.ymom
            }
            unmove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x -= this.xmom
                this.y -= this.ymom
            }
            frictiveMove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x += this.xmom
                this.y += this.ymom
                this.xmom *= this.friction
                this.ymom *= this.friction
            }
            frictiveunMove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.xmom /= this.friction
                this.ymom /= this.friction
                this.x -= this.xmom
                this.y -= this.ymom
            }
            isPointInside(point) {
                this.areaY = point.y - this.y
                this.areaX = point.x - this.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                    return true
                }
                return false
            }
            doesPerimeterTouch(point) {
                this.areaY = point.y - this.y
                this.areaX = point.x - this.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                    return true
                }
                return false
            }
        }
        class Polygon {
            constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
                if (sides < 2) {
                    sides = 2
                }
                this.reflect = reflect
                this.xmom = xmom
                this.ymom = ymom
                this.body = new Circle(x, y, size - (size * .293), "transparent")
                this.nodes = []
                this.angle = angle
                this.size = size
                this.color = color
                this.angleIncrement = (Math.PI * 2) / sides
                this.sides = sides
                for (let t = 0; t < sides; t++) {
                    let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                    this.nodes.push(node)
                    this.angle += this.angleIncrement
                }
            }
            isPointInside(point) { // rough approximation
                this.body.radius = this.size - (this.size * .293)
                if (this.sides <= 2) {
                    return false
                }
                this.areaY = point.y - this.body.y
                this.areaX = point.x - this.body.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                    return true
                }
                return false
            }
            move() {
                if (this.reflect == 1) {
                    if (this.body.x > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.body.y > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.body.x < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.body.y < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.body.x += this.xmom
                this.body.y += this.ymom
            }
            draw() {
                this.nodes = []
                this.angleIncrement = (Math.PI * 2) / this.sides
                this.body.radius = this.size - (this.size * .293)
                for (let t = 0; t < this.sides; t++) {
                    let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                    this.nodes.push(node)
                    this.angle += this.angleIncrement
                }
                canvas_context.strokeStyle = this.color
                canvas_context.fillStyle = this.color
                canvas_context.lineWidth = 0
                canvas_context.beginPath()
                canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
                for (let t = 1; t < this.nodes.length; t++) {
                    canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
                }
                canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
                canvas_context.fill()
                canvas_context.stroke()
                canvas_context.closePath()
            }
        }
        class Shape {
            constructor(shapes) {
                this.shapes = shapes
            }
            draw() {
                for (let t = 0; t < this.shapes.length; t++) {
                    this.shapes[t].draw()
                }
            }
            isPointInside(point) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (this.shapes[t].isPointInside(point)) {
                        return true
                    }
                }
                return false
            }
            doesPerimeterTouch(point) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (this.shapes[t].doesPerimeterTouch(point)) {
                        return true
                    }
                }
                return false
            }
            innerShape(point) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (this.shapes[t].doesPerimeterTouch(point)) {
                        return this.shapes[t]
                    }
                }
                return false
            }
            isInsideOf(box) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (box.isPointInside(this.shapes[t])) {
                        return true
                    }
                }
                return false
            }
            adjustByFromDisplacement(x, y) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (typeof this.shapes[t].fromRatio == "number") {
                        this.shapes[t].x += x * this.shapes[t].fromRatio
                        this.shapes[t].y += y * this.shapes[t].fromRatio
                    }
                }
            }
            adjustByToDisplacement(x, y) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (typeof this.shapes[t].toRatio == "number") {
                        this.shapes[t].x += x * this.shapes[t].toRatio
                        this.shapes[t].y += y * this.shapes[t].toRatio
                    }
                }
            }
            mixIn(arr) {
                for (let t = 0; t < arr.length; t++) {
                    for (let k = 0; k < arr[t].shapes.length; k++) {
                        this.shapes.push(arr[t].shapes[k])
                    }
                }
            }
            push(object) {
                this.shapes.push(object)
            }
        }

        class Spring {
            constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
                if (body == 0) {
                    this.body = new Circle(x, y, radius, color)
                    this.anchor = new Circle(x, y, radius, color)
                    this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                    this.length = length
                } else {
                    this.body = body
                    this.anchor = new Circle(x, y, radius, color)
                    this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                    this.length = length
                }
                this.gravity = gravity
                this.width = width
            }
            balance() {
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                if (this.beam.hypotenuse() < this.length) {
                    this.body.xmom += (this.body.x - this.anchor.x) / this.length
                    this.body.ymom += (this.body.y - this.anchor.y) / this.length
                    this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                    this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
                } else {
                    this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                    this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                    this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                    this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
                }
                let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
            }
            draw() {
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                this.beam.draw()
                this.body.draw()
                this.anchor.draw()
            }
            move() {
                this.anchor.ymom += this.gravity
                this.anchor.move()
            }

        }
        class SpringOP {
            constructor(body, anchor, length, width = 3, color = body.color) {
                this.body = body
                this.anchor = anchor
                this.beam = new LineOP(body, anchor, color, width)
                this.length = length
            }
            balance() {
                if (this.beam.hypotenuse() < this.length) {
                    this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
                    this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
                    this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
                    this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
                } else if (this.beam.hypotenuse() > this.length) {
                    this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
                    this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
                    this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
                    this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
                }

                let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
            }
            draw() {
                this.beam.draw()
            }
            move() {
                //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
            }
        }

        class Color {
            constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
                this.hue = baseColor
                if (red != -1 && green != -1 && blue != -1) {
                    this.r = red
                    this.g = green
                    this.b = blue
                    if (alpha != 1) {
                        if (alpha < 1) {
                            this.alpha = alpha
                        } else {
                            this.alpha = alpha / 255
                            if (this.alpha > 1) {
                                this.alpha = 1
                            }
                        }
                    }
                    if (this.r > 255) {
                        this.r = 255
                    }
                    if (this.g > 255) {
                        this.g = 255
                    }
                    if (this.b > 255) {
                        this.b = 255
                    }
                    if (this.r < 0) {
                        this.r = 0
                    }
                    if (this.g < 0) {
                        this.g = 0
                    }
                    if (this.b < 0) {
                        this.b = 0
                    }
                } else {
                    this.r = 0
                    this.g = 0
                    this.b = 0
                }
            }
            normalize() {
                if (this.r > 255) {
                    this.r = 255
                }
                if (this.g > 255) {
                    this.g = 255
                }
                if (this.b > 255) {
                    this.b = 255
                }
                if (this.r < 0) {
                    this.r = 0
                }
                if (this.g < 0) {
                    this.g = 0
                }
                if (this.b < 0) {
                    this.b = 0
                }
            }
            randomLight() {
                var letters = '0123456789ABCDEF';
                var hash = '#';
                for (var i = 0; i < 6; i++) {
                    hash += letters[(Math.floor(Math.random() * 12) + 4)];
                }
                var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
                return color;
            }
            randomDark() {
                var letters = '0123456789ABCDEF';
                var hash = '#';
                for (var i = 0; i < 6; i++) {
                    hash += letters[(Math.floor(Math.random() * 12))];
                }
                var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
                return color;
            }
            random() {
                var letters = '0123456789ABCDEF';
                var hash = '#';
                for (var i = 0; i < 6; i++) {
                    hash += letters[(Math.floor(Math.random() * 16))];
                }
                var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
                return color;
            }
        }
        class Softbody { //buggy, spins in place
            constructor(x, y, radius, color, size, members = 10, memberLength = 5, force = 10, gravity = 0) {
                this.springs = []
                this.pin = new Circle(x, y, radius, color)
                this.points = []
                this.flop = 0
                let angle = 0
                this.size = size
                let line = new Line((Math.cos(angle) * size), (Math.sin(angle) * size), (Math.cos(angle + ((Math.PI * 2) / members)) * size), (Math.sin(angle + ((Math.PI * 2) / members)) * size))
                let distance = line.hypotenuse()
                for (let t = 0; t < members; t++) {
                    let circ = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), radius, color)
                    circ.reflect = 1
                    circ.bigbody = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), distance, color)
                    circ.draw()
                    circ.touch = []
                    this.points.push(circ)
                    angle += ((Math.PI * 2) / members)
                }

                for (let t = 0; t < this.points.length; t++) {
                    for (let k = 0; k < this.points.length; k++) {
                        if (t != k) {
                            if (this.points[k].bigbody.doesPerimeterTouch(this.points[t])) {
                                if (!this.points[k].touch.includes(t) && !this.points[t].touch.includes(k)) {
                                    let spring = new SpringOP(this.points[k], this.points[t], (size * Math.PI) / members, 2, color)
                                    this.points[k].touch.push(t)
                                    this.points[t].touch.push(k)
                                    this.springs.push(spring)
                                    spring.beam.draw()
                                }
                            }
                        }
                    }
                }

                //console.log(this)

                // this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
                // this.springs.push(this.spring)
                // for (let k = 0; k < members; k++) {
                //     this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
                //     if (k < members - 1) {
                //         this.springs.push(this.spring)
                //     } else {
                //         this.spring.anchor = this.pin
                //         this.springs.push(this.spring)
                //     }
                // }
                this.forceConstant = force
                this.centroid = new Circle(0, 0, 10, "red")
            }
            circularize() {
                this.xpoint = 0
                this.ypoint = 0
                for (let s = 0; s < this.springs.length; s++) {
                    this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                    this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                }
                this.centroid.x = this.xpoint
                this.centroid.y = this.ypoint
                this.angle = 0
                this.angleIncrement = (Math.PI * 2) / this.springs.length
                for (let t = 0; t < this.points.length; t++) {
                    this.points[t].x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                    this.points[t].y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                    this.angle += this.angleIncrement
                }
            }
            balance() {
                this.xpoint = 0
                this.ypoint = 0
                for (let s = 0; s < this.points.length; s++) {
                    this.xpoint += (this.points[s].x / this.points.length)
                    this.ypoint += (this.points[s].y / this.points.length)
                }
                this.centroid.x = this.xpoint
                this.centroid.y = this.ypoint
                    // this.centroid.x += TIP_engine.x / this.points.length
                    // this.centroid.y += TIP_engine.y / this.points.length
                for (let s = 0; s < this.points.length; s++) {
                    this.link = new LineOP(this.points[s], this.centroid, 0, "transparent")
                    if (this.link.hypotenuse() != 0) {

                        if (this.size < this.link.hypotenuse()) {
                            this.points[s].xmom -= (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                            this.points[s].ymom -= (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                        } else {
                            this.points[s].xmom += (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                            this.points[s].ymom += (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                        }

                        // this.points[s].xmom += (((this.points[s].x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                        // this.points[s].ymom += (((this.points[s].y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                    }
                }
                if (this.flop % 2 == 0) {
                    for (let s = 0; s < this.springs.length; s++) {
                        this.springs[s].balance()
                    }
                } else {
                    for (let s = this.springs.length - 1; s >= 0; s--) {
                        this.springs[s].balance()
                    }
                }
                for (let s = 0; s < this.points.length; s++) {
                    this.points[s].move()
                    this.points[s].draw()
                }
                for (let s = 0; s < this.springs.length; s++) {
                    this.springs[s].draw()
                }
                this.centroid.draw()
            }
        }
        class Observer {
            constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
                this.body = new Circle(x, y, radius, color)
                this.color = color
                this.ray = []
                this.rayrange = range
                this.globalangle = Math.PI
                this.gapangle = angle
                this.currentangle = 0
                this.obstacles = []
                this.raymake = rays
            }
            beam() {
                this.currentangle = this.gapangle / 2
                for (let k = 0; k < this.raymake; k++) {
                    this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                    let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                    ray.collided = 0
                    ray.lifespan = this.rayrange - 1
                    this.ray.push(ray)
                }
                for (let f = 0; f < this.rayrange; f++) {
                    for (let t = 0; t < this.ray.length; t++) {
                        if (this.ray[t].collided < 1) {
                            this.ray[t].move()
                            for (let q = 0; q < this.obstacles.length; q++) {
                                if (this.obstacles[q].isPointInside(this.ray[t])) {
                                    this.ray[t].collided = 1
                                }
                            }
                        }
                    }
                }
            }
            draw() {
                this.beam()
                this.body.draw()
                canvas_context.lineWidth = 1
                canvas_context.fillStyle = this.color
                canvas_context.strokeStyle = this.color
                canvas_context.beginPath()
                canvas_context.moveTo(this.body.x, this.body.y)
                for (let y = 0; y < this.ray.length; y++) {
                    canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                    canvas_context.lineTo(this.body.x, this.body.y)
                }
                canvas_context.stroke()
                canvas_context.fill()
                this.ray = []
            }
        }

        function setUp(canvas_pass, style = "#000000") {
            canvas = canvas_pass
            canvas_context = canvas.getContext('2d');
            canvas.style.background = style
            window.setInterval(function() {
                main()
            }, 17)
            document.addEventListener('keydown', (event) => {
                keysPressed[event.key] = true;


                if (keysPressed['Control'] || keysPressed['Meta']) {
                    if (event.key == 'v') {
                        var promise = navigator.clipboard.read();
                        console.log(navigator.clipboard.readText().then(text => textstring += text))
                    }

                    // if(event.key == 'c'){
                    //     copyText.value = textstring
                    //     copyText.select();
                    //     document.execCommand("copy")
                    // }




                    if (event.key == 'BackSpace' || event.key == 'Backspace') {
                        textstring = ''
                    }

                } else {

                    if (event.key == 'Enter') {
                        enterlock = 1
                    } else {
                        if (event.key == 'Meta' || event.key == 'Shift' || event.key == 'Control' || event.key == 'ArrowUp' || event.key == 'ArrowDown' || event.key == 'ArrowLeft' || event.key == 'ArrowRight' || event.key == 'Alt' || event.key == 'Tab' || event.key == 'CapsLock' || event.key == 'Backspace') {} else {
                            if (typing == 1) {
                                textstring += event.key
                            }
                        }
                    }


                    if (event.key == 'BackSpace' || event.key == 'Backspace') {
                        let ts = (textstring.split(''))
                        ts.splice(ts.length - 1, 1)
                        console.log(ts)
                        textstring = ts.join('')
                    }

                }


            });
            document.addEventListener('keyup', (event) => {
                delete keysPressed[event.key];

                if (event.key == 'Enter') {
                    enterlock = 0
                }
            });
            window.addEventListener('pointerdown', e => {
                FLEX_engine = canvas.getBoundingClientRect();
                XS_engine = e.clientX - FLEX_engine.left;
                YS_engine = e.clientY - FLEX_engine.top;
                TIP_engine.x = XS_engine
                TIP_engine.y = YS_engine
                TIP_engine.body = TIP_engine
                let clear = 0
                for (let t = 0; t < icons.length; t++) {
                    if (icons[t].body.isPointInside(TIP_engine)) {
                        icons[t].marked = 1
                        clear = 1
                    }
                }
                for (let t = 0; t < icons.length; t++) {
                    // if(clear == 1){
                    if (t != 2) {

                        if (icons[t].ran == 1) {
                            if (!icons[t].window.isPointInside(TIP_engine)) {
                                icons[t].running = 0
                            }
                        } else {
                            icons[t].running = 0
                        }
                    }
                    // }
                }
                // example usage: if(object.isPointInside(TIP_engine)){ take action }
            });
            window.addEventListener('pointermove', continued_stimuli);

            window.addEventListener('pointerup', e => {
                for (let t = 0; t < icons.length; t++) {
                    icons[t].marked = 0
                }
                // window.removeEventListener("pointermove", continued_stimuli);
            })

            function continued_stimuli(e) {
                FLEX_engine = canvas.getBoundingClientRect();
                XS_engine = e.clientX - FLEX_engine.left;
                YS_engine = e.clientY - FLEX_engine.top;
                TIP_engine.x = XS_engine
                TIP_engine.y = YS_engine
                TIP_engine.body = TIP_engine
            }
        }

        function gamepad_control(object, speed = 1) { // basic control for objects using the controler
            //         //console.log(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
            if (typeof object.body != 'undefined') {
                if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                    if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                        object.body.x += (gamepadAPI.axesStatus[0] * speed)
                        object.body.y += (gamepadAPI.axesStatus[1] * speed)
                    }
                }
            } else if (typeof object != 'undefined') {
                if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                    if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                        object.x += (gamepadAPI.axesStatus[0] * speed)
                        object.y += (gamepadAPI.axesStatus[1] * speed)
                    }
                }
            }
        }

        function control(object, speed = 1) { // basic control for objects
            if (typeof object.body != 'undefined') {
                if (keysPressed['w']) {
                    object.body.y -= speed
                }
                if (keysPressed['d']) {
                    object.body.x += speed
                }
                if (keysPressed['s']) {
                    object.body.y += speed
                }
                if (keysPressed['a']) {
                    object.body.x -= speed
                }
            } else if (typeof object != 'undefined') {
                if (keysPressed['w']) {
                    object.y -= speed
                }
                if (keysPressed['d']) {
                    object.x += speed
                }
                if (keysPressed['s']) {
                    object.y += speed
                }
                if (keysPressed['a']) {
                    object.x -= speed
                }
            }
        }

        function getRandomLightColor() { // random color that will be visible on  black background
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[(Math.floor(Math.random() * 12) + 4)];
            }
            return color;
        }

        function getRandomColor() { // random color
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[(Math.floor(Math.random() * 16) + 0)];
            }
            return color;
        }

        function getRandomDarkColor() { // color that will be visible on a black background
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[(Math.floor(Math.random() * 12))];
            }
            return color;
        }

        function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
            let limit = granularity
            let shape_array = []
            for (let t = 0; t < limit; t++) {
                let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                circ.toRatio = t / limit
                circ.fromRatio = (limit - t) / limit
                shape_array.push(circ)
            }
            return (new Shape(shape_array))
        }

        let setup_canvas = document.getElementById('canvas') //getting canvas from document




        setUp(setup_canvas) // setting up canvas refrences, starting timer. 

        // object instantiation and creation happens here 

        class Icon {
            constructor(x, y) {
                this.listener = globalListener
                this.running = 0
                this.ran = 0
                this.body = new Circle(x, y, 20, getRandomColor())
                if (icons.length == 0) {
                    this.name = "Click to play Froggair" //getRandomColor()+getRandomColor()

                } else if (icons.length == 2) {
                    this.name = "" //getRandomColor()+getRandomColor()

                } else if (icons.length == 1) {
                    this.name = "Click to play Diggums" //getRandomColor()+getRandomColor()

                } else if (icons.length == 3) {
                    this.name = "Click to play LapJam" //getRandomColor()+getRandomColor()

                } else if (icons.length == 4) {
                    this.name = "Click to play Sand Sort" //getRandomColor()+getRandomColor()

                }else if (icons.length == 5) {
                    this.name = "Click to play Pomaohop" //getRandomColor()+getRandomColor()

                }
                this.marked = 0
                this.gamenum = icons.length
            }
            move(point) {
                this.body.x = point.x
                this.body.y = point.y
                for (let k = 0; k < icons.length; k++) {
                    for (let t = 0; t < icons.length; t++) {
                        if (this != icons[t]) {
                            if (icons[k].body.doesPerimeterTouch(icons[t].body)) {
                                let j = 0
                                while (icons[k].body.doesPerimeterTouch(icons[t].body)) {
                                    j++
                                    if (j > 20) {
                                        break
                                    }
                                    let ranx = (icons[k].body.x - icons[t].body.x) / 10
                                    let rany = (icons[k].body.y - icons[t].body.y) / 10
                                        // this.body.x+=ranx
                                        // this.body.y+=rany
                                    icons[t].body.x -= ranx
                                    icons[t].body.y -= rany
                                }

                            }
                        }
                    }
                }
            }
            run(booter) {

 if (booter.index == 5) {


    const snowflakeimg2 = new Image()
    snowflakeimg2.src = '' // "http://ditzbitz.com/snowflakes2.png"
    snowflakeimg2.onload = function () {
        snowflakeimg2.decode()
    }
    const snowflakeimg = new Image()
    snowflakeimg.src = '' // "http://ditzbitz.com/snowflakes.png"
    const bossflake = new Image()
    bossflake.src = '' // "http://ditzbitz.com/flake37.png"
    snowflakeimg.onload = function () {
        snowflakeimg.decode()
    }
    const spikeenemyimg = new Image()
    spikeenemyimg.src = '' // "http://ditzbitz.com/spikeenemyimg.png"
    spikeenemyimg.onload = function () {
        spikeenemyimg.decode()
    }
    const volcbg = new Image()
    volcbg.src = '' // "http://ditzbitz.com/vbg.png"
    volcbg.onload = function () {
        volcbg.decode()
    }
    const redcircleimg = new Image()
    redcircleimg.src = '' // "http://ditzbitz.com/smallredcircle.png"
    redcircleimg.onload = function () {
        redcircleimg.decode()
    }
    const bluecircleimg = new Image()
    bluecircleimg.src = '' // "http://ditzbitz.com/bluecircle.png"
    bluecircleimg.onload = function () {
        bluecircleimg.decode()
    }
    const smallyellowcircle = new Image()
    smallyellowcircle.src = '' // "http://ditzbitz.com/smallyellowcircle.png"
    smallyellowcircle.onload = function () {
        smallyellowcircle.decode()
    }

    const hilllump = new Image()
    hilllump.src = '' // "http://ditzbitz.com/hilllump.png"
    hilllump.onload = function () {
        hilllump.decode()
    }
    const title = new Image()
    title.src = '' // "http://ditzbitz.com/tittle.png"
    title.onload = function () {
        title.decode()
    }
    const crackfloorimg = new Image()
    crackfloorimg.src = '' // "http://ditzbitz.com/cracksheet.png"
    crackfloorimg.onload = function () {
        crackfloorimg.decode()
    }
    const pomaodownpaint = new Image()
    pomaodownpaint.src = '' // "http://ditzbitz.com/pomaodownpaint.png"
    pomaodownpaint.onload = function () {
        pomaodownpaint.decode()
    }
    const pomaodownpaintl = new Image()
    pomaodownpaintl.src = '' // "http://ditzbitz.com/pomaodownpaintl.png"
    pomaodownpaintl.onload = function () {
        pomaodownpaintl.decode()
    }
    const pomaodownpaintb = new Image()
    pomaodownpaintb.src = '' // "http://ditzbitz.com/pomaodownpaintb.png"
    pomaodownpaintb.onload = function () {
        pomaodownpaintb.decode()
    }
    const pomaodownpaintlb = new Image()
    pomaodownpaintlb.src = '' // "http://ditzbitz.com/pomaodownpaintlb.png"
    pomaodownpaintlb.onload = function () {
        pomaodownpaintlb.decode()
    }
    const propimg = new Image()
    propimg.src = '' // "http://ditzbitz.com/propoganda.png"
    propimg.onload = function () {
        propimg.decode()
    }
    const transfloor = new Image()
    transfloor.src = '' // "http://ditzbitz.com/hsemitrans.png"
    transfloor.onload = function () {
        transfloor.decode()
    }
    const hillshadowbad = new Image()
    hillshadowbad.src = '' // "http://ditzbitz.com/hillshadow.png"
    hillshadowbad.onload = function () {
        hillshadowbad.decode()
    }
    const hillshadow = new Image()
    hillshadow.src = '' // "http://ditzbitz.com/hillshadow2.png"
    hillshadow.onload = function () {
        hillshadow.decode()
    }
    // const floorimg = new Image()
    // floorimg.src = '' // "http://ditzbitz.com/floor4.png"
    const floorimg = new Image()
    floorimg.src = '' // "http://ditzbitz.com/floorD.png"
    floorimg.onload = function () {
        floorimg.decode()
    }
    const cloudimg = new Image()
    cloudimg.src = '' // "http://ditzbitz.com/cloudlist.png"
    const icloudimg = new Image()
    icloudimg.src = '' // "http://ditzbitz.com/invcloudlist.png"
    cloudimg.onload = function () {
        cloudimg.decode()
    }
    const batimg = new Image()
    batimg.src = '' // "http://ditzbitz.com/paintbat.png"
    batimg.onload = function () {
        batimg.decode()
    }
    const blockimg = new Image()
    blockimg.src = '' // "http://ditzbitz.com/block.png"
    blockimg.onload = function () {
        blockimg.decode()
    }
    const lvl2floorimg = new Image()
    lvl2floorimg.src = '' // "http://ditzbitz.com/floor5.png"
    lvl2floorimg.onload = function () {
        lvl2floorimg.decode()
    }
    const lvl3floorimg = new Image()
    lvl3floorimg.src = '' // "http://ditzbitz.com/bricks.png"
    lvl3floorimg.onload = function () {
        lvl3floorimg.decode()
    }
    // const lvl4floorimg = new Image()
    // lvl4floorimg.src = '' // "http://ditzbitz.com/floor7.png"
    const lvl4floorimg = new Image()
    lvl4floorimg.src = '' // "http://ditzbitz.com/floorpaintlvl4-3.png"
    lvl4floorimg.onload = function () {
        lvl4floorimg.decode()
    }
    const lvl4fwallimg = new Image()
    lvl4fwallimg.src = '' // "http://ditzbitz.com/wallpaintlvl4.png"
    const lvl5floorimg = new Image()
    lvl5floorimg.src = '' // "http://ditzbitz.com/desertfloor.png"
    const lvl6floorimg = new Image()
    lvl6floorimg.src = '' // "http://ditzbitz.com/floor9.png"
    // const walling = new Image()
    // walling.src = '' // "http://ditzbitz.com/wall.png"
    const walling = new Image()
    walling.src = '' // "http://ditzbitz.com/wallA.png"
    const lvl2walling = new Image()
    lvl2walling.src = '' // "http://ditzbitz.com/wall5.png"
    const lvl5walling = new Image()
    lvl5walling.src = '' // "http://ditzbitz.com/wall6.png"
    const nailimg = new Image()
    nailimg.src = '' // "http://ditzbitz.com/poundnail.png"
    const ballsprite = new Image()
    ballsprite.src = '' // "http://ditzbitz.com/ballsprite4.png"
    const ballspritelvl4 = new Image()
    ballspritelvl4.src = '' // "http://ditzbitz.com/ballsprite5.png"
    const eyeimg = new Image()
    eyeimg.src = '' // "http://ditzbitz.com/eyepaint.png"
    const eyeimgred = new Image()
    eyeimgred.src = '' // "http://ditzbitz.com/eyepaintred.png"

    const lvl4fifthsbasemusic = new Audio('baeao.mp3');
    const lvl1basemusic = new Audio('lvl1base.mp3');
    const lvl2basemusic = new Audio('lvl2base.mp3');
    const lvl9basemusic = new Audio('beastlyatomslap.mp3');
    const pipelevelbasemusic = new Audio('pipevault.mp3');
    const lvl7bosssong = new Audio('lvl7bosssong.mp3');
    const lvl4basemusic = new Audio('voidx.mp3');
    const level3basemusic = new Audio('lvl3basemusic.mp3');
    const lvl4bossmusic = new Audio('eyelowdiff.mp3');
    const lvl5basemusic = new Audio('lvl5basedrop.mp3');
    const lvl6bossmusic = new Audio('wormsign.mp3');
    const jazz = new Audio('gulpnoise.mp3');
    const jazz2 = new Audio('gulpnoise2.mp3');
    const spidermusic = new Audio('Mopao.mp3');
    const level10basemusic = new Audio('snow.mp3');
    const targoymusic = new Audio('pomo3.mp3');
    const lvl6music = new Audio('mountainsong.mp3');

    const jailswitchimgl = new Image()
    jailswitchimgl.src = '' // 'http://ditzbitz.com/switchl.png'
    const jailswitchimg = new Image()
    jailswitchimg.src = '' // 'http://ditzbitz.com/switch.png'

    const rampimg2 = new Image()
    rampimg2.src = '' // 'http://ditzbitz.com/paintramp2.png'

    const rampimg1 = new Image()
    rampimg1.src = '' // 'http://ditzbitz.com/paintramp1.png'

    const rampcurveimg1 = new Image()
    rampcurveimg1.src = '' // 'http://ditzbitz.com/paintrampcurve.png'

    const wormimg = new Image()
    wormimg.src = '' // 'http://ditzbitz.com/wormimg.png'
    const wormbossimg = new Image()
    wormbossimg.src = '' // 'http://ditzbitz.com/wormboss.png'

    const fruitsprites = new Image()
    fruitsprites.src = '' // 'http://ditzbitz.com/fruitsprites11.png'
    const cake = new Image()
    cake.src = '' // 'http://ditzbitz.com/Fruit 92 - Cake.png'
    const orbspritel = new Image()
    orbspritel.src = '' // 'http://ditzbitz.com/orbspritel.png'

    const orbsprite = new Image()
    orbsprite.src = '' // 'http://ditzbitz.com/orbsprite.png'

    // const fractalsheet = new Image()
    // fractalsheet.src = '' // 'http://ditzbitz.com/fractalsheet - 01.png'



    // const jumpometer = new Image()
    // jumpometer.src = '' // 'http://ditzbitz.com/jumpometer.png'

    const pomaospit = new Image()
    pomaospit.src = '' // 'http://ditzbitz.com/newpomaospit.png'

    // const pomaospitg= new Image()
    // pomaospitg.src = '' // 'http://ditzbitz.com/pomaospitg.png'

    const pomaospitb = new Image()
    pomaospitb.src = '' // 'http://ditzbitz.com/newspitb.png'

    // const pomaospitbg = new Image()
    // pomaospitbg.src = '' // 'http://ditzbitz.com/pomaospitbg.png'

    const pomaospitl = new Image()
    pomaospitl.src = '' // 'http://ditzbitz.com/newpomaospitl.png'
    // const pomaospitlg = new Image()
    // pomaospitlg.src = '' // 'http://ditzbitz.com/pomaospitlg.png'
    const pomaospitlb = new Image()
    pomaospitlb.src = '' // 'http://ditzbitz.com/newspitbl.png'
    // const pomaospitlbg = new Image()
    // pomaospitlbg.src = '' // 'http://ditzbitz.com/pomaospitblg.png'

    const pomaospitf = new Image()
    pomaospitf.src = '' // 'http://ditzbitz.com/newpomaospitflap.png'

    // const pomaospitfg = new Image()
    // pomaospitfg.src = '' // 'http://ditzbitz.com/pomaospitfg.png'

    const pomaospitfb = new Image()
    pomaospitfb.src = '' // 'http://ditzbitz.com/blushflapspitblush.png'

    // const pomaospitfbg = new Image()
    // pomaospitfbg.src = '' // 'http://ditzbitz.com/pomaospitfbg.png'

    const pomaospitfl = new Image()
    pomaospitfl.src = '' // 'http://ditzbitz.com/newpomaospitflapl.png'

    // const pomaospitflg = new Image()
    // pomaospitflg.src = '' // 'http://ditzbitz.com/pomaospitflg.png'


    const pomaospitflb = new Image()
    pomaospitflb.src = '' // 'http://ditzbitz.com/blushflapspitblushl.png'


    // const pomaospitflbg = new Image()
    // pomaospitflbg.src = '' // 'http://ditzbitz.com/pomaospitflbg.png'

    const pomaoflb = new Image()
    pomaoflb.src = '' // 'http://ditzbitz.com/pomaoblushflapleft.png'
    // const pomaoflbg = new Image()
    // pomaoflbg.src = '' // 'http://ditzbitz.com/pomaoflbg.png'

    const pomaoflbh = new Image()
    pomaoflbh.src = '' // 'http://ditzbitz.com/newblushsadflapl.png'

    // const pomaoflbhg = new Image()
    // pomaoflbhg.src = '' // 'http://ditzbitz.com/pomaofbhlg.png'

    const pomaoflh = new Image()
    pomaoflh.src = '' // 'http://ditzbitz.com/newpomaohfl.png'

    const pomaoflhg = new Image()
    pomaoflhg.src = '' // 'http://ditzbitz.com/pomaoflhg.png'

    const pomaofbh = new Image()
    pomaofbh.src = '' // 'http://ditzbitz.com/newblushsadflap.png'

    // const pomaofbhg = new Image()
    // pomaofbhg.src = '' // 'http://ditzbitz.com/pomaofbhg.png'

    const boysprites = new Image()
    boysprites.src = '' // 'http://ditzbitz.com/boisters2.png'

    const cactusimg = new Image()
    cactusimg.src = '' // 'http://ditzbitz.com/cactusdark.png'

    const cactusimgtop = new Image()
    cactusimgtop.src = '' // 'http://ditzbitz.com/cactustopdark.png'

    const pomomimg = new Image()
    pomomimg.src = '' // 'http://ditzbitz.com/pomom.png'

    const grandpoimg = new Image()
    grandpoimg.src = '' // 'http://ditzbitz.com/grandpo2.png'

    const blurmaoimg = new Image()
    blurmaoimg.src = '' // 'http://ditzbitz.com/blurmao.png'
    const blurmaoimgl = new Image()
    blurmaoimgl.src = '' // 'http://ditzbitz.com/blurmoal.png'

    const grandpoimgl = new Image()
    grandpoimgl.src = '' // 'http://ditzbitz.com/grandpo2l2.png'

    const poatriceimg = new Image()
    poatriceimg.src = '' // 'http://ditzbitz.com/poatrice.png'

    const poatriceimgl = new Image()
    poatriceimgl.src = '' // 'http://ditzbitz.com/poatricel.png'

    const gramaoimg = new Image()
    gramaoimg.src = '' // 'http://ditzbitz.com/gramao.png'


    const jomaoimg = new Image()
    jomaoimg.src = '' // 'http://ditzbitz.com/jomao.png'
    const jomaoimgl = new Image()
    jomaoimgl.src = '' // 'http://ditzbitz.com/jomaol.png'
    const rebellionbossimg = new Image()
    rebellionbossimg.src = '' // 'http://ditzbitz.com/eyepatchtwoscarqueen.png'
    const rebellionbossimgleft = new Image()
    rebellionbossimgleft.src = '' // 'http://ditzbitz.com/eyepatchlessqueen.png'
    const peamaoimg = new Image()
    peamaoimg.src = '' // 'http://ditzbitz.com/peamao.png'
    const peamaoimgl = new Image()
    peamaoimgl.src = '' // 'http://ditzbitz.com/peamaol.png'
    const podmaoimg = new Image()
    podmaoimg.src = '' // 'http://ditzbitz.com/podmao.png'
    const podmaoimgl = new Image()
    podmaoimgl.src = '' // 'http://ditzbitz.com/podmaol.png'

    const treemaoimg = new Image()
    treemaoimg.src = '' // 'http://ditzbitz.com/treemao.png'
    const treemaoimgl = new Image()
    treemaoimgl.src = '' // 'http://ditzbitz.com/treemaol.png'

    const pawmaoimg = new Image()
    pawmaoimg.src = '' // 'http://ditzbitz.com/pawmao.png'

    const prisoner1img = new Image()
    prisoner1img.src = '' // 'http://ditzbitz.com/prisoner1.png'

    const prisoner2img = new Image()
    prisoner2img.src = '' // 'http://ditzbitz.com/prisoner2.png'

    const prisoner3img = new Image()
    prisoner3img.src = '' // 'http://ditzbitz.com/prisoner3.png'

    const pomarine = new Image()
    pomarine.src = '' // 'http://ditzbitz.com/pomarine.png'


    const pomarinel = new Image()
    pomarinel.src = '' // 'http://ditzbitz.com/pomarinel.png'


    const paintedbackground = new Image()
    paintedbackground.src = '' // 'http://ditzbitz.com/bg5.png'
    const paintedbackgroundlvl3 = new Image()
    paintedbackgroundlvl3.src = '' // 'http://ditzbitz.com/bg7.png'
    const paintedbackgroundlvl4 = new Image()
    paintedbackgroundlvl4.src = '' // 'http://ditzbitz.com/bg6.png'
    const wallpaperimg = new Image()
    wallpaperimg.src = '' // 'http://ditzbitz.com/wallpaper.jpg'
    // const dealwithit = new Image()
    // dealwithit.src = '' // 'http://ditzbitz.com/dealwithit.png'
    const redwallpaperimg = new Image()
    redwallpaperimg.src = '' // 'http://ditzbitz.com/redwall.png'
    const dessertimg = new Image()
    dessertimg.src = '' // 'http://ditzbitz.com/desertfloor2.png'

    const lumaoimg = new Image()
    lumaoimg.src = '' // 'http://ditzbitz.com/lumao.png'

    const lumaolimg = new Image()
    lumaolimg.src = '' // 'http://ditzbitz.com/lumaol.png'

    const pomaoimg = new Image()
    pomaoimg.src = '' // 'http://ditzbitz.com/rcpomaolpx.png'

    const pobo1img = new Image()
    pobo1img.src = '' // 'http://ditzbitz.com/pobo1.png'

    const pobo2img = new Image()
    pobo2img.src = '' // 'http://ditzbitz.com/pobo2.png'

    const pobo3img = new Image()
    pobo3img.src = '' // 'http://ditzbitz.com/pobo3.png'
    // const pomaoimgx = new Image()
    // pomaoimgx.src = '' // 'http://ditzbitz.com/pomaoimgx.png'


    const pomaoimgg = new Image()
    pomaoimgg.src = '' // 'http://ditzbitz.com/pomaog.png'

    const pomaoimggl = new Image()
    pomaoimggl.src = '' // 'http://ditzbitz.com/pomaogl.png'

    const pomaofh = new Image()
    pomaofh.src = '' // 'http://ditzbitz.com/newpomaohf.png'

    // const pomaofhg = new Image()
    // pomaofhg.src = '' // 'http://ditzbitz.com/pomaofhg.png'

    const pomaoimgh = new Image()
    pomaoimgh.src = '' // 'http://ditzbitz.com/newpomaoh.png'
    // const pomaoimghg = new Image()
    // pomaoimghg.src = '' // 'http://ditzbitz.com/pomaohg.png'

    const pomaoimglhb = new Image()
    pomaoimglhb.src = '' // 'http://ditzbitz.com/newbh.png'
    // const pomaoimglhbg = new Image()
    // pomaoimglhbg.src = '' // 'http://ditzbitz.com/pomaolhbg.png'
    const pomaoimghb = new Image()
    pomaoimghb.src = '' // 'http://ditzbitz.com/newbhl.png'
    // const pomaoimghbg = new Image()
    // pomaoimghbg.src = '' // 'http://ditzbitz.com/pomaohbg.png'

    const pomaoimglh = new Image()
    pomaoimglh.src = '' // 'http://ditzbitz.com/newpomaolh.png'
    const pomaoimglhg = new Image()
    pomaoimglhg.src = '' // 'http://ditzbitz.com/pomaolhg.png'
    const pomaoimgb = new Image()
    pomaoimgb.src = '' // 'http://ditzbitz.com/newb.png'
    const pomaoimgbg = new Image()
    pomaoimgbg.src = '' // 'http://ditzbitz.com/pomaobg.png'

    const seedegg = new Image()
    seedegg.src = '' // 'http://ditzbitz.com/seedeggpaint3.png'
    const seedeggf = new Image()
    seedeggf.src = '' // 'http://ditzbitz.com/seedeggpaintfirel.png'
    const seedeggfl = new Image()
    seedeggfl.src = '' // 'http://ditzbitz.com/seedeggpaintfire.png'
    const pomaoimgl = new Image()
    pomaoimgl.src = '' // 'http://ditzbitz.com/rcpomaolpl.png'
    const pomaoimglg = new Image()
    pomaoimglg.src = '' // 'http://ditzbitz.com/pomaolg.png'
    const pomaoimgbl = new Image()
    pomaoimgbl.src = '' // 'http://ditzbitz.com/newbl.png'
    const pomaoimgblg = new Image()
    pomaoimgblg.src = '' // 'http://ditzbitz.com/pomaoblg.png'
    // const mangosteen = new Image()
    // mangosteen.src = '' // 'http://ditzbitz.com/Fruit 03 - Mangosteen.png'

    const pomaoimgup = new Image()
    pomaoimgup.src = '' // 'http://ditzbitz.com/newpomaoup.png'
    const healthbase = new Image()
    healthbase.src = '' // 'http://ditzbitz.com/healthbase.png'
    const healthdot = new Image()
    healthdot.src = '' // 'http://ditzbitz.com/healthdot.png'
    const pomaoimgupg = new Image()
    pomaoimgupg.src = '' // 'http://ditzbitz.com/pomaoupg.png'
    const pomaoimglup = new Image()
    pomaoimglup.src = '' // 'http://ditzbitz.com/newpomaoupl.png'
    const pomaoimglupg = new Image()
    pomaoimglupg.src = '' // 'http://ditzbitz.com/pomaouplg.png'

    const pomaoimgupb = new Image()
    pomaoimgupb.src = '' // 'http://ditzbitz.com/eatblush.png'
    const pomaoimgupbg = new Image()
    pomaoimgupbg.src = '' // 'http://ditzbitz.com/pomaoupbg.png'
    const pomaoimglupb = new Image()
    pomaoimglupb.src = '' // 'http://ditzbitz.com/eatblushl.png'
    const pomaoimglupbg = new Image()
    pomaoimglupbg.src = '' // 'http://ditzbitz.com/pomaoupblg.png'
    const pomaof = new Image()
    pomaof.src = '' // 'http://ditzbitz.com/pomaofpaint.png'
    const pomaofg = new Image()
    pomaofg.src = '' // 'http://ditzbitz.com/pomaofg.png'
    const pomaofl = new Image()
    pomaofl.src = '' // 'http://ditzbitz.com/pomaofpaintl.png'
    const pomaoflg = new Image()
    pomaoflg.src = '' // 'http://ditzbitz.com/pomaoflg.png'
    const pomaofb = new Image()
    pomaofb.src = '' // 'http://ditzbitz.com/pomaoblushflapright.png'
    const pomaofbg = new Image()
    pomaofbg.src = '' // 'http://ditzbitz.com/pomaofbg.png'
    const ramp90 = new Image()
    ramp90.src = '' // 'http://ditzbitz.com/paintramp90.png'
    const ramp90l = new Image()
    ramp90l.src = '' // 'http://ditzbitz.com/paintramp90l.png'

    const jomaoholoimg = new Image()
    jomaoholoimg.src = '' // 'http://ditzbitz.com/jomaostripholo.png'

    const jomaoholoimgl = new Image()
    jomaoholoimgl.src = '' // 'http://ditzbitz.com/jomaostripholol.png'

    const gamepadAPI = {
        controller: {},
        turbo: true,
        connect: function (evt) {
            if (navigator.getGamepads()[0] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[1] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[2] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[3] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            }
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i] === null) {
                    continue;
                }
                if (!gamepads[i].connected) {
                    continue;
                }
            }
        },
        disconnect: function (evt) {
            gamepadAPI.turbo = false;
            delete gamepadAPI.controller;
        },
        update: function () {
            gamepadAPI.controller = navigator.getGamepads()[0]
            gamepadAPI.buttonsCache = [];// clear the buttons cache
            for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) {// move the buttons status from the previous frame to the cache
                gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
            }
            gamepadAPI.buttonsStatus = [];// clear the buttons status
            var c = gamepadAPI.controller || {}; // get the gamepad object
            var pressed = [];
            if (c.buttons) {
                for (var b = 0, t = c.buttons.length; b < t; b++) {// loop through buttons and push the pressed ones to the array
                    if (c.buttons[b].pressed) {
                        pressed.push(gamepadAPI.buttons[b]);
                    }
                }
            }
            var axes = [];
            if (c.axes) {
                for (var a = 0, x = c.axes.length; a < x; a++) {// loop through axes and push their values to the array
                    axes.push(c.axes[a].toFixed(2));
                }
            }
            gamepadAPI.axesStatus = axes;// assign received values
            gamepadAPI.buttonsStatus = pressed;
            // console.log(pressed); // return buttons for debugging purposes
            return pressed;
        },
        buttonPressed: function (button, hold) {
            var newPress = false;
            for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) {// loop through pressed buttons
                if (gamepadAPI.buttonsStatus[i] == button) {// if we found the button we're looking for...
                    newPress = true;// set the boolean variable to true
                    if (!hold) {// if we want to check the single press
                        for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) {// loop through the cached states from the previous frame
                            if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                newPress = false;
                            }
                        }
                    }
                }
            }
            return newPress;
        },
        buttons: [
            'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
        ],
        buttonsCache: [],
        buttonsStatus: [],
        axesStatus: []
    };
    let canvas
    let canvas_context
    let keysPressed = {}
    let FLEX_engine
    let TIP_engine = {}
    let XS_engine
    let YS_engine
    TIP_engine.x = 350
    TIP_engine.y = 350
    class Point {
        constructor(x, y) {
            this.x = x
            this.y = y
            this.radius = 0
        }
        pointDistance(point) {
            return (new LineOP(this, point, "transparent", 0)).hypotenuse()
        }
    }

    class Vector{ // vector math and physics if you prefer this over vector components on circles
        constructor(object = (new Point(0,0)), xmom = 0, ymom = 0){
            this.xmom = xmom
            this.ymom = ymom
            this.object = object
        }
        isToward(point){
            let link = new LineOP(this.object, point)
            let dis1 = link.sqrDis()
            let dummy = new Point(this.object.x+this.xmom, this.object.y+this.ymom)
            let link2 = new LineOP(dummy, point)
            let dis2 = link2.sqrDis()
            if(dis2 < dis1){
                return true
            }else{
                return false
            }
        }
        rotate(angleGoal){
            let link = new Line(this.xmom, this.ymom, 0,0)
            let length = link.hypotenuse()
            let x = (length * Math.cos(angleGoal))
            let y = (length * Math.sin(angleGoal))
            this.xmom = x
            this.ymom = y
        }
        magnitude(){
            return (new Line(this.xmom, this.ymom, 0,0)).hypotenuse()
        }
        normalize(size = 1){
            let magnitude = this.magnitude()
            this.xmom/=magnitude
            this.ymom/=magnitude
            this.xmom*=size
            this.ymom*=size
        }
        multiply(vect){
            let point = new Point(0,0)
            let end = new Point(this.xmom+vect.xmom, this.ymom+vect.ymom)
            return point.pointDistance(end)
        }
        add(vect){
            return new Vector(this.object, this.xmom+vect.xmom, this.ymom+vect.ymom)
        }
        subtract(vect){
            return new Vector(this.object, this.xmom-vect.xmom, this.ymom-vect.ymom)
        }
        divide(vect){
            return new Vector(this.object, this.xmom/vect.xmom, this.ymom/vect.ymom) //be careful with this, I don't think this is right
        }
        draw(){
            let dummy = new Point(this.object.x+this.xmom, this.object.y+this.ymom)
            let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
            link.draw()
        }
    }
    class Line {
        constructor(x, y, x2, y2, color, width) {
            this.x1 = x
            this.y1 = y
            this.x2 = x2
            this.y2 = y2
            this.color = color
            this.width = width
        }
        angle() {
            return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
        }
        squareDistance() {
            let xdif = this.x1 - this.x2
            let ydif = this.y1 - this.y2
            let squareDistance = (xdif * xdif) + (ydif * ydif)
            return squareDistance
        }
        hypotenuse() {
            let xdif = this.x1 - this.x2
            let ydif = this.y1 - this.y2
            let hypotenuse = (xdif * xdif) + (ydif * ydif)
            if(hypotenuse < 10000000-1){
                if(hypotenuse > 1000){
                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                }else{
                return squaretable[`${Math.round(hypotenuse)}`]
                }
            }else{
                return Math.sqrt(hypotenuse)
            }
        }
        draw() {
            let linewidthstorage = canvas_context.lineWidth
            canvas_context.strokeStyle = this.color
            canvas_context.lineWidth = this.width
            canvas_context.beginPath()
            canvas_context.moveTo(this.x1, this.y1)
            canvas_context.lineTo(this.x2, this.y2)
            canvas_context.stroke()
            canvas_context.lineWidth = linewidthstorage
        }
    }
    class LineOP {
        constructor(object, target, color, width) {
            this.object = object
            this.target = target
            this.color = color
            this.width = width
        }
        squareDistance() {
            let xdif = this.object.x - this.target.x
            let ydif = this.object.y - this.target.y
            let squareDistance = (xdif * xdif) + (ydif * ydif)
            return squareDistance
        }
        hypotenuse() {
            let xdif = this.object.x - this.target.x
            let ydif = this.object.y - this.target.y
            let hypotenuse = (xdif * xdif) + (ydif * ydif)
            if(hypotenuse < 10000000-1){
                if(hypotenuse > 1000){
                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                }else{
                return squaretable[`${Math.round(hypotenuse)}`]
                }
            }else{
                return Math.sqrt(hypotenuse)
            }
        }
        angle() {
            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
        }
        draw() {
            let linewidthstorage = canvas_context.lineWidth
            canvas_context.strokeStyle = this.color
            canvas_context.lineWidth = this.width
            canvas_context.beginPath()
            canvas_context.moveTo(this.object.x, this.object.y)
            canvas_context.lineTo(this.target.x, this.target.y)
            canvas_context.stroke()
            canvas_context.lineWidth = linewidthstorage
        }
    }
    class Triangle {
        constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
            this.x = x
            this.y = y
            this.color = color
            this.length = length
            this.x1 = this.x + this.length * leg1Ratio
            this.x2 = this.x - this.length * leg2Ratio
            this.tip = this.y - this.length * heightRatio
            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
            this.fill = fill
            this.stroke = strokeWidth
        }
        draw() {
            canvas_context.strokeStyle = this.color
            canvas_context.stokeWidth = this.stroke
            canvas_context.beginPath()
            canvas_context.moveTo(this.x, this.y)
            canvas_context.lineTo(this.x1, this.y)
            canvas_context.lineTo(this.x, this.tip)
            canvas_context.lineTo(this.x2, this.y)
            canvas_context.lineTo(this.x, this.y)
            if (this.fill == 1) {
                canvas_context.fill()
            }
            canvas_context.stroke()
            canvas_context.closePath()
        }
        isPointInside(point) {
            if (point.x <= this.x1) {
                if (point.y >= this.tip) {
                    if (point.y <= this.y) {
                        if (point.x >= this.x2) {
                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                            this.basey = point.y - this.tip
                            this.basex = point.x - this.x
                            if (this.basex == 0) {
                                return true
                            }
                            this.slope = this.basey / this.basex
                            if (this.slope >= this.accept1) {
                                return true
                            } else if (this.slope <= this.accept2) {
                                return true
                            }
                        }
                    }
                }
            }
            return false
        }
    }
    class Rectangle {
        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
            this.x = x
            this.y = y
            this.height = height
            this.width = width
            this.color = color
            this.xmom = 0
            this.ymom = 0
            this.stroke = stroke
            this.strokeWidth = strokeWidth
            this.fill = fill
        }
        draw() {
            canvas_context.fillStyle = this.color
            canvas_context.fillRect(this.x, this.y, this.width, this.height)
        }
        move() {
            this.x += this.xmom
            this.y += this.ymom
        }
        isPointInside(point) {
            if (point.x >= this.x) {
                if (point.y >= this.y) {
                    if (point.x <= this.x + this.width) {
                        if (point.y <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            if (point.x + point.radius >= this.x) {
                if (point.y + point.radius >= this.y) {
                    if (point.x - point.radius <= this.x + this.width) {
                        if (point.y - point.radius <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
    }
    class Circle {
        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
            this.x = x
            this.y = y
            this.radius = radius
            this.color = color
            this.xmom = xmom
            this.symom = 0
            this.sxmom = 0
            this.ymom = ymom
            this.friction = friction
            this.reflect = reflect
            this.strokeWidth = strokeWidth
            this.strokeColor = strokeColor
        }
        draw() {
            canvas_context.lineWidth = this.strokeWidth
            canvas_context.strokeStyle = this.color
            canvas_context.beginPath();
            if (this.radius > 0) {
                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                canvas_context.fillStyle = this.color
                canvas_context.fill()
                canvas_context.stroke();
            } else {
                console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
            }
        }
        smove(){
            this.x += this.sxmom
            this.y += this.symom
            if(this ==  pomaos[0].body){

                canvas_context.translate(-this.sxmom, -this.symom)
            }
        }
        move() {
            if(this == pomaos[0].body){

                
            canvas_context.translate(-this.xmom, -this.ymom)
            }
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
        }
        unmove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x -= this.xmom
            this.y -= this.ymom
        }
        frictiveMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
            this.xmom *= this.friction
            this.ymom *= this.friction
        }
        frictiveunMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.xmom /= this.friction
            this.ymom /= this.friction
            this.x -= this.xmom
            this.y -= this.ymom
        }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }
    } 
    class CircleRing {
        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
            this.x = x
            this.y = y
            this.radius = radius
            this.color = color
            this.xmom = xmom
            this.ymom = ymom
            this.friction = friction
            this.reflect = reflect
            this.strokeWidth = 10
            this.strokeColor = strokeColor
        }
        draw() {
            canvas_context.lineWidth = this.strokeWidth
            canvas_context.strokeStyle = this.color
            canvas_context.beginPath();
            if (this.radius > 0) {
                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                canvas_context.fillStyle = this.color
                canvas_context.fill()
                canvas_context.stroke();
            } else {
                console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
            }
        }
        move() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
        }
        unmove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x -= this.xmom
            this.y -= this.ymom
        }
        frictiveMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
            this.xmom *= this.friction
            this.ymom *= this.friction
        }
        frictiveunMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.xmom /= this.friction
            this.ymom /= this.friction
            this.x -= this.xmom
            this.y -= this.ymom
        }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }
    } class Polygon {
        constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
            if (sides < 2) {
                sides = 2
            }
            this.reflect = reflect
            this.xmom = xmom
            this.ymom = ymom
            this.body = new Circle(x, y, size - (size * .293), "transparent")
            this.nodes = []
            this.angle = angle
            this.size = size
            this.color = color
            this.angleIncrement = (Math.PI * 2) / sides
            this.sides = sides
            for (let t = 0; t < sides; t++) {
                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                this.nodes.push(node)
                this.angle += this.angleIncrement
            }
        }
        isPointInside(point) { // rough approximation
            this.body.radius = this.size - (this.size * .293)
            if (this.sides <= 2) {
                return false
            }
            this.areaY = point.y - this.body.y
            this.areaX = point.x - this.body.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                return true
            }
            return false
        }
        move() {
            if (this.reflect == 1) {
                if (this.body.x > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.body.y > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.body.x < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.body.y < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.body.x += this.xmom
            this.body.y += this.ymom
        }
        draw(nodes) {
            this.nodes = [...nodes]
            // this.nodes = []
            // this.angleIncrement = (Math.PI * 2) / this.sides
            // this.body.radius = this.size - (this.size * .293)
            // for (let t = 0; t < this.sides; t++) {
            //     let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
            //     this.nodes.push(node)
            //     this.angle += this.angleIncrement
            // }
            canvas_context.strokeStyle = this.color
            canvas_context.fillStyle = this.color
            canvas_context.lineWidth = 0
            canvas_context.beginPath()
            canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
            for (let t = 1; t < this.nodes.length; t++) {
                canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
            }
            canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
            canvas_context.fill()
            canvas_context.stroke()
            canvas_context.closePath()
        }
    }
    class Shape {
        constructor(shapes) {
            this.shapes = shapes
        }
        draw() {
            for (let t = 0; t < this.shapes.length; t++) {
                this.shapes[t].draw()
            }
        }
        isPointInside(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].isPointInside(point)) {
                    return true
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].doesPerimeterTouch(point)) {
                    return true
                }
            }
            return false
        }
        innerShape(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].doesPerimeterTouch(point)) {
                    return this.shapes[t]
                }
            }
            return false
        }
        isInsideOf(box) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (box.isPointInside(this.shapes[t])) {
                    return true
                }
            }
            return false
        }
        adjustByFromDisplacement(x,y) {
            for (let t = 0; t < this.shapes.length; t++) {
                if(typeof this.shapes[t].fromRatio == "number"){
                    this.shapes[t].x+=x*this.shapes[t].fromRatio
                    this.shapes[t].y+=y*this.shapes[t].fromRatio
                }
            }
        }
        adjustByToDisplacement(x,y) {
            for (let t = 0; t < this.shapes.length; t++) {
                if(typeof this.shapes[t].toRatio == "number"){
                    this.shapes[t].x+=x*this.shapes[t].toRatio
                    this.shapes[t].y+=y*this.shapes[t].toRatio
                }
            }
        }
        mixIn(arr){
            for(let t = 0;t<arr.length;t++){
                for(let k = 0;k<arr[t].shapes.length;k++){
                    this.shapes.push(arr[t].shapes[k])
                }
            }
        }
        push(object) {
            this.shapes.push(object)
        }
    }

    class Spring {
        constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
            if (body == 0) {
                this.body = new Circle(x, y, radius, color)
                this.anchor = new Circle(x, y, radius, color)
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                this.length = length
            } else {
                this.body = body
                this.anchor = new Circle(x, y, radius, color)
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                this.length = length
            }
            this.gravity = gravity
            this.width = width
        }
        balance() {
            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
            if (this.beam.hypotenuse() < this.length) {
                this.body.xmom += (this.body.x - this.anchor.x) / this.length
                this.body.ymom += (this.body.y - this.anchor.y) / this.length
                this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
            } else {
                this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
            }
            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
        }
        draw() {
            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
            this.beam.draw()
            this.body.draw()
            this.anchor.draw()
        }
        move() {
            this.anchor.ymom += this.gravity
            this.anchor.move()
        }

    }  
    class SpringOP {
        constructor(body, anchor, length, width = 3, color = body.color) {
            this.body = body
            this.anchor = anchor
            this.beam = new LineOP(body, anchor, color, width)
            this.length = length
        }
        balance() {
            if (this.beam.hypotenuse() < this.length) {
                this.body.xmom += ((this.body.x - this.anchor.x) / this.length) 
                this.body.ymom += ((this.body.y - this.anchor.y) / this.length) 
                this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length) 
                this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length) 
            } else if (this.beam.hypotenuse() > this.length) {
                this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
                this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
                this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
                this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
            }

            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
        }
        draw() {
            this.beam.draw()
        }
        move() {
            //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
        }
    }

    class Color {
        constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
            this.hue = baseColor
            if (red != -1 && green != -1 && blue != -1) {
                this.r = red
                this.g = green
                this.b = blue
                if (alpha != 1) {
                    if (alpha < 1) {
                        this.alpha = alpha
                    } else {
                        this.alpha = alpha / 255
                        if (this.alpha > 1) {
                            this.alpha = 1
                        }
                    }
                }
                if (this.r > 255) {
                    this.r = 255
                }
                if (this.g > 255) {
                    this.g = 255
                }
                if (this.b > 255) {
                    this.b = 255
                }
                if (this.r < 0) {
                    this.r = 0
                }
                if (this.g < 0) {
                    this.g = 0
                }
                if (this.b < 0) {
                    this.b = 0
                }
            } else {
                this.r = 0
                this.g = 0
                this.b = 0
            }
        }
        normalize() {
            if (this.r > 255) {
                this.r = 255
            }
            if (this.g > 255) {
                this.g = 255
            }
            if (this.b > 255) {
                this.b = 255
            }
            if (this.r < 0) {
                this.r = 0
            }
            if (this.g < 0) {
                this.g = 0
            }
            if (this.b < 0) {
                this.b = 0
            }
        }
        randomLight() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(Math.random() * 12) + 4)];
            }
            var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
            return color;
        }
        randomDark() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(Math.random() * 12))];
            }
            var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
            return color;
        }
        random() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(Math.random() * 16))];
            }
            var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
            return color;
        }
    }
    class Softbody { //buggy, spins in place
        constructor(x, y, radius, color, size, members = 10, memberLength = 5, force = 10, gravity = 0) {
            this.springs = []
            this.pin = new Circle(x, y, radius, color)
            this.points = []
            this.flop = 0
            let angle = 0
            this.size = size 
            let line = new Line((Math.cos(angle)*size), (Math.sin(angle)*size), (Math.cos(angle+ ((Math.PI*2)/members))*size), (Math.sin(angle+ ((Math.PI*2)/members))*size) )
            let distance = line.hypotenuse()
            for(let t =0;t<members;t++){
                let circ = new Circle(x+(Math.cos(angle)*size), y+(Math.sin(angle)*size), radius, color)
                circ.reflect = 1
                circ.bigbody = new Circle(x+(Math.cos(angle)*size), y+(Math.sin(angle)*size), distance, color)
                circ.draw()
                circ.touch = []
                this.points.push(circ)
                angle += ((Math.PI*2)/members)
            }

            for(let t =0;t<this.points.length;t++){
                for(let k =0;k<this.points.length;k++){
                    if(t!=k){
                        if(this.points[k].bigbody.doesPerimeterTouch(this.points[t])){
                        if(!this.points[k].touch.includes(t) && !this.points[t].touch.includes(k)){
                                let spring = new SpringOP(this.points[k], this.points[t], (size*Math.PI)/members, 2, color)
                                this.points[k].touch.push(t)
                                this.points[t].touch.push(k)
                                this.springs.push(spring)
                                spring.beam.draw()
                            }
                        }
                    }
                }
            }

            // console.log(this)

            // this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
            // this.springs.push(this.spring)
            // for (let k = 0; k < members; k++) {
            //     this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
            //     if (k < members - 1) {
            //         this.springs.push(this.spring)
            //     } else {
            //         this.spring.anchor = this.pin
            //         this.springs.push(this.spring)
            //     }
            // }
            this.forceConstant = force
            this.centroid = new Circle(0, 0, 10, "red")
        }
        circularize() {
            this.xpoint = 0
            this.ypoint = 0
            for (let s = 0; s < this.springs.length; s++) {
                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
            }
            this.centroid.x = this.xpoint
            this.centroid.y = this.ypoint
            this.angle = 0
            this.angleIncrement = (Math.PI * 2) / this.springs.length
            for (let t = 0; t < this.points.length; t++) {
                this.points[t].x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                this.points[t].y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                this.angle += this.angleIncrement 
            }
        }
        balance() {
            this.xpoint = 0
            this.ypoint = 0
            for (let s = 0; s < this.points.length; s++) {
                this.xpoint += (this.points[s].x / this.points.length)
                this.ypoint += (this.points[s].y / this.points.length)
            }
            this.centroid.x = this.xpoint
            this.centroid.y = this.ypoint
            // this.centroid.x += TIP_engine.x / this.points.length
            // this.centroid.y += TIP_engine.y / this.points.length
            for (let s = 0; s < this.points.length; s++) {
                this.link = new LineOP(this.points[s], this.centroid, 0, "transparent")
                if (this.link.hypotenuse() != 0) {

                    if(this.size < this.link.hypotenuse()){
                        this.points[s].xmom -= (Math.cos(this.link.angle())*(this.link.hypotenuse())) * this.forceConstant*.1
                        this.points[s].ymom -= (Math.sin(this.link.angle())*(this.link.hypotenuse())) * this.forceConstant*.1
                    }else{
                        this.points[s].xmom += (Math.cos(this.link.angle())*(this.link.hypotenuse())) * this.forceConstant*.1
                        this.points[s].ymom += (Math.sin(this.link.angle())*(this.link.hypotenuse())) * this.forceConstant*.1
                    }

                    // this.points[s].xmom += (((this.points[s].x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                    // this.points[s].ymom += (((this.points[s].y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                }
            }
            if(this.flop%2 == 0){
                for (let s =  0; s < this.springs.length; s++) {
                    this.springs[s].balance()
                }
            }else{
                for (let s = this.springs.length-1;s>=0; s--) {
                    this.springs[s].balance()
                }
            }
            for (let s = 0; s < this.points.length; s++) {
                this.points[s].move()
                this.points[s].draw()
            }
            for (let s =  0; s < this.springs.length; s++) {
                this.springs[s].draw()
            }
            this.centroid.draw()
        }
    }
    class Observer {
        constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
            this.body = new Circle(x, y, radius, color)
            this.color = color
            this.ray = []
            this.rayrange = range
            this.globalangle = Math.PI
            this.gapangle = angle
            this.currentangle = 0
            this.obstacles = []
            this.raymake = rays
        }
        beam() {
            this.currentangle = this.gapangle / 2
            for (let k = 0; k < this.raymake; k++) {
                this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                ray.collided = 0
                ray.lifespan = this.rayrange - 1
                this.ray.push(ray)
            }
            for (let f = 0; f < this.rayrange; f++) {
                for (let t = 0; t < this.ray.length; t++) {
                    if (this.ray[t].collided < 1) {
                        this.ray[t].move()
                        for (let q = 0; q < this.obstacles.length; q++) {
                            if (this.obstacles[q].isPointInside(this.ray[t])) {
                                this.ray[t].collided = 1
                            }
                        }
                    }
                }
            }
        }
        draw() {
            this.beam()
            this.body.draw()
            canvas_context.lineWidth = 1
            canvas_context.fillStyle = this.color
            canvas_context.strokeStyle = this.color
            canvas_context.beginPath()
            canvas_context.moveTo(this.body.x, this.body.y)
            for (let y = 0; y < this.ray.length; y++) {
                canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                canvas_context.lineTo(this.body.x, this.body.y)
            }
            canvas_context.stroke()
            canvas_context.fill()
            this.ray = []
        }
    }
    function setUp(canvas_pass, style = "#AAAAAA") {
        canvas = canvas_pass
        canvas_context = canvas.getContext('2d');
        canvas.style.background = style
        document.addEventListener('keydown', (event) => {
            keysPressed[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            delete keysPressed[event.key];
        });
        window.addEventListener('pointerdown', e => {
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine
            // example usage: if(object.isPointInside(TIP_engine)){ take action }
        });
        window.addEventListener('pointermove', continued_stimuli);

        window.addEventListener('pointerup', e => {
            // window.removeEventListener("pointermove", continued_stimuli);
        })
        function continued_stimuli(e) {
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine
        }
    }
    function gamepad_control(object, speed = 1) { // basic control for objects using the controler
//         console.log(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
        if (typeof object.body != 'undefined') {
            if(typeof (gamepadAPI.axesStatus[1]) != 'undefined'){
                if(typeof (gamepadAPI.axesStatus[0]) != 'undefined'){
                object.body.x += (gamepadAPI.axesStatus[0] * speed)
                object.body.y += (gamepadAPI.axesStatus[1] * speed)
                }
            }
        } else if (typeof object != 'undefined') {
            if(typeof (gamepadAPI.axesStatus[1]) != 'undefined'){
                if(typeof (gamepadAPI.axesStatus[0]) != 'undefined'){
                object.x += (gamepadAPI.axesStatus[0] * speed)
                object.y += (gamepadAPI.axesStatus[1] * speed)
                }
            }
        }
    }
    function control(object, speed = 1) { // basic control for objects
        if (typeof object.body != 'undefined') {
            if (keysPressed['w']) {
                object.body.y -= speed
            }
            if (keysPressed['d']) {
                object.body.x += speed
            }
            if (keysPressed['s']) {
                object.body.y += speed
            }
            if (keysPressed['a']) {
                object.body.x -= speed
            }
        } else if (typeof object != 'undefined') {
            if (keysPressed['w']) {
                object.y -= speed
            }
            if (keysPressed['d']) {
                object.x += speed
            }
            if (keysPressed['s']) {
                object.y += speed
            }
            if (keysPressed['a']) {
                object.x -= speed
            }
        }
    }
    function getRandomLightColor() { // random color that will be visible on  black background
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 12) + 4)];
        }
        return color;
    }
    function getRandomColor() { // random color
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 16) + 0)];
        }
        return color;
    }
    function getRandomDarkColor() {// color that will be visible on a black background
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 9))];
        }
        return color;
    }
    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
            let limit = granularity
            let shape_array = []
            for (let t = 0; t < limit; t++) {
                let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                circ.toRatio = t/limit
                circ.fromRatio = (limit-t)/limit
                shape_array.push(circ)
            }
            return (new Shape(shape_array))
    }

                    let setup_canvas = document.createElement("CANVAS");
                    setup_canvas.width = 700
                    setup_canvas.height = 700
                    setup_canvas.hidden = true

    setUp(setup_canvas) // setting up canvas refrences, starting timer. 

    // object instantiation and creation happens here 
    

    let cheats = {}
    let hot = 0

    class Health {
        constructor(pomao) {
            this.pomao = pomao
            this.rays = []
            this.body = new Circle(this.pomao.body.x - 575, this.pomao.body.y - 300, 27.5, "red")
        }
        draw() {
            if(cheats.harmless == 1){
                this.pomao.hits = 9
            }
            this.body = new Circle(this.pomao.body.x - 575, this.pomao.body.y - 300, 27.5, "red")
            this.body.draw()
            canvas_context.drawImage(healthbase, 0, 0, healthbase.width, healthbase.height, this.body.x - this.body.radius, this.body.y - this.body.radius, this.body.radius * 2, this.body.radius * 2)
            let a = Math.PI
            this.rays = []
            for (let t = 0; t < 9; t++) {
                const ray = new Circle(this.body.x + (Math.sin(a) * 28), this.body.y + (Math.cos(a) * 28), 6, "yellow")
                this.rays.push(ray)
                a += (Math.PI / 4.5)
            }
            if(this.hits > 9){
                this.hits = 9
            }
            for (let t = 0; t < this.pomao.hits; t++) {
                // this.rays[t].draw()

                canvas_context.drawImage(healthdot, 0, 0, healthdot.width, healthdot.height, this.rays[t].x - (this.rays[t].radius * 1.2), this.rays[t].y - (this.rays[t].radius * 1.2), this.rays[t].radius * 2.4, this.rays[t].radius * 2.4)
            }

        }
    }

    class Pomao {
        constructor(args = 0) {
            this.touchout = 0
            this.wingcheck = 0
            this.cutscene = 0
            this.grounded = 0
            this.wingthing = 0
            this.eggmake = 0
            this.rooted = {}
            this.rootedframe = 0
            this.dry = 0
            this.tongueray = []
            this.tonguebox = new Shape(this.tongueray)
            this.pausetimer = 10
            this.paused = 10
            this.fired = 0
            this.blocked = 0
            this.bonked = 0
            this.blush = 0
            this.high = 0
            this.tripping = 0
            this.eggtimer = 10
            this.egglock = 0
            this.body = new Circle(350, 350, 32, "transparent")
            if(cheats.megamao == 1){
                this.body.radius = 64
            }
            this.tongue = new Circle(this.body.x, this.body.y, 6, "blue")
            if(cheats.megamao == 1){
                this.tongue.radius = 12
            }
            
            this.tonguex = 0
            this.tonguey = 0
            this.tonguexmom = 0
            this.tongueymom = 0
            this.runner = 0
            this.jumping = 1
            this.hng = 0
            this.dir = 1
            this.timeloop = 0
            this.timeloops = 0  //?
            this.timeloopx = 0
            this.thrown = []
            this.pounding = 0
            this.eggs = [this.body]
            this.disabled = 0
            this.hits = 9
            this.flap = 0
            this.flapstep = 0
            this.health = new Health(this)
            this.rattled = 0

            this.positron = new Circle(this.body.x, this.body.y, 3, "gray", 1)
            this.electron = new Circle(this.body.x, this.body.y, 3, "gray", -1)
            this.positron2 = new Circle(this.body.x, this.body.y, 3, "gray", 0, 1)
            this.electron2 = new Circle(this.body.x, this.body.y, 3, "gray", 0, -1)
            this.pomarray = [
                {
                    "angle": -3.0900024820325203,
                    "length": 842.6071008397848
                },
                {
                    "angle": -3.0392171780123785,
                    "length": 711.7980972863734
                },
                {
                    "angle": -2.9864134810096097,
                    "length": 636.9785562444595
                },
                {
                    "angle": -2.9358334225802794,
                    "length": 614.3520057488349
                },
                {
                    "angle": -2.8844451529222184,
                    "length": 661.7218921853346
                },
                {
                    "angle": -2.8336751272063228,
                    "length": 993.7168833971955
                },
                {
                    "angle": -2.781301952481093,
                    "length": 1171.4495818282012
                },
                {
                    "angle": -2.731095455469834,
                    "length": 1441.9872287680628
                },
                {
                    "angle": -2.6797528311626158,
                    "length": 1631.6425505639054
                },
                {
                    "angle": -2.6271034825260573,
                    "length": 1841.0023240997107
                },
                {
                    "angle": -2.5769097656370232,
                    "length": 2002.0044637157116
                },
                {
                    "angle": -2.524802808994127,
                    "length": 2171.362869620556
                },
                {
                    "angle": -2.473706724279335,
                    "length": 2343.954666495556
                },
                {
                    "angle": -2.4200094355232338,
                    "length": 2526.117456066946
                },
                {
                    "angle": -2.36909261256157,
                    "length": 2668.253155088518
                },
                {
                    "angle": -2.31631566609945,
                    "length": 2778.2611177922226
                },
                {
                    "angle": -2.2614019791774393,
                    "length": 2936.737915082136
                },
                {
                    "angle": -2.2112901476824587,
                    "length": 3021.4888102246914
                },
                {
                    "angle": -2.160696037505721,
                    "length": 3107.1283526516636
                },
                {
                    "angle": -2.1104069021476524,
                    "length": 3245.3653981210664
                },
                {
                    "angle": -2.0602508494318093,
                    "length": 3209.3904193306807
                },
                {
                    "angle": -2.0064523875657216,
                    "length": 3041.689826641232
                },
                {
                    "angle": -1.955659478691034,
                    "length": 2910.189504919166
                },
                {
                    "angle": -1.9022140109425818,
                    "length": 2796.0286274697282
                },
                {
                    "angle": -1.8470044583786287,
                    "length": 2700.8645311929286
                },
                {
                    "angle": -1.79331531448391,
                    "length": 2627.990608844906
                },
                {
                    "angle": -1.7362238559220897,
                    "length": 2569.683492243348
                },
                {
                    "angle": -1.6823471532460736,
                    "length": 2531.368870256061
                },
                {
                    "angle": -1.618229745463697,
                    "length": 2505.6332707550027
                },
                {
                    "angle": -1.5499713958590675,
                    "length": 2501.084507908905
                },
                {
                    "angle": -1.4966669683011042,
                    "length": 2513.788389649475
                },
                {
                    "angle": -1.444887999344592,
                    "length": 2540.0549191213795
                },
                {
                    "angle": -1.3903586618258141,
                    "length": 2583.1942120195017
                },
                {
                    "angle": -1.340339972981263,
                    "length": 2637.621975956077
                },
                {
                    "angle": -1.28722802932911,
                    "length": 2712.316461799259
                },
                {
                    "angle": -1.2355562128285356,
                    "length": 2803.4395905282
                },
                {
                    "angle": -1.181284679948892,
                    "length": 2921.2431168533512
                },
                {
                    "angle": -1.1300671666688695,
                    "length": 3056.1852464224794
                },
                {
                    "angle": -1.0786317869981805,
                    "length": 3218.70028978592
                },
                {
                    "angle": -1.0271344756720624,
                    "length": 3228.1530473507155
                },
                {
                    "angle": -0.9740760045706093,
                    "length": 3132.988634953639
                },
                {
                    "angle": -0.9217978898763471,
                    "length": 3071.676886415633
                },
                {
                    "angle": -0.8657554822466478,
                    "length": 3009.26870731487
                },
                {
                    "angle": -0.8152188751019344,
                    "length": 2926.933507591617
                },
                {
                    "angle": -0.7624007527783836,
                    "length": 2849.3900081778556
                },
                {
                    "angle": -0.7086215199670778,
                    "length": 2692.846094577413
                },
                {
                    "angle": -0.6549065072027261,
                    "length": 2533.532179980364
                },
                {
                    "angle": -0.603289571976316,
                    "length": 2419.3242835105775
                },
                {
                    "angle": -0.5518998082866706,
                    "length": 2313.2561390686897
                },
                {
                    "angle": -0.5010306587602077,
                    "length": 2180.405643081758
                },
                {
                    "angle": -0.4501810182395141,
                    "length": 2063.9012632955128
                },
                {
                    "angle": -0.393223942660539,
                    "length": 1894.057948321235
                },
                {
                    "angle": -0.33879755972622005,
                    "length": 1756.8387373877922
                },
                {
                    "angle": -0.28869600296870723,
                    "length": 1668.381536392044
                },
                {
                    "angle": -0.2377141567864178,
                    "length": 1573.9203915882972
                },
                {
                    "angle": -0.18445250405077204,
                    "length": 1423.3618544031197
                },
                {
                    "angle": -0.13444414619250972,
                    "length": 1294.5140864540008
                },
                {
                    "angle": -0.0839432369934708,
                    "length": 1187.9510239721421
                },
                {
                    "angle": -0.03093684961144852,
                    "length": 1074.767495660868
                },
                {
                    "angle": 0.022023985571814616,
                    "length": 963.5506732130889
                },
                {
                    "angle": 0.07503083858795291,
                    "length": 890.34369653475
                },
                {
                    "angle": 0.12865429706753992,
                    "length": 810.3864279534318
                },
                {
                    "angle": 0.17973656145765743,
                    "length": 755.1160594393732
                },
                {
                    "angle": 0.23127406347510263,
                    "length": 706.94122585078
                },
                {
                    "angle": 0.282109425590053,
                    "length": 671.5463459445746
                },
                {
                    "angle": 0.3338382610056162,
                    "length": 635.1143539692857
                },
                {
                    "angle": 0.38778931978909664,
                    "length": 601.306914901943
                },
                {
                    "angle": 0.44025044466941005,
                    "length": 583.8736032343586
                },
                {
                    "angle": 0.4941993434605133,
                    "length": 575.8158338285284
                },
                {
                    "angle": 0.5491581447539602,
                    "length": 563.3610157729709
                },
                {
                    "angle": 0.6046067533442996,
                    "length": 554.2780565882567
                },
                {
                    "angle": 0.6562025769033171,
                    "length": 556.7619833970675
                },
                {
                    "angle": 0.7085511821153687,
                    "length": 556.7115173508646
                },
                {
                    "angle": 0.7639297288018813,
                    "length": 566.6059825589182
                },
                {
                    "angle": 0.8170516076819963,
                    "length": 576.0560390353785
                },
                {
                    "angle": 0.8708792558546752,
                    "length": 593.1579815126606
                },
                {
                    "angle": 0.9253850900369438,
                    "length": 618.207773323229
                },
                {
                    "angle": 0.9785656386631345,
                    "length": 635.6227161027491
                },
                {
                    "angle": 1.031645311377938,
                    "length": 675.6658563186647
                },
                {
                    "angle": 1.0873874355152848,
                    "length": 723.2475410915213
                },
                {
                    "angle": 1.1387523975385965,
                    "length": 762.91072909371
                },
                {
                    "angle": 1.1890435271751802,
                    "length": 799.6826050973614
                },
                {
                    "angle": 1.2409448483243457,
                    "length": 821.7677111030207
                },
                {
                    "angle": 1.2933807230491594,
                    "length": 835.0376960850554
                },
                {
                    "angle": 1.3454974980362069,
                    "length": 841.7030881048413
                },
                {
                    "angle": 1.3992788365438618,
                    "length": 917.3733254219987
                },
                {
                    "angle": 1.4506687212318976,
                    "length": 1827.7876862705598
                },
                {
                    "angle": 1.5039984926214207,
                    "length": 2004.2965968454519
                },
                {
                    "angle": 1.5556885136391267,
                    "length": 2028.7688527883292
                },
                {
                    "angle": 1.6063967944478499,
                    "length": 2088.4230398226646
                },
                {
                    "angle": 1.6584500544374525,
                    "length": 2031.9323431791418
                },
                {
                    "angle": 1.7094435084179394,
                    "length": 1791.264011037434
                },
                {
                    "angle": 1.7609272816479649,
                    "length": 1331.2000438310206
                },
                {
                    "angle": 1.8127226104517642,
                    "length": 1161.2795546806447
                },
                {
                    "angle": 1.8627704219273011,
                    "length": 1216.3950152421603
                },
                {
                    "angle": 1.913414757519883,
                    "length": 2333.5566812457546
                },
                {
                    "angle": 1.963660139081041,
                    "length": 2362.4716713573434
                },
                {
                    "angle": 2.014253081958968,
                    "length": 2274.605719452098
                },
                {
                    "angle": 2.065026221426755,
                    "length": 2088.9737368466012
                },
                {
                    "angle": 2.1164139421161234,
                    "length": 1797.9861213304102
                },
                {
                    "angle": 2.1717729019930436,
                    "length": 1514.4161449863022
                },
                {
                    "angle": 2.223224086210891,
                    "length": 1549.813527673672
                },
                {
                    "angle": 2.274319798803,
                    "length": 1573.7614479542972
                },
                {
                    "angle": 2.3254452924597784,
                    "length": 1625.7696896546583
                },
                {
                    "angle": 2.376947145839857,
                    "length": 1696.1245593978674
                },
                {
                    "angle": 2.428165777144579,
                    "length": 1733.7370209885994
                },
                {
                    "angle": 2.481553838496098,
                    "length": 1778.1765819765278
                },
                {
                    "angle": 2.5324049771051538,
                    "length": 1783.7179315710673
                },
                {
                    "angle": 2.5828162552763403,
                    "length": 1807.7397730972734
                },
                {
                    "angle": 2.6376626729809476,
                    "length": 1782.9235605481663
                },
                {
                    "angle": 2.688396767607974,
                    "length": 1726.678378630022
                },
                {
                    "angle": 2.743257458565758,
                    "length": 1657.4363720776164
                },
                {
                    "angle": 2.7940877541480247,
                    "length": 1592.794274246844
                },
                {
                    "angle": 2.8449544469718453,
                    "length": 1539.617986006895
                },
                {
                    "angle": 2.8951938875276824,
                    "length": 1476.3267997934017
                },
                {
                    "angle": 2.94757483429578,
                    "length": 1366.8568774082814
                },
                {
                    "angle": 2.9985409918048065,
                    "length": 1246.621762840834
                },
                {
                    "angle": 3.0494937955340284,
                    "length": 1123.6036556435865
                },
                {
                    "angle": 3.100608769042309,
                    "length": 1017.625220196438
                }
            ]
            this.pomarrayleft = [
                {
                    "angle": -3.127411769756162,
                    "length": 1078.2106881571235
                },
                {
                    "angle": -3.0771016485706926,
                    "length": 1137.362238745729
                },
                {
                    "angle": -3.026025692309955,
                    "length": 1236.4692576027592
                },
                {
                    "angle": -2.9754242903904986,
                    "length": 1390.5597063995083
                },
                {
                    "angle": -2.923605611542274,
                    "length": 1512.8581265616813
                },
                {
                    "angle": -2.8732902188991405,
                    "length": 1637.7391706992057
                },
                {
                    "angle": -2.8226734806080565,
                    "length": 1761.2957837963477
                },
                {
                    "angle": -2.7708868709479977,
                    "length": 1863.2112421990023
                },
                {
                    "angle": -2.7190537864313664,
                    "length": 2004.2293023061939
                },
                {
                    "angle": -2.6688362534694883,
                    "length": 2154.1270884157275
                },
                {
                    "angle": -2.6182969207826745,
                    "length": 2287.240950775158
                },
                {
                    "angle": -2.5675385296700437,
                    "length": 2440.4244592238683
                },
                {
                    "angle": -2.516987080578789,
                    "length": 2577.3083098317147
                },
                {
                    "angle": -2.466835229165751,
                    "length": 2671.640319931612
                },
                {
                    "angle": -2.415678887684283,
                    "length": 2778.954873027804
                },
                {
                    "angle": -2.3654655703689027,
                    "length": 2914.4357440520544
                },
                {
                    "angle": -2.312812617132903,
                    "length": 2940.448842909478
                },
                {
                    "angle": -2.262306403983799,
                    "length": 3011.5182513953187
                },
                {
                    "angle": -2.21168074641381,
                    "length": 3077.1848588085268
                },
                {
                    "angle": -2.1605035485316977,
                    "length": 3156.406195073214
                },
                {
                    "angle": -2.1101385928879868,
                    "length": 3230.438608694123
                },
                {
                    "angle": -2.0596951740595646,
                    "length": 3156.3784642696846
                },
                {
                    "angle": -2.008998479258629,
                    "length": 3014.160182523774
                },
                {
                    "angle": -1.9581116359601003,
                    "length": 2910.4413125038263
                },
                {
                    "angle": -1.907822248088823,
                    "length": 2814.4010550380335
                },
                {
                    "angle": -1.8572280340723162,
                    "length": 2724.0925406814204
                },
                {
                    "angle": -1.8046854953486573,
                    "length": 2661.0140480520204
                },
                {
                    "angle": -1.7522570600900247,
                    "length": 2618.7597769380664
                },
                {
                    "angle": -1.702185575801875,
                    "length": 2595.269969892688
                },
                {
                    "angle": -1.6502688764323794,
                    "length": 2606.5227611828595
                },
                {
                    "angle": -1.5979333040637673,
                    "length": 2597.257766733237
                },
                {
                    "angle": -1.547077178021175,
                    "length": 2596.806259322213
                },
                {
                    "angle": -1.4954779319774714,
                    "length": 2592.3833317042445
                },
                {
                    "angle": -1.4428715653422803,
                    "length": 2576.587096083269
                },
                {
                    "angle": -1.3922770487755614,
                    "length": 2592.056842212798
                },
                {
                    "angle": -1.3418484838705775,
                    "length": 2682.9204552555457
                },
                {
                    "angle": -1.2900902256443207,
                    "length": 2787.5166116142645
                },
                {
                    "angle": -1.2391826596302224,
                    "length": 2878.710231921694
                },
                {
                    "angle": -1.1882561308123871,
                    "length": 3008.4931312371045
                },
                {
                    "angle": -1.137647077924563,
                    "length": 3143.019115247822
                },
                {
                    "angle": -1.0871186861169617,
                    "length": 3303.775696873723
                },
                {
                    "angle": -1.0354736129359698,
                    "length": 3341.7923977852333
                },
                {
                    "angle": -0.98500579958961,
                    "length": 3194.8506556631182
                },
                {
                    "angle": -0.9344768144997845,
                    "length": 3010.9234768354945
                },
                {
                    "angle": -0.8835306545737108,
                    "length": 2942.187966518468
                },
                {
                    "angle": -0.8326929557933133,
                    "length": 2869.0562328100787
                },
                {
                    "angle": -0.7806171545948313,
                    "length": 2715.5039824939013
                },
                {
                    "angle": -0.7290408995220169,
                    "length": 2523.4058318818134
                },
                {
                    "angle": -0.678893382358401,
                    "length": 2373.5357673991384
                },
                {
                    "angle": -0.6275005156285277,
                    "length": 2207.333249735879
                },
                {
                    "angle": -0.5761336665583278,
                    "length": 2086.4210784077877
                },
                {
                    "angle": -0.5259071524748967,
                    "length": 1961.487106382905
                },
                {
                    "angle": -0.4756503922103153,
                    "length": 1816.173159093887
                },
                {
                    "angle": -0.4237145655085014,
                    "length": 1520.767570226235
                },
                {
                    "angle": -0.37367143586804413,
                    "length": 1259.4550411224482
                },
                {
                    "angle": -0.3228855600430013,
                    "length": 1080.5778367042803
                },
                {
                    "angle": -0.27274562968208443,
                    "length": 790.2736423838796
                },
                {
                    "angle": -0.2223266367011554,
                    "length": 626.0660562157864
                },
                {
                    "angle": -0.16678195444069532,
                    "length": 602.081382322358
                },
                {
                    "angle": -0.11463031287666091,
                    "length": 629.0569596934365
                },
                {
                    "angle": -0.06393412603678986,
                    "length": 742.2322680235375
                },
                {
                    "angle": -0.012316321942961833,
                    "length": 866.3297502994683
                },
                {
                    "angle": 0.037998607719853694,
                    "length": 989.9905408323539
                },
                {
                    "angle": 0.08961308750587366,
                    "length": 1119.049391626162
                },
                {
                    "angle": 0.14003339012531266,
                    "length": 1261.3028378702002
                },
                {
                    "angle": 0.19230789361857067,
                    "length": 1354.3175487744884
                },
                {
                    "angle": 0.2426860313199931,
                    "length": 1477.1166109669866
                },
                {
                    "angle": 0.29413406725269176,
                    "length": 1561.757445623938
                },
                {
                    "angle": 0.3461167379944047,
                    "length": 1635.2928684855142
                },
                {
                    "angle": 0.39686473189681215,
                    "length": 1710.2917607021518
                },
                {
                    "angle": 0.4489510974719858,
                    "length": 1762.7953168845852
                },
                {
                    "angle": 0.4997050871048781,
                    "length": 1816.0090387452074
                },
                {
                    "angle": 0.5502655464261379,
                    "length": 1847.9508946466522
                },
                {
                    "angle": 0.6018256113592149,
                    "length": 1846.175576635651
                },
                {
                    "angle": 0.6530985904099822,
                    "length": 1838.9436341953697
                },
                {
                    "angle": 0.7052430300619456,
                    "length": 1787.5393160725507
                },
                {
                    "angle": 0.755838722802763,
                    "length": 1731.150548986232
                },
                {
                    "angle": 0.8067134610556763,
                    "length": 1674.9303730190295
                },
                {
                    "angle": 0.8585169800022312,
                    "length": 1614.154766007705
                },
                {
                    "angle": 0.9098218547361074,
                    "length": 1592.1713387132186
                },
                {
                    "angle": 0.9610343863595476,
                    "length": 1656.606947503169
                },
                {
                    "angle": 1.0112517273086032,
                    "length": 1775.2894670951791
                },
                {
                    "angle": 1.0618212063041776,
                    "length": 1989.0179855609458
                },
                {
                    "angle": 1.1156849594624938,
                    "length": 2177.1928731322405
                },
                {
                    "angle": 1.1663399723699939,
                    "length": 2287.4840961790323
                },
                {
                    "angle": 1.2171561963039412,
                    "length": 2336.2514293289423
                },
                {
                    "angle": 1.269015616272444,
                    "length": 2283.0395341634867
                },
                {
                    "angle": 1.3191350047433268,
                    "length": 1984.21725959779
                },
                {
                    "angle": 1.3697494104368375,
                    "length": 1602.3777513981331
                },
                {
                    "angle": 1.4203838141409748,
                    "length": 1625.0718342650362
                },
                {
                    "angle": 1.4705347134049662,
                    "length": 1759.384577236211
                },
                {
                    "angle": 1.5214125243908168,
                    "length": 1870.866188548811
                },
                {
                    "angle": 1.5719649782657066,
                    "length": 1888.7193907047185
                },
                {
                    "angle": 1.6220326109467527,
                    "length": 1879.5488488102128
                },
                {
                    "angle": 1.6729343817691562,
                    "length": 1787.640785990996
                },
                {
                    "angle": 1.7239336401201633,
                    "length": 1673.7574330568896
                },
                {
                    "angle": 1.7748055420949795,
                    "length": 1262.9886059475248
                },
                {
                    "angle": 1.825907036654489,
                    "length": 1022.7421966195834
                },
                {
                    "angle": 1.8775152777933413,
                    "length": 876.2208143568714
                },
                {
                    "angle": 1.9307537790615477,
                    "length": 760.9355929017183
                },
                {
                    "angle": 1.9810647146032265,
                    "length": 705.4544661141117
                },
                {
                    "angle": 2.031527997422867,
                    "length": 675.8722517276765
                },
                {
                    "angle": 2.0822937216484987,
                    "length": 660.7327858901699
                },
                {
                    "angle": 2.137146431081851,
                    "length": 654.3281609202386
                },
                {
                    "angle": 2.189216866334204,
                    "length": 641.1418626928935
                },
                {
                    "angle": 2.23928039844635,
                    "length": 621.0045892382623
                },
                {
                    "angle": 2.298285787312431,
                    "length": 589.6307377934572
                },
                {
                    "angle": 2.3487216987116533,
                    "length": 577.2089324999251
                },
                {
                    "angle": 2.4024167760178923,
                    "length": 569.482211899769
                },
                {
                    "angle": 2.455083479386079,
                    "length": 564.1930066061323
                },
                {
                    "angle": 2.5051476974914655,
                    "length": 565.628050510888
                },
                {
                    "angle": 2.5559545982763705,
                    "length": 572.1457435513148
                },
                {
                    "angle": 2.6060134755709217,
                    "length": 585.3972298885346
                },
                {
                    "angle": 2.6574292201604655,
                    "length": 591.4749930525431
                },
                {
                    "angle": 2.70937294873381,
                    "length": 596.2067954922677
                },
                {
                    "angle": 2.761785973825037,
                    "length": 609.0131305575487
                },
                {
                    "angle": 2.81425298063536,
                    "length": 639.1954037929536
                },
                {
                    "angle": 2.864409950846538,
                    "length": 678.0836799335666
                },
                {
                    "angle": 2.915929902352013,
                    "length": 699.534228346427
                },
                {
                    "angle": 2.968969251151705,
                    "length": 745.4786960005877
                },
                {
                    "angle": 3.0204698923751563,
                    "length": 816.3948018170195
                },
                {
                    "angle": 3.0711543030881443,
                    "length": 886.9942358779954
                },
                {
                    "angle": 3.121601802791772,
                    "length": 997.231482725183
                }
            ]


            for (let t = 0; t < 10; t++) {
                let pomarray2 = []
                for (let t = 0; t < this.pomarray.length - 1; t++) {
                    let obj = {}
                    obj.angle = (this.pomarray[t].angle + this.pomarray[t + 1].angle) * .5
                    obj.length = (this.pomarray[t].length + this.pomarray[t + 1].length) * .5
                    pomarray2.push(this.pomarray[t])
                    pomarray2.push(obj)
                }
                this.pomarray = [...pomarray2]
            }

            for (let t = 0; t < 10; t++) {
                let pomarray2 = []
                for (let t = 0; t < this.pomarrayleft.length - 1; t++) {
                    let obj = {}
                    obj.angle = (this.pomarrayleft[t].angle + this.pomarrayleft[t + 1].angle) * .5
                    obj.length = (this.pomarrayleft[t].length + this.pomarrayleft[t + 1].length) * .5
                    pomarray2.push(this.pomarrayleft[t])
                    pomarray2.push(obj)
                }
                this.pomarrayleft = [...pomarray2]
            }



            this.angleincrement = (Math.PI * 2) / this.pomarray.length
            this.angleincrementleft = (Math.PI * 2) / this.pomarrayleft.length


            let zero = Math.PI
            this.angleincrement = (Math.PI * 2) / this.pomarray.length


            for (let t = 0; t < this.pomarray.length; t++) {
                this.pomarray[t].angle = zero
                this.pomarray[t].length = Math.sqrt(this.pomarray[t].length)
                zero += this.angleincrement
            }

            zero = Math.PI
            this.angleincrementleft = (Math.PI * 2) / this.pomarrayleft.length


            for (let t = 0; t < this.pomarrayleft.length; t++) {
                this.pomarrayleft[t].angle = zero
                this.pomarrayleft[t].length = Math.sqrt(this.pomarrayleft[t].length)
                zero += this.angleincrementleft
            }

            this.angleincrement = 1 / this.angleincrement
            this.angleincrementleft = 1 / this.angleincrementleft


            if(args == 0){

                
            }else{
                // console.log(args)
                this.id = args.id
                this.body.x = args.x
                this.body.y = args.y
                this.tongue.x = args.xt
                this.tongue.y = args.yt
                this.tonguex = args.xto
                this.tonguey = args.yto
                this.dir = args.dir
                this.xdir = args.xdir
                this.ydir = args.ydir
            }

        }
        checkInsidePomao(point) {
            let link = new LineOP(this.body, point) // line between objects
            let angle = link.angle() + Math.PI // angle adjusted
            let dis = link.hypotenuse()  // get distance (could be a square check, rather than a function distance)
            if (this.dir == 1) {
                let t = Math.floor((angle) * this.angleincrement) // calculate the index of the angle 
                t %= this.pomarray.length - 1 // get the index without a loop
                if (dis < ((this.pomarray[t].length + this.pomarray[t + 1].length) * .5) * ((this.body.radius) * .02)) { // normalized to character size
                    return true // collision
                }
            } else { // same as above but for the other direction (this.dir = -1)
                let t = Math.floor((angle) * this.angleincrementleft)
                t %= this.pomarrayleft.length - 1
                if (dis < ((this.pomarrayleft[t].length + this.pomarrayleft[t + 1].length) * .5) * ((this.body.radius) * .02)) {
                    return true
                }
            }
            return false
        }
        checkRepelPomao(point) {
            let link = new LineOP(this.body, point) // line between objects
            let angle = link.angle() + Math.PI // angle adjusted
            let dis = link.hypotenuse() - point.radius // get distance (could be a square check, rather than a function distance)
            if (this.dir == 1) {
                let t = Math.floor((angle) * this.angleincrement) // calculate the index of the angle 
                t %= this.pomarray.length - 1 // get the index without a loop
                if (dis < ((this.pomarray[t].length + this.pomarray[t + 1].length) * .5) * ((this.body.radius) * .02)) { // normalized to character size
                    return  ((this.pomarrayleft[t].length + this.pomarrayleft[t + 1].length) * .5) * ((this.body.radius) * .02) // collision
                }
            } else { // same as above but for the other direction (this.dir = -1)
                let t = Math.floor((angle) * this.angleincrementleft)
                t %= this.pomarrayleft.length - 1
                if (dis < ((this.pomarrayleft[t].length + this.pomarrayleft[t + 1].length) * .5) * ((this.body.radius) * .02)) {
                    return  ((this.pomarrayleft[t].length + this.pomarrayleft[t + 1].length) * .5) * ((this.body.radius) * .02)
                }
            }
            return false
        }
        tonguecast() {

            this.tongueray = []
            if (!this.body.doesPerimeterTouch(this.tongue)) {
                for (let t = 0; t < 30; t++) {
                    const ray = new Circle(this.body.x + (this.tonguex - (this.tonguex * .033333 * t)), (-(Math.sin(this.timeloop) * 1.5)) + this.body.y + (this.tonguey - (this.tonguey * .033333 * t)), 1.5, "red")
                    if (keysPressed['q']) {
                        ray.draw()
                    }
                    this.tongueray.push(ray)
                }

            }

            this.tonguebox = new Shape(this.tongueray)
        }
        tongueFix() {

        }
        gravity() {

            this.flapstep++
            if (this.flapstep % 3 == 0) {

                this.flap++
                this.flap %= 3
            }

            if (this.tripping > 0) {

                for (let t = 0; t < 3; t++) {

                    this.positron.xmom -= (this.positron.x - this.electron.x) / 1000
                    this.electron.xmom += (this.positron.x - this.electron.x) / 1000
                    this.positron.ymom -= (this.positron.y - this.electron.y) / 1000
                    this.electron.ymom += (this.positron.y - this.electron.y) / 1000

                    this.positron.xmom -= (this.positron.x - this.body.x) / 1000
                    this.electron.xmom -= (this.electron.x - this.body.x) / 1000
                    this.positron.ymom -= (this.positron.y - this.body.y) / 1000
                    this.electron.ymom -= (this.electron.y - this.body.y) / 1000
                    this.electron.color = getRandomLightColortp()
                    this.positron.color = getRandomLightColortp()
                    this.electron.move()
                    this.electron.draw()
                    this.positron.move()
                    this.positron.draw()
                }

                for (let t = 0; t < 3; t++) {

                    this.positron2.xmom -= (this.positron2.x - this.electron2.x) / 1000
                    this.electron2.xmom += (this.positron2.x - this.electron2.x) / 1000
                    this.positron2.ymom -= (this.positron2.y - this.electron2.y) / 1000
                    this.electron2.ymom += (this.positron2.y - this.electron2.y) / 1000

                    this.positron2.xmom -= (this.positron2.x - this.body.x) / 1000
                    this.electron2.xmom -= (this.electron2.x - this.body.x) / 1000
                    this.positron2.ymom -= (this.positron2.y - this.body.y) / 1000
                    this.electron2.ymom -= (this.electron2.y - this.body.y) / 1000

                    this.electron2.color = getRandomLightColortp()
                    this.positron2.color = getRandomLightColortp()
                    this.electron2.move()
                    this.electron2.draw()
                    this.positron2.move()
                    this.positron2.draw()
                }


            }
            // ////////console.log(this.electron, this.positron)


            this.wet = 0

            if(!keysPressed['s']){
            for(let t = 0;t<floors.length;t++){
                if(floors[t].doesPerimeterTouch(this.tongue)){
                    this.touchout = 1
                }
                for(let k = 0;k<this.tonguebox.shapes.length;k++){
                    if(floors[t].doesPerimeterTouch(this.tonguebox.shapes[k])){
                        this.touchout = 1
                    }
                }
                if(this.body.x+25 > floors[t].x){
                    if(this.body.x-25 < floors[t].x + floors[t].width){
                        if(this.body.y+33 >= floors[t].y){
                            if(this.body.y+33 <= floors[t].y+floors[t].height){
                                if(this == pomaos[0]){
                                canvas_context.translate(0, (this.body.y -( floors[t].y-32)))
                                this.body.y = floors[t].y-32
                                 this.wet = 1
                                }
                            }
                        }
                    }
                }
            }

        }

            if(this.wet == 1){
                // this.body.y = 680
                if(!keysPressed['s']){

                    this.body.ymom = 0
                    this.body.symom = 0
                    this.body.sxmom = 0
                    this.grounded = 1
                    this.wet = 0
                }
            }

            if (this.grounded == 1) {
                if (this.body.ymom > 0) {
                    if (!keysPressed['s'] || (gamepadAPI.axesStatus[1] > .5)) {
                        if (this.body.ymom > 0) {
                            this.body.ymomstorage = this.body.ymom + this.body.symom
                        }
                        this.body.ymom = 0
                    } else {
                        // this.body.ymom += 11.1  //literally what is this
                    }
                }
                if (this.jumping == 0) {
                    this.timeloopx = 0
                }
                if (this.pounding > 0) {
                    this.pounding--
                }
                this.jumping = 0
                this.hng = 0

            } else if (this.grounded == 2) {
                this.runner = 0
                if (this.body.ymom > 0) {
                    if (!keysPressed['s'] || (gamepadAPI.axesStatus[1] > .5)) {
                        if (this.body.ymom > 0) {
                            this.body.ymomstorage = this.body.ymom + this.body.symom
                        }
                        this.body.ymom = 0
                    } else {
                        this.body.ymom += 11.1
                    }
                } // this will never trigger
                this.jumping = 2
                // this.body.ymom += .1
                if (this.rootedframe <= 0) {
                    this.rooted = {}
                }
                this.rootedframe--
                this.grounded = 0
            } else {
                // if(this.jumping == 0){
                this.jumping = 1
                // }
                this.body.ymom += .1
                if (this.rootedframe <= 0) {
                    this.rooted = {}
                }
                this.rootedframe--

            }
            this.grounded = 0

            if (this.touchout == 1 ) {
                this.touchout = 0
                    if (this.tongueymom < 0) {
                        if (Math.abs(this.tonguey) > 1) {
                            this.body.symom += this.tongueymom * 1.1
                        }
                        if (Math.abs(this.tonguex) > 15) {
                            if (this.dir == -1) {
                                this.body.sxmom -= Math.abs(this.tonguexmom * 3)
                            } else {
                                this.body.sxmom += Math.abs(this.tonguexmom * 3)
                            }
                        }
                    } else {
                        if (Math.abs(this.tonguey) > 1) {
                            this.body.symom -= this.tongueymom * 1.1
                        }
                        if (Math.abs(this.tonguex) > 15) {
                            if (this.dir == -1) {
                                this.body.sxmom -= Math.abs(this.tonguexmom * 3)
                            } else {
                                this.body.sxmom += Math.abs(this.tonguexmom * 3)
                            }
                        }
                    }
                    if (this.body.ymom > 0) {
                        this.body.ymomstorage = this.body.ymom + this.body.symom
                    }
                    this.body.ymom = 0
                    this.body.xmom *= .975
                    this.grounded = 2  


                    // while(this.tongue.y > 680){
                    //     // this.body.smove()
                    //     // this.tongue.y+=this.body.symom
                    //     this.tongue.y-=.001
                    //     this.body.y-=.001
                    // }
            }

            // }
            if (this.wingcheck == 1) {
                if (this.tongueymom < 0) {
                    if (Math.abs(this.tonguey) > 1) {
                        this.body.symom += this.tongueymom * 1.1
                    }
                    if (Math.abs(this.tonguex) > 15) {
                        if (this.dir == -1) {
                            this.body.sxmom -= Math.abs(this.tonguexmom * 3)
                        } else {
                            this.body.sxmom += Math.abs(this.tonguexmom * 3)
                        }
                    }
                    this.tongueymom *= .49
                    this.tonguexmom *= .49
                } else {
                    if (Math.abs(this.tonguey) > 1) {
                        this.body.symom -= this.tongueymom * 1.1
                    }
                    if (Math.abs(this.tonguex) > 15) {
                        if (this.dir == -1) {
                            this.body.sxmom -= Math.abs(this.tonguexmom * 3)
                        } else {
                            this.body.sxmom += Math.abs(this.tonguexmom * 3)
                        }
                    }
                    this.tongueymom *= .49
                    this.tonguexmom *= .49

                }
            }
            this.footspot = new Circle(this.body.x, this.body.y + (this.body.radius - .01), 3, "red")
    

            for (let t = 1; t < this.eggs.length; t++) {
                if (this.eggs[t].marked == 0) {
                    this.eggs[t].steery()
                }
            }

            if (keysPressed['s'] || (gamepadAPI.axesStatus[1] > .5)) {
            } else {
                this.tongueFix()
            }
            this.wingcheck = 0

        }
        draw() {
            if(cheats.ruthless == 1){
                this.eggs.push(this.body)
            }
            this.eggmake--
            if (this.eggmake > 0) {
                if (this.eggmake % 10 == 0) {
                    if (this.eggs.length < 16) {
                        const seepx = new Seed(this.eggs[this.eggs.length - 1])
                        this.eggs.push(seepx)
                    }
                }
            }
            this.high--
            this.tripping--
            if (this.body.ymom + this.body.symom < 0) {
                this.pounding = 0
            }
            if (this.rattled > 0) {
                this.rattled--
            } else if (this.rattled < 0) {
                this.rattled++
            }
            if (Math.abs(this.rattled < 3)) {
                this.rattled = 0
            }
            this.blush--
            this.timeloop += .05
            this.timeloops += .01
            this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
            this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")
            this.bodyloose = new Circle(this.body.x, this.body.y, 25, "yellow")

            this.blocked = 0
            this.bonked = 0
            if (this.rattled == 50) {
                this.rattled += 40.5
            }
            if (this.rattled == 50.5) {
                this.rattled += 35.51
            }
            if (this.cutscene <= 0) {
            if(pomaos.indexOf(this) == 0){
                this.control()
            }
            }
            
            if(cheats.warpspeed == 1){
                for(let t = 0;t<3;t++){
                this.control()
                }
            }
            if (this.blocked == 0) {

            if(pomaos.indexOf(this) == 0){
                this.body.move()
                this.body.smove()
            }
            } else {
                this.body.ymove()
            }

            if(pomaos.indexOf(this) == 0){
            this.gravity()
            }
            this.tonguex += this.tonguexmom
            this.tonguey += this.tongueymom
            this.tonguex -= this.body.sxmom * .05
            this.tonguey -= this.body.symom * .05


            if (this.tongue.x > this.body.x) {
                this.tonguexmom -= .5
            }
            if (this.tongue.x < this.body.x) {
                this.tonguexmom += .5
            }
            if(cheats.megamao == 1){
            if (this.tongue.x > this.body.x) {
                this.tonguexmom -= .5
            }
            if (this.tongue.x < this.body.x) {
                this.tonguexmom += .5
            }

            if (this.tongue.y > this.body.y && ((!keysPressed['l'] && !keysPressed['j']) || this.tongue.y > this.body.y + 5)) {
                this.tongueymom -= .5
            }
            if (this.tongue.y < this.body.y && ((!keysPressed['l'] && !keysPressed['j']) || this.tongue.y < this.body.y - 5)) {
                this.tongueymom += .5
            }
            }
            if (this.tongue.y > this.body.y && ((!keysPressed['l'] && !keysPressed['j']) || this.tongue.y > this.body.y + 5)) {
                this.tongueymom -= .5
            }
            if (this.tongue.y < this.body.y && ((!keysPressed['l'] && !keysPressed['j']) || this.tongue.y < this.body.y - 5)) {
                this.tongueymom += .5
            }
            this.fired--
            if (this.bodytight.isPointInside(this.tongue)) {
                if (this.fired <= 0) {
                    this.tonguexmom *= 0
                    this.tongueymom *= 0
                    this.tonguex *= .9
                    this.tonguey *= .9
                }
            } else {
                this.tonguexmom *= .91
                this.tongueymom *= .91
            }
            this.tongue = new Circle(this.body.x + this.tonguex, this.body.y + this.tonguey, 5, "blue")
            this.tongued1 = new Circle(this.body.x + this.tonguex + (this.rattled / 3), this.body.y + this.tonguey, 5, "#0000FF77")
            this.tongued2 = new Circle(this.body.x + this.tonguex - (this.rattled / 3), this.body.y + this.tonguey, 5, "#0000FF77")
            this.tonguecast()

            if (this.tongue.y > this.body.y - 14) {
                this.diry = -1
            } else {
                this.diry = 0
            }



            if (this.tongue.x > this.body.x + 14) {
                this.dir = 1
            }
            if (this.tongue.x < this.body.x - 14) {
                this.dir = -1
            }

            this.height = 64 + (Math.sin(this.timeloop) * (3 + this.pounding))
            this.width = 64 + (Math.sin(this.timeloopx) * 1)
            if (this.jumping == 1) {
                if (this.body.ymom < 0) {
                    this.height = 68 + this.pounding + Math.round((Math.min(Math.abs(this.body.ymom), 15) + Math.abs(Math.min(this.hng, .217)) + Math.abs(this.body.symom)) * 1.9)
                } else {
                    this.height = 68 + this.pounding
                }
            }
            if (this.jumping == 1) {
                if (this.body.ymom < 0) {
                    this.width = 60 - (this.pounding + ((Math.min(Math.abs(this.body.ymom), 15) + Math.abs(Math.min(this.hng, .217)) + Math.abs(this.body.symom)) * 1.5))
                } else {
                    this.width = 60 - this.pounding
                }
                // this.width  = 60-this.pounding
            }


            if(cheats.megamao == 1){
                this.height = 128 + (Math.sin(this.timeloop) * (6 + this.pounding))
                this.width = 128 + (Math.sin(this.timeloopx) * 1)

            if (this.jumping == 1) {
                if (this.body.ymom < 0) {
                    this.height = 136 + this.pounding + Math.round((Math.min(Math.abs(this.body.ymom), 15)  + Math.abs(Math.min(this.hng, .217)) + Math.abs(this.body.symom)) * 1.9)
                } else {
                    this.height = 136 + this.pounding
                }
            }
            if (this.jumping == 1) {
                if (this.body.ymom < 0) {
                    this.width = 120 - (this.pounding + ((Math.min(Math.abs(this.body.ymom), 15) + Math.abs(Math.min(this.hng, .217)) + Math.abs(this.body.symom)) * 1.5))
                } else {
                    this.width = 120 - this.pounding
                }
            }
            }

            if (Math.abs(this.rattled < 3)) {
                this.rattled = 0
            }

            //canvas_context.clearRect(-1000000,680,canvas.width*1000000, canvas.height)
            for (let t = 0; t < this.eggs.length; t++) {
                this.eggs[t].draw()
            }

            for (let t = 0; t < this.thrown.length; t++) {
                this.thrown[t].draw()
            }



            this.tongue.draw()

            this.link = new Line(this.body.x, 3 + this.body.y - (Math.sin(this.timeloop) * 1), this.tongue.x, this.tongue.y, "blue", 3) // radius 3 // this.tongue.radius*1.1

            this.link.draw()

            // console.log(this.link)


            if (!keysPressed['q']) {

                if (this.diry == -1) {
                    hot--
                    for (let t = 0; t < this.thrown.length; t++) {
                        if (this.body.doesPerimeterTouch(this.thrown[t]) && this.thrown[t].timer < 5) {
                            hot = 20
                            this.thrown[t].timer = 6
                        }
                    }
                    if (this.tonguex > 14 && this.tonguey > 25) {
                        if (this.blush <= 1) {
                            canvas_context.drawImage(pomaodownpaint, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                        } else {
                            canvas_context.drawImage(pomaodownpaintb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                        }
                    } else if (this.tonguex < -14 && this.tonguey > 25) {
                        if (this.blush <= 1) {
                            canvas_context.drawImage(pomaodownpaintl, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                        } else {
                            canvas_context.drawImage(pomaodownpaintlb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                        }
                    } else if (hot <= 0) {

                        if (this.blush <= 1) {

                            if (this.disabled == 0) {
                                if (this.dir == 1) {
                                    if (this.hng != 0 && this.pounding < 10 && (keysPressed['w'] || gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A'))) {
                                        canvas_context.drawImage(pomaof, (pomaof.width / 3 * this.flap), 0, pomaof.width / 3, pomaof.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    } else {
                                        canvas_context.drawImage(pomaoimg, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    }
                                } else {
                                    if (this.hng != 0 && this.pounding < 10 && (keysPressed['w'] || gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A'))) {
                                        canvas_context.drawImage(pomaofl, (pomaofl.width / 3 * this.flap), 0, pomaofl.width / 3, pomaofl.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    } else {
                                        canvas_context.drawImage(pomaoimgl, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    }
                                }
                            } else {
                                if (this.dir == 1) {
                                    if (this.hng != 0 && this.pounding < 10 && (keysPressed['w'] || gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A'))) {
                                        canvas_context.drawImage(pomaofh, (pomaofh.width / 3 * this.flap), 0, pomaofh.width / 3, pomaofh.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    } else {
                                        canvas_context.drawImage(pomaoimgh, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    }
                                } else {
                                    if (this.hng != 0 && this.pounding < 10 && (keysPressed['w'] || gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A'))) {
                                        canvas_context.drawImage(pomaoflh, (pomaoflh.width / 3 * this.flap), 0, pomaoflh.width / 3, pomaoflh.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    } else {
                                        canvas_context.drawImage(pomaoimglh, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    }
                                }
                            }
                        } else {
                            if (this.disabled == 0) {
                                if (this.dir == 1) {
                                    if (this.hng != 0 && this.pounding < 10 && (keysPressed['w'] || gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A'))) {
                                        canvas_context.drawImage(pomaofb, (pomaofb.width / 3 * this.flap), 0, pomaofb.width / 3, pomaofb.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    } else {
                                        canvas_context.drawImage(pomaoimgb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    }
                                } else {
                                    if (this.hng != 0 && this.pounding < 10 && (keysPressed['w'] || gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A'))) {
                                        canvas_context.drawImage(pomaoflb, (pomaoflb.width / 3 * this.flap), 0, pomaoflb.width / 3, pomaoflb.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    } else {
                                        canvas_context.drawImage(pomaoimgbl, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    }
                                }
                            } else {

                                if (this.dir == 1) {
                                    if (this.hng != 0 && this.pounding < 10 && (keysPressed['w'] || gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A'))) {
                                        canvas_context.drawImage(pomaofbh, (pomaofbh.width / 3 * this.flap), 0, pomaofbh.width / 3, pomaofbh.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    } else {
                                        canvas_context.drawImage(pomaoimglhb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    }
                                } else {
                                    if (this.hng != 0 && this.pounding < 10 && (keysPressed['w'] || gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A'))) {
                                        canvas_context.drawImage(pomaoflbh, (pomaoflbh.width / 3 * this.flap), 0, pomaoflbh.width / 3, pomaoflbh.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    } else {
                                        canvas_context.drawImage(pomaoimghb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                    }
                                }
                            }
                        }
                    } else {

                        if (this.blush <= 1) {
                            if (this.dir == 1) {

                                if (this.hng !== 0) {
                                    canvas_context.drawImage(pomaospitf, (pomaospitf.width / 3 * this.flap), 0, pomaospitf.width / 3, pomaospitf.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)

                                } else {

                                    canvas_context.drawImage(pomaospit, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                }
                            } else {

                                if (this.hng !== 0) {
                                    canvas_context.drawImage(pomaospitfl, (pomaospitfl.width / 3 * this.flap), 0, pomaospitfl.width / 3, pomaospitfl.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                } else {
                                    canvas_context.drawImage(pomaospitl, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)

                                }
                            }
                        } else {
                            if (this.dir == 1) {

                                if (this.hng !== 0) {
                                    canvas_context.drawImage(pomaospitfb, (pomaospitfb.width / 3 * this.flap), 0, pomaospitfb.width / 3, pomaospitfb.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)

                                } else {

                                    canvas_context.drawImage(pomaospitb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                }
                            } else {

                                if (this.hng !== 0) {
                                    canvas_context.drawImage(pomaospitflb, (pomaospitflb.width / 3 * this.flap), 0, pomaospitflb.width / 3, pomaospitflb.height, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                                } else {
                                    canvas_context.drawImage(pomaospitlb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)

                                }
                            }

                        }
                    }
                } else {
                    if (this.blush <= 1) {

                        if (this.dir == 1) {
                            canvas_context.drawImage(pomaoimgup, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                        } else {
                            canvas_context.drawImage(pomaoimglup, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                        }

                    } else {

                        if (this.dir == 1) {
                            canvas_context.drawImage(pomaoimgupb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                        } else {
                            canvas_context.drawImage(pomaoimglupb, this.body.x - (this.width / 2), this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5), this.width, this.height)
                        }
                    }
                }

                // canvas_context.drawImage(dealwithit, (this.body.x - (this.width / 2))+10, (this.body.y - (this.height / 2) - (Math.sin(this.timeloop) * 1.5))-20, this.width, this.height)


                this.body.color = "transparent"

            } else {
                // this.body = new Circle(this.body.x, this.body.y, this.body.radius, "black")

                // this.body.color = "black"
                // this.body.draw()
                // this.body = new Circle(this.body.x, this.body.y, this.body.radius, "black")
            }


//             for (let t = 0; t < worms.length; t++) {
//                 if (worms[t].boss == 1) {
//                     // if (this.y < -9170) {
//                     //     // 
//                     if(worms[t].gcdodge == 0){
// worms[t].draw()
// } // maybe remove this?
//                     // }
//                 } else {
//                     if (worms[t].body.x > this.body.x - (canvas.width / .66) && worms[t].body.x < this.body.x + (canvas.width / .66)) {
//                         if (worms[t].body.y > this.body.y - (canvas.height / .7) && worms[t].body.y < this.body.y + (canvas.height / .016)) {
//                             if (worms[t].layer == 1) {
//                                 if(worms[t].gcdodge == 0){
// worms[t].draw()
// }
//                             }
//                         }
//                     }
//                 }
//             }

            // this.diry = 1
            // this.body.draw()
            // this.footspot.draw()
            this.body.xmom *= .96
            if (Math.abs(this.body.xmom) < .5) {
                this.body.xmom = 0
                this.disabled = 0
            }
            // this.health.draw()

        }

        control() {

            if(this != pomaos [0]){
                return
            }
            if (gamepadAPI.buttonsStatus.includes('RB') || keysPressed['p']) {
                if (pausefalse == false) {
                    if (this.pausetimer <= 0) {
                        pausefalse = true
                        this.paused = -10
                        this.pausetimer = 30
                    }
                }
            }
            this.pausetimer--

            gamepadAPI.update()

            // ////////console.log(gamepadAPI)
            //   if(gamepadAPI.buttonsStatus.includes('A')){
            if (gamepadAPI.axesStatus[1] < -.5 || gamepadAPI.buttonsStatus.includes('A')) {
                // this.rooted = {}
                if (this.jumping == 0) {
                    this.body.ymom = -5.1

                    this.runner = 0
                } else if (this.jumping == 2) {
                    if (this.bonked == 0) {
                        this.body.ymom = -2.1
                        this.runner = 0
                    }
                } else {

                    if (this.runner > 37  || cheats.nowear == 1) {

                        if (this.hng < .1) {
                            this.hng += .006
                        } else if (this.hng < .2) {
                            this.hng += .006
                        } else {
                            this.hng += .001
                        }
                        if (this.hng < .216 || cheats.nowear == 1) {
                            this.body.ymom += -this.hng
                            ////////console.log(this.hng)
                        } else {
                            // this.hng = -.05
                            // this.runner = 0
                        }

                    }

                }
            } else if (keysPressed['w'] || gamepadAPI.buttonsStatus.includes('A')) {
                // this.rooted = {}
                if (this.jumping == 0) {
                    if (this.bonked == 0) {

                        this.body.ymom = -5.1
                        this.runner = 0
                    }
                } else if (this.jumping == 2) {
                    if (this.bonked == 0) {
                        this.body.ymom = -2.1
                        this.runner = 0
                    }
                } else {
   
                    if (this.runner > 37  || cheats.nowear == 1) {

                        if (this.hng < .1) {
                            this.hng += .006
                        } else if (this.hng < .2) {
                            this.hng += .006
                        } else {
                            this.hng += .001
                        }
                        if (this.hng < .216 || cheats.nowear == 1) {
                            this.body.ymom += -this.hng
                            ////////console.log(this.hng)
                        } else {
                            // this.hng = -.05
                            // this.runner = 0
                        }

                    }
                }
            } else {
                if (this.hng != 0) {
                    this.hng *= .997
                }
            }

            // this.xdir = 0
            // this.ydir = 0




            let gamepad
            // ////////console.log(pomao)




            this.ydir = 0
            this.xdir = 0
            // for(let t = 0; Math.abs(this.body.ymom) > 5.2;t++){
            //     this.body.ymom*=.99
            // }
            for (let t = 0; Math.abs(this.body.symom) > 5.2; t++) {
                this.body.symom *= .99
            }
            for (let t = 0; Math.abs(this.body.sxmom) > 3.5; t++) {
                this.body.sxmom *= .99
            }
            this.body.sxmom *= .999

            this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
            this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")

            //   if(gamepadAPI.buttonsStatus.includes('A')){
            if (keysPressed['f'] || keysPressed['n'] || gamepadAPI.buttonsStatus.includes('DPad-Left') || gamepadAPI.buttonsStatus.includes('Axis-Left')) {
                // this.rooted = {}
                if (this.jumping == 1) {
                    if (this.body.ymom > -3.5) {
                        if (this.runner > 21) {
                            this.pounding = 10
                            this.body.ymom = 17
                            this.timeloop = Math.PI
                        }
                    }
                }

            }




            this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
            this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")
            if (keysPressed['a'] || keysPressed['d'] || (this.body.symom !== 0 || this.body.sxmom !== 0)) {
                // this.rooted = {}
                for (let t = 1; t < this.eggs.length; t++) {
                    if (this.eggs[t].marked == 0) {
                        if (this.blocked == 0 || this.blocked == 2) {
                            this.eggs[t].steer()
                        }
                    }
                }
            }


            if (keysPressed['s']) {
                // this.body.y+=2
                // for(let t = 0; t<fruits.length; t++){
                //     if(this.body.doesPerimeterTouch(fruits[t].body)  || fruits[t].body.doesPerimeterTouch(this.tongue)){
                //         // fruits[t].y+=1.9
                //         // fruits[t].x+=this.body.xmom
                //         // fruits[t].y+=this.body.ymom
                //     }
                // }
            }


            this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
            this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")
            if (this.disabled == 0) {
                if (keysPressed['a']) {
                    // this.rooted = {}
                    this.dir = -1
                    if (this.blocked !== 1 && this.blocked !== 2) {
                        this.dir = -1
                        this.body.x -= 3
                        if (this.body.sxmom > 0) {
                            this.body.sxmom = 0
                        }

                                if(this == pomaos[0]){
                        canvas_context.translate(3, 0)
                                }
                        // for (let t = 0; t < fruits.length; t++) {
                        //     if (this.body.doesPerimeterTouch(fruits[t].body) || fruits[t].body.doesPerimeterTouch(this.tongue)) {
                        //         fruits[t].x -= 2.9
                        //         // fruits[t].x+=this.body.xmom
                        //         // fruits[t].y+=this.body.ymom
                        //     }
                        // }

                    }

                } else if (keysPressed['d']) {
                    // this.rooted = {}
                    this.dir = 1
                    if (this.blocked !== -1 && this.blocked !== 2) {
                        this.body.x += 3
                        this.dir = 1
                        if (this.body.sxmom < 0) {
                            this.body.sxmom = 0
                        }

                                if(this == pomaos[0]){
                        canvas_context.translate(-3, 0)
                                }
                        // for (let t = 0; t < fruits.length; t++) {
                        //     if (this.body.doesPerimeterTouch(fruits[t].body) || fruits[t].body.doesPerimeterTouch(this.tongue)) {
                        //         fruits[t].x += 2.9
                        //         // fruits[t].x+=this.body.xmom
                        //         // fruits[t].y+=this.body.ymom
                        //     }
                        // }

                    }
                } else if (gamepadAPI.axesStatus.length > 0) {
                    if (Math.abs(gamepadAPI.axesStatus[0]) > .2) {
                        // this.rooted = {}
                        // this.body.x+= gamepadAPI.axesStatus[0]*3
                        // canvas_context.translate(-gamepadAPI.axesStatus[0]*3,0)

                        // }else{
                        // }else if(this.blocked*gamepadAPI.axesStatus[0]*3 > 0){



                        if (this.blocked == 0) {
                            if (gamepadAPI.axesStatus[0] * 3 > 0) {
                                // //////console.log("top")
                                this.body.x += gamepadAPI.axesStatus[0] * 3
                                canvas_context.translate(-gamepadAPI.axesStatus[0] * 3, 0)

                            } else {
                                // //////console.log("bottom")
                                this.body.x += gamepadAPI.axesStatus[0] * 3
                                canvas_context.translate(-gamepadAPI.axesStatus[0] * 3, 0)

                            }
                        } else if (gamepadAPI.axesStatus[0] * 3 * this.blocked > 0) {
                            // this.rooted = {}
                            this.body.x += gamepadAPI.axesStatus[0] * 3
                            canvas_context.translate(-gamepadAPI.axesStatus[0] * 3, 0)

                        }


                        // }
                        if (gamepadAPI.axesStatus[0] * 3 < .1) {
                            // this.rooted = {}
                            this.dir = -1
                            if (this.body.sxmom > 0) {
                                this.body.sxmom = 0
                            }
                        }
                        if (gamepadAPI.axesStatus[0] * 3 > -.1) {
                            // this.rooted = {}
                            this.dir = 1
                            if (this.body.sxmom < 0) {
                                this.body.sxmom = 0
                            }
                        }
                        for (let t = 1; t < this.eggs.length; t++) {
                            this.eggs[t].steer()
                        }
                    }
                }
            }
            // if(keysPressed['p']){
            //     canvas_context.clearRect(-100000,-100000,canvas.width*1000, canvas.height*1000)
            // }

            this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
            this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")
            if (keysPressed[' ']) {
                // console.log("Daed")
                this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
                this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")
                this.tongue = new Circle(this.body.x + this.tonguex, this.body.y + this.tonguey, 5, "blue")
                if (this.bodyxtight.isPointInside(this.tongue)) {
                    if (keysPressed['ArrowDown'] || keysPressed['k']) {
                        this.ydir = 1
                        // this.tongueymom = 33
                    } if (keysPressed['ArrowUp'] || keysPressed['i']) {
                        this.ydir = -1
                        // ////////console.log('hit')
                        // this.tongueymom = -33
                    } if (keysPressed['ArrowLeft'] || keysPressed['j']) {
                        this.xdir = -1
                        // this.tonguexmom = -33
                    } if (keysPressed['ArrowRight'] || keysPressed['l']) {
                        this.xdir = 1
                        // this.tonguexmom = 33
                    }
                    if (this.xdir == 1) {
                        this.tonguexmom = 33.1 / 2
                        this.dir = 1
                    }
                    if (this.ydir == 1) {
                        this.tongueymom = 33.1 / 2
                    }
                    if (this.xdir == -1) {
                        this.tonguexmom = -33.1 / 2
                        this.dir = -1
                    }
                    if (this.ydir == -1) {
                        this.tongueymom = -33.1 / 2
                    }
                    if (this.xdir * this.ydir != 0) {
                        this.tonguexmom *= .81
                        this.tongueymom *= .81
                    }

                    if (this.xdir == 0 && this.ydir == 0) {
                        if (this.dir == 1) {
                            this.tonguey = 0
                            this.tongueymom = 0
                            this.tonguexmom = 34 / 2
                        } else {
                            this.tonguey = 0
                            this.tongueymom = 0
                            this.tonguexmom = -34 / 2
                        }
                    }

                    if(cheats.megamao == 1){
                        this.tongueymom*=2
                        this.tonguexmom*=2
                    }

                    this.fired = 3
                }
            } else if (gamepadAPI.axesStatus.length > 0) {
                if (Math.abs(gamepadAPI.axesStatus[2]) + Math.abs(gamepadAPI.axesStatus[3]) > .9 && !gamepadAPI.buttonsStatus.includes('Axis-Right')) {

                    this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
                    this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")
                    if (this.bodyxtight.isPointInside(this.tongue)) {

                        this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
                        this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")

                        let kick = 0





                        const hurtle = (Rax(Math.atan2(((gamepadAPI.axesStatus[3])), ((gamepadAPI.axesStatus[2])))))


                        if ((hurtle > 0 && hurtle < 22.5) || (hurtle > (360 - 22.5))) {
                            this.xdir = 1
                            this.tonguexmom = 33.1 / 2
                            this.dir = 1
                            kick++
                        }
                        if ((hurtle > 22.5 && hurtle < 67.5)) {
                            this.xdir = 1
                            this.tonguexmom = 33.1 / 2
                            this.dir = 1
                            kick++
                            this.ydir = 1
                            this.tongueymom = 33.1 / 2
                            kick++
                        }
                        if ((hurtle > 67.5 && hurtle < 112.5)) {
                            this.ydir = 1
                            this.tongueymom = 33.1 / 2
                            kick++
                        }
                        if ((hurtle > 112.5 && hurtle < 157.5)) {
                            this.xdir = -1
                            this.tonguexmom = -33.1 / 2
                            this.dir = -1
                            kick++
                            this.ydir = 1
                            this.tongueymom = 33.1 / 2
                            kick++
                        }
                        if ((hurtle > 157.5 && hurtle < 202.5)) {
                            this.xdir = -1
                            this.tonguexmom = -33.1 / 2
                            this.dir = -1
                            kick++
                        }
                        if ((hurtle > 202.5 && hurtle < 247.5)) {
                            this.xdir = -1
                            this.tonguexmom = -33.1 / 2
                            this.dir = -1
                            kick++
                            this.ydir = -1
                            this.tongueymom = -33.1 / 2
                            kick++
                        }
                        if ((hurtle > 247.5 && hurtle < 292.5)) {
                            this.ydir = -1
                            this.tongueymom = -33.1 / 2
                            kick++
                        }
                        if ((hurtle > 292.5 && hurtle < (360 - 22.5))) {
                            this.xdir = 1
                            this.tonguexmom = 33.1 / 2
                            kick++
                            this.dir = 1
                            this.ydir = -1
                            this.tongueymom = -33.1 / 2
                            kick++
                        }


                        if (kick == 2) {
                            this.tonguexmom *= .81
                            this.tongueymom *= .81
                        }

                        this.fired = 3

                    }
                }
            } else if (this.bodytight.isPointInside(this.tongue)) {
                this.tonguey *= .5
                this.tonguex *= .5
            }


            this.ydir = 0
            this.xdir = 0
            this.eggtimer++

            this.bodyxtight = new Circle(this.body.x, this.body.y, 9, "red")
            this.bodytight = new Circle(this.body.x, this.body.y, 21, "yellow")
            if (this.eggs[this.eggs.length - 1] != this.body || cheats.ruthless == 1) {

                if (this.eggs.length > 1 && this.eggtimer > 10) {
                    if (keysPressed['m'] || (gamepadAPI.buttonsStatus.includes('Axis-Right') && (Math.abs(gamepadAPI.axesStatus[2]) + Math.abs(gamepadAPI.axesStatus[3]) > .3))) {

                        if (keysPressed['m']) {

                            this.eggtimer = 0
                        }
                        if (keysPressed['ArrowDown'] || keysPressed['k']) {
                            this.ydir = 1
                            // this.tongueymom = 33
                        } if (keysPressed['ArrowUp'] || keysPressed['i']) {
                            this.ydir = -1
                            // ////////console.log('hit')
                            // this.tongueymom = -33
                        } if (keysPressed['ArrowLeft'] || keysPressed['j']) {
                            this.xdir = -1
                            // this.tonguexmom = -33
                        } if (keysPressed['ArrowRight'] || keysPressed['l']) {
                            this.xdir = 1
                            // this.tonguexmom = 33
                        }

                        //.3
                        // if(gamepadAPI.axesStatus[3] < -.3){
                        //     this.ydir = -1
                        //     // this.tongueymom = -33.1
                        // } if(gamepadAPI.axesStatus[3] > .3){
                        //     this.ydir = 1
                        //     // this.tongueymom = 33.1
                        //     this.dir = 1
                        // }
                        // if(gamepadAPI.axesStatus[2] > .3){
                        //     this.xdir = 1
                        //     // this.tonguexmom = 33.1
                        // }
                        // if(gamepadAPI.axesStatus[2] < -.3){
                        //     this.xdir = -1
                        //     // this.tonguexmom = -33.1
                        //     this.dir = -1
                        // }

                        if (keysPressed['m']) {
                            if (this.xdir == -1) {
                                if(cheats.ruthless == 0) {
                                this.eggs[this.eggs.length - 1].x = this.body.x + (this.dir * 29)
                                this.eggs[this.eggs.length - 1].y = this.body.y
                                }
                                this.eggs[this.eggs.length - 1].marked = 1
                                this.eggs[this.eggs.length - 1].xmom = -12
                                this.eggs[this.eggs.length - 1].ymom = -3
                                // this.thrown.push(this.eggs[this.eggs.length-1])
                                // this.eggs.pop()
                                this.dir = -1
                            }
                            if (this.xdir == 1) {

                                if(cheats.ruthless == 0) {
                                this.eggs[this.eggs.length - 1].x = this.body.x + (this.dir * 29)
                                this.eggs[this.eggs.length - 1].y = this.body.y
                                }
                                this.eggs[this.eggs.length - 1].marked = 1
                                this.eggs[this.eggs.length - 1].xmom = 12
                                this.eggs[this.eggs.length - 1].ymom = -3
                                // this.thrown.push(this.eggs[this.eggs.length-1])
                                // this.eggs.pop()
                                this.dir = 1
                            }
                            if (this.ydir == 1) {
                                if(cheats.ruthless == 0) {
                                this.eggs[this.eggs.length - 1].x = this.body.x + (this.dir * 29)
                                this.eggs[this.eggs.length - 1].y = this.body.y
                                }
                                this.eggs[this.eggs.length - 1].marked = 1
                                this.eggs[this.eggs.length - 1].xmom += this.dir
                                this.eggs[this.eggs.length - 1].ymom = 8
                                // this.thrown.push(this.eggs[this.eggs.length-1])
                                // this.eggs.pop()
                            }
                            if (this.ydir == -1) {
                                if(cheats.ruthless == 0) {
                                this.eggs[this.eggs.length - 1].x = this.body.x + (this.dir * 29)
                                this.eggs[this.eggs.length - 1].y = this.body.y
                                }
                                this.eggs[this.eggs.length - 1].marked = 1
                                this.eggs[this.eggs.length - 1].xmom += this.dir
                                this.eggs[this.eggs.length - 1].ymom = -8
                                // this.thrown.push(this.eggs[this.eggs.length-1])
                                // this.eggs.pop()
                            }
                            if (this.xdir * this.ydir != 0) {
                                // this.eggs[this.eggs.length-1].x  = this.body.x
                                // this.eggs[this.eggs.length-1].y  = this.body.y
                                this.eggs[this.eggs.length - 1].marked = 1
                                if(cheats.ruthless == 0) {
                                this.eggs[this.eggs.length - 1].x = this.body.x + (this.dir * 29)
                                this.eggs[this.eggs.length - 1].y = this.body.y
                                }
                                this.eggs[this.eggs.length - 1].xmom *= .8
                                this.eggs[this.eggs.length - 1].ymom *= .8
                                // this.thrown.push(this.eggs[this.eggs.length-1])
                                // this.eggs.pop()
                            }


                            if (this.xdir == 0 && this.ydir == 0) {
                                if (this.dir == 1) {

                                    if(cheats.ruthless == 0) {
                                    this.eggs[this.eggs.length - 1].x = this.body.x + (this.dir * 29)
                                    this.eggs[this.eggs.length - 1].y = this.body.y
                                    }
                                    this.eggs[this.eggs.length - 1].marked = 1
                                    this.eggs[this.eggs.length - 1].xmom = 12
                                    this.eggs[this.eggs.length - 1].ymom = -.95
                                    // this.thrown.push(this.eggs[this.eggs.length-1])
                                    // this.eggs.pop()
                                } else {

                                    if(cheats.ruthless == 0) {
                                    this.eggs[this.eggs.length - 1].x = this.body.x + (this.dir * 29)
                                    this.eggs[this.eggs.length - 1].y = this.body.y
                                    }
                                    this.eggs[this.eggs.length - 1].marked = 1
                                    this.eggs[this.eggs.length - 1].xmom = -12
                                    this.eggs[this.eggs.length - 1].ymom = -.95
                                    // this.thrown.push(this.eggs[this.eggs.length-1])
                                    // this.eggs.pop()
                                }





                                // ////////console.log(this.eggs)
                                // this.eggs.splice(this.eggs.length-1, 1)
                                // ////////console.log(this.eggs)
                            }
                        }



                        if (this.egglock == 3) {

                            if (Math.abs(gamepadAPI.axesStatus[3]) > .25 || Math.abs(gamepadAPI.axesStatus[2]) > .25) {

                                if(cheats.ruthless == 0) {
                                this.eggs[this.eggs.length - 1].x = this.body.x + (this.dir * 29)
                                this.eggs[this.eggs.length - 1].y = this.body.y
                                }
                                this.eggs[this.eggs.length - 1].ymom = (gamepadAPI.axesStatus[3] * 14)
                                this.eggs[this.eggs.length - 1].xmom = (gamepadAPI.axesStatus[2] * 14)
                            }
                            if (this.blush > 1) {
                                this.eggs[this.eggs.length - 1].hot = 1
                            }
                            this.thrown.push(this.eggs[this.eggs.length - 1])
                            for (let t = 0; t < this.eggs.length; t++) {
                                if (this.thrown.includes(this.eggs[t])) {
                                    this.eggs.splice(t, 1)
                                }
                            }
                            this.egglock = 0
                            this.eggtimer = 0
                        }


                        if (Math.abs(gamepadAPI.axesStatus[3]) > .25 || Math.abs(gamepadAPI.axesStatus[2]) > .25) {
                            this.egglock++
                        }

                        if (keysPressed['m']) {
                            if (this.blush > 1) {
                                this.eggs[this.eggs.length - 1].hot = 1
                            }
                            this.thrown.push(this.eggs[this.eggs.length - 1])
                            for (let t = 0; t < this.eggs.length; t++) {
                                if (this.thrown.includes(this.eggs[t])) {
                                    this.eggs.splice(t, 1)
                                }
                            }
                        }

                    }
                }

            }
            if (keysPressed['ArrowLeft'] || keysPressed['j']) {
                this.xdir = -1
                this.dir = -1
            }
            if (keysPressed['ArrowRight'] || keysPressed['l']) {
                this.xdir = 1
                this.dir = 1
            }

            this.runner++
        }


    }


    let pomao = new Pomao()
    console.log(pomao, "hit")
    let pomaos = [pomao]

    // let floor = new Rectangle(-50000000, 713, 1000000000, 100000000, "Red")
    let floors = []

    for(let t= 0;t<72;t++){
        let floor = new Rectangle(-2000+ ((t%18)*240), 90+Math.floor(t/18) *180, 60, 20, "white")
        floor.drawflash  = 0
        floors.push(floor)
    }

    
    let dots = []

    for(let t = 0;t<300;t++){
        let dot = new Circle(-5000+(Math.random()*10000), -2500+(Math.random()*3400), 5, getRandomColor()) 
        dots.push(dot)
    }


    let counter = 0
    let ball = new Circle(1350, 350, 140, "white")
    // canvas_context.translate(0, 300)
    // canvas_context.scale(.3,.3)


                    PomaohopSocketize(ws)

                    function PomaohopSocketize(ws) {

                        // console.log("0hit")

                        // console.log("hit")
                        ws.addEventListener("message", ({
                            data
                        }) => {

                                if (JSON.parse(data).pomaohop >= 0) {
                                    console.log(JSON.parse(data))
                                // console.log("hit")

                                if (pomaoIds.includes(JSON.parse(data).id)) {
                                    pomaos[pomaoIds.indexOf(JSON.parse(data).id)] = new Pomao(JSON.parse(data))
                                } else {
                                    pomaoIds.push(JSON.parse(data).id)
                                    pomaos[pomaoIds.length - 1] = new Pomao(JSON.parse(data))
                                }

                            } else {





                                if (booter.running == 0) {
                                    return
                                }
                                textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)
                                textcanvas_context.font = "12px arial"
                                textcanvas_context.fillStyle = JSON.parse(data).color
                                if (typeof JSON.parse(data).name != "undefined") {


                                    let ypointer = 300 + textscroll
                                    let stoarr = (`(${JSON.parse(data).name}) ` + ' ' + JSON.parse(data).text).split('')
                                    let stostring = ''
                                    for (let t = 0; t < stoarr.length; t++) {
                                        const width = textcanvas_context.measureText(stostring + '' + stoarr[t]).width
                                        if (width > textcanvas.width - 12) {
                                            textcanvas_context.fillText(stostring + '' + stoarr[t], 0, ypointer)
                                            ypointer += 12
                                            textscroll += 12
                                            stostring = ''
                                        } else {
                                            stostring = stostring + "" + stoarr[t]
                                            if (t == stoarr.length - 1) {

                                                textscroll += 12
                                                textcanvas_context.fillText(stostring, 0, ypointer)
                                            }
                                        }
                                    }


                                    // textcanvas_context.fillText(`(${JSON.parse(data).name}) `+ JSON.parse(data).text, 0, 300+textscroll)


                                    console.log(JSON.parse(data).measure)
                                        // textscroll += JSON.parse(data).measure
                                }
                                // textcanvas_context.translate(0, 12)
                                // textcanvas.translate(0, 12)
                            }
                        })

                        // let json = {}
                        // json.connecting = 1

                        // ws.send(JSON.stringify(json))
                        // })

                    }

    
    function main() {
        canvas_context.clearRect(-100000, -100000, canvas.width*1000, canvas.height*1000)  // refreshes the image
        gamepadAPI.update() //checks for button presses/stick movement on the connected controller)
        // console.log("bighit")
        windowspares[booter.index] = canvas
        for(let t = 0;t<dots.length;t++){
            dots[t].draw()
        }
        ball.move()
        if(ball.y+ball.radius < 713){
            ball.ymom += .2
        }else{
            ball.ymom = 0
            ball.y = 713-ball.radius
        }

        let round = 12
        // ball.draw()
        ball.xmom *= .991
        ball.ymom *= .991

        for(let t= 0;t<floors.length;t++){
            if(floors[t].drawflash == 0){
                floors[t].draw()
            }else{
                if(counter%50 > 30){
                    floors[t].draw()
                }

                if(counter%400 == 0){
                    floors[t].marked = 1
                }
            }
        }

        for(let t= 0;t<floors.length;t++){
            if(floors[t].marked == 1){
                floors.splice(t,1)
            }
        }
        if(counter%1000 == 0){
            for(let t= 0;t<round;t++){
                floors[Math.floor(Math.random()*floors.length)].drawflash = 1
            }
            round--
            counter == 0
        }
        counter++ 
        for(let t = 0;t<pomaos.length;t++){
        pomaos[t].draw()

        if(counter%10 == 0){
        if(t == 0){
        let pson = {}

        pson.id = pomaos[t].id
        pson.pomaohop = 1

        pson.x = pomaos[t].body.x
        pson.y = pomaos[t].body.y
        pson.xt = pomaos[t].tongue.x
        pson.yt = pomaos[t].tongue.y
        pson.xto = pomaos[t].tonguex
        pson.yto = pomaos[t].tonguey
        pson.dir = pomaos[t].dir
        pson.xdir = pomaos[t].xdir
        pson.ydir = pomaos[t].ydir
        // console.log(JSON.stringify(pson))
        ws.send(JSON.stringify(pson))
        }
        }
        }
    }

               booter.main =  main


               console.log(booter)
            }else  if (booter.index == 4) {

                    let canvas
                    let canvas_context
                    let keysPressed = {}
                    let FLEX_engine
                    let TIP_engine = {}
                    let XS_engine
                    let YS_engine
                    class Point {
                        constructor(x, y) {
                            this.x = x
                            this.y = y
                            this.radius = 0
                        }
                        pointDistance(point) {
                            return (new LineOP(this, point, "transparent", 0)).hypotenuse()
                        }
                    }
                    class Line {
                        constructor(x, y, x2, y2, color, width) {
                            this.x1 = x
                            this.y1 = y
                            this.x2 = x2
                            this.y2 = y2
                            this.color = color
                            this.width = width
                        }
                        hypotenuse() {
                            let xdif = this.x1 - this.x2
                            let ydif = this.y1 - this.y2
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x1, this.y1)
                            canvas_context.lineTo(this.x2, this.y2)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class LineOP {
                        constructor(object, target, color, width) {
                            this.object = object
                            this.target = target
                            this.color = color
                            this.width = width
                        }
                        hypotenuse() {
                            let xdif = this.object.x - this.target.x
                            let ydif = this.object.y - this.target.y
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                        }
                        angle() {
                            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.object.x, this.object.y)
                            canvas_context.lineTo(this.target.x, this.target.y)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class Triangle {
                        constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
                            this.x = x
                            this.y = y
                            this.color = color
                            this.length = length
                            this.x1 = this.x + this.length * leg1Ratio
                            this.x2 = this.x - this.length * leg2Ratio
                            this.tip = this.y - this.length * heightRatio
                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                            this.fill = fill
                            this.stroke = strokeWidth
                        }
                        draw() {
                            canvas_context.strokeStyle = this.color
                            canvas_context.stokeWidth = this.stroke
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x, this.y)
                            canvas_context.lineTo(this.x1, this.y)
                            canvas_context.lineTo(this.x, this.tip)
                            canvas_context.lineTo(this.x2, this.y)
                            canvas_context.lineTo(this.x, this.y)
                            if (this.fill == 1) {
                                canvas_context.fill()
                            }
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                        isPointInside(point) {
                            if (point.x <= this.x1) {
                                if (point.y >= this.tip) {
                                    if (point.y <= this.y) {
                                        if (point.x >= this.x2) {
                                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                                            this.basey = point.y - this.tip
                                            this.basex = point.x - this.x
                                            if (this.basex == 0) {
                                                return true
                                            }
                                            this.slope = this.basey / this.basex
                                            if (this.slope >= this.accept1) {
                                                return true
                                            } else if (this.slope <= this.accept2) {
                                                return true
                                            }
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Rectangle {
                        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
                            this.x = x
                            this.y = y
                            this.height = height
                            this.width = width
                            this.color = color

                            this.r = 0 //Math.random() * 10
                            this.g = 0 //Math.random() * 10
                            this.b = 0 //Math.random() * 10
                            this.color = `rgba(${this.r},${this.g},${this.b}, 1)`
                            this.xmom = 0
                            this.ymom = 0
                            this.stroke = stroke
                            this.strokeWidth = strokeWidth
                            this.fill = fill
                        }
                        draw() {
                            this.color = `rgba(${this.r*2.5},${this.g*2.5},${this.b*2.5}, 1)`
                            canvas_context.strokeStyle = this.color
                            canvas_context.fillStyle = this.color
                            canvas_context.fillRect(this.x, this.y, this.width, this.height)
                            canvas_context.strokeRect(this.x, this.y, this.width, this.height)
                        }
                        move() {
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        isPointInside(point) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        if (point.y <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y + point.radius >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesFootTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y + point.radius >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        // if (point.y + point.radius <= this.y + this.height) {
                                        if (point.y <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesHeadTouch(point) {
                            // if (point.x + point.radius >= this.x) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        // if (point.y - point.radius <= this.y + this.height) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesLeftTouch(point) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesRightTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Circle {
                        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                            this.x = x
                            this.y = y
                            this.radius = radius
                            this.color = color
                            this.xmom = xmom
                            this.ymom = ymom
                            this.friction = friction
                            this.reflect = reflect
                            this.strokeWidth = strokeWidth
                            this.strokeColor = strokeColor
                            this.marked = 0
                            this.r = 0
                            this.g = 0
                            this.b = 0

                            // this.color = getDirtColor()
                            // this.color = getDirtColor()
                            this.color = "tan"
                        }
                        draw() {
                            canvas_context.lineWidth = this.strokeWidth

                            // this.color = `rgba(${this.r*2.5},${this.g*2.5},${this.b*2.5}, 1)`
                            canvas_context.strokeStyle = this.color

                            canvas_context.beginPath();
                            if (this.radius > 0) {
                                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                                canvas_context.fillStyle = this.color
                                canvas_context.fill()
                                canvas_context.stroke();
                            } else {
                                console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                            }
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }

                            this.x += this.xmom
                            this.y += this.ymom
                            canvas_context.translate(-this.xmom, -this.ymom)
                        }
                        unmove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        frictiveMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            canvas_context.translate(-this.xmom, -this.ymom)
                            this.xmom *= this.friction
                            this.ymom *= this.friction
                        }
                        frictiveunMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.xmom /= this.friction
                            this.ymom /= this.friction
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        isPointInside(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                                return true
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                                return true
                            }
                            return false
                        }
                    }
                    class Polygon {
                        constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
                            if (sides < 2) {
                                sides = 2
                            }
                            this.reflect = reflect
                            this.xmom = xmom
                            this.ymom = ymom
                            this.body = new Circle(x, y, size - (size * .293), "transparent")
                            this.nodes = []
                            this.angle = angle
                            this.size = size
                            this.color = color
                            this.angleIncrement = (Math.PI * 2) / sides
                            this.sides = sides
                            for (let t = 0; t < sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                        }
                        isPointInside(point) { // rough approximation
                            this.body.radius = this.size - (this.size * .293)
                            if (this.sides <= 2) {
                                return false
                            }
                            this.areaY = point.y - this.body.y
                            this.areaX = point.x - this.body.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                                return true
                            }
                            return false
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.body.x > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.body.x < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.body.x += this.xmom
                            this.body.y += this.ymom
                        }
                        draw() {
                            this.nodes = []
                            this.angleIncrement = (Math.PI * 2) / this.sides
                            this.body.radius = this.size - (this.size * .293)
                            for (let t = 0; t < this.sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                            canvas_context.strokeStyle = this.color
                            canvas_context.fillStyle = this.color
                            canvas_context.lineWidth = 0
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
                            for (let t = 1; t < this.nodes.length; t++) {
                                canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
                            }
                            canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
                            canvas_context.fill()
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                    }
                    class Shape {
                        constructor(shapes) {
                            this.shapes = shapes
                        }
                        isPointInside(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].isPointInside(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].doesPerimeterTouch(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        isInsideOf(box) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (box.isPointInside(this.shapes[t])) {
                                    return true
                                }
                            }
                            return false
                        }
                        push(object) {
                            this.shapes.push(object)
                        }
                    }
                    class Spring {
                        constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
                            if (body == 0) {
                                this.body = new Circle(x, y, radius, color)
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            } else {
                                this.body = body
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            }
                            this.gravity = gravity
                            this.width = width
                        }
                        balance() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            if (this.beam.hypotenuse() < this.length) {
                                this.body.xmom += (this.body.x - this.anchor.x) / this.length
                                this.body.ymom += (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
                            } else {
                                this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
                            }
                            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
                        }
                        draw() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            this.beam.draw()
                            this.body.draw()
                            this.anchor.draw()
                        }
                        move() {
                            this.anchor.ymom += this.gravity
                            this.anchor.move()
                        }

                    }
                    class Color {
                        constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
                            this.hue = baseColor
                            if (red != -1 && green != -1 && blue != -1) {
                                this.r = red
                                this.g = green
                                this.b = blue
                                if (alpha != 1) {
                                    if (alpha < 1) {
                                        this.alpha = alpha
                                    } else {
                                        this.alpha = alpha / 255
                                        if (this.alpha > 1) {
                                            this.alpha = 1
                                        }
                                    }
                                }
                                if (this.r > 255) {
                                    this.r = 255
                                }
                                if (this.g > 255) {
                                    this.g = 255
                                }
                                if (this.b > 255) {
                                    this.b = 255
                                }
                                if (this.r < 0) {
                                    this.r = 0
                                }
                                if (this.g < 0) {
                                    this.g = 0
                                }
                                if (this.b < 0) {
                                    this.b = 0
                                }
                            } else {
                                this.r = 0
                                this.g = 0
                                this.b = 0
                            }
                        }
                        normalize() {
                            if (this.r > 255) {
                                this.r = 255
                            }
                            if (this.g > 255) {
                                this.g = 255
                            }
                            if (this.b > 255) {
                                this.b = 255
                            }
                            if (this.r < 0) {
                                this.r = 0
                            }
                            if (this.g < 0) {
                                this.g = 0
                            }
                            if (this.b < 0) {
                                this.b = 0
                            }
                        }
                        randomLight() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12) + 4)];
                            }
                            var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
                            return color;
                        }
                        randomDark() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12))];
                            }
                            var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
                            return color;
                        }
                        random() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 16))];
                            }
                            var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
                            return color;
                        }
                    }
                    class Softbody { //buggy, spins in place
                        constructor(x, y, radius, color, members = 10, memberLength = 5, force = 10, gravity = 0) {
                            this.springs = []
                            this.pin = new Circle(x, y, radius, color)
                            this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
                            this.springs.push(this.spring)
                            for (let k = 0; k < members; k++) {
                                this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
                                if (k < members - 1) {
                                    this.springs.push(this.spring)
                                } else {
                                    this.spring.anchor = this.pin
                                    this.springs.push(this.spring)
                                }
                            }
                            this.forceConstant = force
                            this.centroid = new Point(0, 0)
                        }
                        circularize() {
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.springs.length; s++) {
                                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                            this.angle = 0
                            this.angleIncrement = (Math.PI * 2) / this.springs.length
                            for (let t = 0; t < this.springs.length; t++) {
                                this.springs[t].body.x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                                this.springs[t].body.y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                                this.angle += this.angleIncrement
                            }
                        }
                        balance() {
                            for (let s = this.springs.length - 1; s >= 0; s--) {
                                this.springs[s].balance()
                            }
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.springs.length; s++) {
                                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                            for (let s = 0; s < this.springs.length; s++) {
                                this.link = new Line(this.centroid.x, this.centroid.y, this.springs[s].anchor.x, this.springs[s].anchor.y, 0, "transparent")
                                if (this.link.hypotenuse() != 0) {
                                    this.springs[s].anchor.xmom += (((this.springs[s].anchor.x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                                    this.springs[s].anchor.ymom += (((this.springs[s].anchor.y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                                }
                            }
                            for (let s = 0; s < this.springs.length; s++) {
                                this.springs[s].move()
                            }
                            for (let s = 0; s < this.springs.length; s++) {
                                this.springs[s].draw()
                            }
                        }
                    }
                    class Observer {
                        constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
                            this.body = new Circle(x, y, radius, color, 0, 0, 1, 1)
                            this.color = color
                            this.ray = []
                            this.rayrange = range
                            this.globalangle = Math.PI
                            this.gapangle = angle
                            this.currentangle = 0
                            this.obstacles = []
                            this.raymake = rays
                            this.turner = Math.floor((Math.random() - .5) * 3)
                            this.turnrate = Math.random() * .05
                        }
                        beam() {
                            this.currentangle = this.gapangle / 2
                            for (let k = 0; k < this.raymake; k++) {
                                this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                                let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                                ray.collided = 0
                                ray.lifespan = this.rayrange - 1
                                ray.move()
                                ray.move()
                                ray.move()
                                this.ray.push(ray)
                            }
                            for (let f = 0; f < this.rayrange; f++) {
                                for (let t = 0; t < this.ray.length; t++) {
                                    if (this.ray[t].collided < 1) {
                                        this.ray[t].move()
                                        for (let q = 0; q < this.obstacles.length; q++) {
                                            if (this.obstacles[q].isPointInside(this.ray[t])) {
                                                this.ray[t].collided = 1
                                                if (t > Math.floor(this.ray.length * .5)) {
                                                    this.turner = -1
                                                } else if (t < Math.floor(this.ray.length * .5)) {
                                                    this.turner = 1
                                                } else {
                                                    this.obstacles[q].marked = 1
                                                }

                                            }
                                        }
                                    }
                                }
                            }
                        }
                        draw() {
                            this.beam()
                            this.body.draw()
                            canvas_context.lineWidth = 1
                            canvas_context.fillStyle = this.color
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.body.x, this.body.y)
                            for (let y = 0; y < this.ray.length; y++) {
                                canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                                canvas_context.lineTo(this.body.x, this.body.y)
                            }
                            canvas_context.stroke()
                            canvas_context.fill()

                            this.body.xmom += (this.ray[(Math.floor(this.ray.length * .5))].xmom) / 100
                            this.body.ymom += (this.ray[(Math.floor(this.ray.length * .5))].ymom) / 100

                            if (this.turner == -1) {
                                this.globalangle += this.turnrate
                            }
                            if (this.turner == 1) {
                                this.globalangle -= this.turnrate
                            }


                            this.body.move()
                            this.ray = []
                        }
                    }

                    function setUp(canvas_pass, style = "#000000") {
                        canvas = canvas_pass
                        canvas_context = canvas.getContext('2d');
                        canvas.style.background = style
                            // window.setInterval(function () {
                        windowspares[booter.index] = canvas
                        booter.main = main
                            // }, 17)
                        document.addEventListener('keydown', (event) => {
                            keysPressed[event.key] = true;
                        });
                        document.addEventListener('keyup', (event) => {
                            delete keysPressed[event.key];
                        });
                        window.addEventListener('pointerdown', e => {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            TIP_engine.x = XS_engine
                            TIP_engine.y = YS_engine
                            TIP_engine.body = TIP_engine

                        });

                        window.addEventListener('pointermove', continued_stimuli);
                        window.addEventListener('pointerup', e => {
                            // window.removeEventListener("pointermove", continued_stimuli);
                        })

                        canvas.addEventListener('pointermove', continued_stimuli);

                        function continued_stimuli(e) {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            TIP_engine.x = XS_engine
                            TIP_engine.y = YS_engine
                            TIP_engine.body = TIP_engine

                            // let TIP_engineD = {}
                            // TIP_engineD.x = TIP_engine.x-diggers[0].body.x
                            // TIP_engineD.y = TIP_engine.y-diggers[0].body.y
                            // let link = new LineOP(diggers[0].body, TIP_engineD)
                            diggers[0].angle = (Math.atan2(375 - TIP_engine.y, 400 - TIP_engine.x)) + Math.PI


                        }
                    }

                    function control(object, speed = 1) { // basic control for objects
                        if (typeof object.body != 'undefined') {
                            if (keysPressed['w']) {
                                // if (object.dry == 1) {
                                //     object.body.ymom = -(speed * 3)
                                //     // canvas_context.translate(0, speed*100)
                                // } else {
                                if (object.head == 0) {
                                    object.body.y -= (speed)
                                    object.body.ymom -= .3
                                    canvas_context.translate(0, speed)
                                } else {
                                    object.dry = 2
                                }
                                // }
                            }
                            if (keysPressed['d']) {
                                if (object.right == 0) {
                                    object.body.x += speed
                                    canvas_context.translate(-speed, 0)
                                }
                            }
                            if (keysPressed['s']) {
                                if (object.dry == 0) {

                                    object.body.y += (speed)
                                    object.body.ymom += .3
                                    canvas_context.translate(0, -speed)

                                }
                            }
                            if (keysPressed['a']) {
                                if (object.left == 0) {
                                    object.body.x -= speed
                                    canvas_context.translate(speed, 0)
                                }
                            }
                            if (keysPressed['x']) {

                            }
                        } else if (typeof object != 'undefined') {
                            if (keysPressed['w']) {
                                object.y -= speed
                            }
                            if (keysPressed['d']) {
                                object.x += speed
                            }
                            if (keysPressed['s']) {
                                object.y += speed
                            }
                            if (keysPressed['a']) {
                                object.x -= speed
                            }
                        }
                    }

                    function getRandomLightColor() { // random color that will be visible on  black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12) + 4)];
                        }
                        return color;
                    }

                    function getRandomColor() { // random color
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 16) + 0)];
                        }
                        return color;
                    }

                    function getDirtColor() { // random color
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 4; i++) {
                            color += letters[(Math.floor(Math.random() * 10) + 6)];
                        }
                        color += '44'
                        return color;
                    }

                    function getRandomDarkColor() { // color that will be visible on a black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12))];
                        }
                        return color;
                    }

                    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
                        let limit = granularity
                        let shape_array = []
                        for (let t = 0; t < limit; t++) {
                            let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                            shape_array.push(circ)
                        }
                        return (new Shape(shape_array))
                    }

                    let setup_canvas = document.createElement("CANVAS");
                    setup_canvas.width = 700
                    setup_canvas.height = 700
                    setup_canvas.hidden = true

                    // let together = document.getElementById('col') //getting canvas from document

                    // let cohesion = document.getElementById('coh') //getting canvas from document
                    // let separation = document.getElementById('sep') //getting canvas from document

                    setUp(setup_canvas, "#AABBBB") // setting up canvas refrences, starting timer. 

                    // object instantiation and creation happens here 

                    class Digger {
                        constructor(args = 0) {
                            if (args == 0) {

                                this.id = digId
                                this.body = new Circle(350, 350, 20, namer, 0, 0, .99)
                                this.drill = new Circle(canvas.width * .5, canvas.height * .5, 10, "yellow")
                                this.angle = 0
                                this.red = 0
                                this.green = 0
                                this.blue = 0
                                this.maxfuel = 200
                                this.fuel = 200
                                this.fuelgauge = new Rectangle(0, 0, 100, 20, "red")
                                this.fuelgauge.r = 255
                                this.fuelgauge.g = 0
                                this.fuelgauge.b = 0
                                this.redrate = 2
                                this.bluerate = .5
                                this.greenrate = 1
                                this.money = 0
                                this.greencount = 0
                                this.redcount = 0
                                this.bluecount = 0


                                this.dry = 0
                            } else {
                                // console.log("bighit")
                                this.id = args.id
                                this.body = new Circle(args.x, args.y, 12, args.color, 0, 0, .99)
                                this.angle = args.angle
                                this.drill = new Circle(args.x + (Math.cos(((Math.random() * -.5) * .35) + this.angle) * 17), args.y + (Math.sin(((Math.random() * -.5) * .35) + this.angle) * 17), 3, "yellow")
                                this.red = 0
                                this.green = 0
                                this.blue = 0
                                this.maxfuel = 200
                                this.fuel = 200
                                this.fuelgauge = new Rectangle(0, 0, 100, 20, "red")
                                this.fuelgauge.r = 255
                                this.fuelgauge.g = 0
                                this.fuelgauge.b = 0
                                this.redrate = 2
                                this.bluerate = .5
                                this.greenrate = 1
                                this.money = args.money
                                this.greencount = 0
                                this.redcount = 0
                                this.bluecount = 0


                                this.dry = 0
                            }
                        }
                        draw() {

                            if (this.dry == 2) {
                                this.dry = 1
                            } else {
                                this.dry = 0
                            }
                            this.head = 0
                            this.left = 0
                            this.right = 0
                            for (let t = 0; t < world.grid.length; t++) {
                                for (let k = 0; k < world.grid[t].length; k++) {


                                    this.line = new LineOP(world.grid[t][k], this.body)
                                    if (this.line.hypotenuse() < 600) {
                                        if (this.fuel > 0) {
                                            if (world.grid[t][k].doesPerimeterTouch(this.drill) || world.grid[t][k].doesPerimeterTouch(this.body)) {

                                                if (diggers.indexOf(this) == 0) {

                                                    if (world.grid[t][k].r > 0) {
                                                        // world.grid[t][k].r -= this.redrate
                                                        world.grid[t][k].x -= (this.body.x - world.grid[t][k].x) / 12.3
                                                        world.grid[t][k].y -= (this.body.y - world.grid[t][k].y) / 12.3
                                                        this.red += this.redrate
                                                        this.redcount += this.redrate
                                                    }
                                                    if (world.grid[t][k].b > 0) {
                                                        // world.grid[t][k].b -= this.bluerate
                                                        world.grid[t][k].x -= (this.body.x - world.grid[t][k].x) / 12.3
                                                        world.grid[t][k].y -= (this.body.y - world.grid[t][k].y) / 12.3
                                                        this.blue += this.bluerate
                                                        this.bluecount += this.bluerate
                                                    }
                                                    if (world.grid[t][k].g > 0) {
                                                        // world.grid[t][k].g -= this.greenrate
                                                        world.grid[t][k].x -= (this.body.x - world.grid[t][k].x) / 12.3
                                                        world.grid[t][k].y -= (this.body.y - world.grid[t][k].y) / 12.3
                                                        this.green += this.greenrate
                                                        this.greencount += this.greenrate
                                                    }
                                                    // if (world.grid[t][k].g + world.grid[t][k].b + world.grid[t][k].r <= 0) {
                                                    // world.grid[t][k].marked = 1


                                                    let json = {}
                                                    json.splicer = 1
                                                    json.k = world.grid[t][k].k
                                                    json.t = world.grid[t][k].t
                                                    json.x = world.grid[t][k].x
                                                    json.y = world.grid[t][k].y


                                                    ws.send(JSON.stringify(json))
                                                        // }

                                                } else {

                                                    if (world.grid[t][k].r > 0) {
                                                        world.grid[t][k].r -= this.redrate * 1.1
                                                        this.red += this.redrate * 1.1
                                                        this.redcount += this.redrate * 1.1
                                                    }
                                                    if (world.grid[t][k].b > 0) {
                                                        world.grid[t][k].b -= this.bluerate * 1.1
                                                        this.blue += this.bluerate * 1.1
                                                        this.bluecount += this.bluerate * 1.1
                                                    }
                                                    if (world.grid[t][k].g > 0) {
                                                        world.grid[t][k].g -= this.greenrate * 1.1
                                                        this.green += this.greenrate * 1.1
                                                        this.greencount += this.greenrate * 1.1
                                                    }
                                                    if (world.grid[t][k].g + world.grid[t][k].b + world.grid[t][k].r <= 0) {

                                                        let json = {}
                                                        json.splicer = 1
                                                        json.k = world.grid[t][k].k
                                                        json.t = world.grid[t][k].t


                                                        // world.grid[t][k].marked = 1
                                                    }
                                                }
                                            }
                                        }

                                        if (world.grid[t][k].doesPerimeterTouch(this.body)) {
                                            this.dry = 1
                                        }

                                        // if (world.grid[t][k].doesFootTouch(this.body)) {
                                        //     this.dry = 1
                                        // }
                                        // if (world.grid[t][k].doesHeadTouch(this.body)) {
                                        //     this.head = 1
                                        // }
                                        // if (world.grid[t][k].doesRightTouch(this.body)) {
                                        //     this.right = 1
                                        // }
                                        // if (world.grid[t][k].doesLeftTouch(this.body)) {
                                        //     this.left = 1
                                        // }
                                    }
                                }
                            }
                            if (this.bluecount > 1) {
                                let rect = new Rectangle(this.drill.x - ((Math.random() - .5) * 3), this.drill.y - ((Math.random() - .5) * 3), 3.5, 3.5, "transparent")
                                rect.r = 0
                                rect.g = 0
                                rect.b = 255
                                rect.xmom = (Math.random() - .5) * 3
                                rect.ymom = (Math.random() - .5) * 3
                                particles.push(rect)
                                this.bluecount = 0
                            }
                            if (this.redcount > 1) {
                                let rect = new Rectangle(this.drill.x - ((Math.random() - .5) * 3), this.drill.y - ((Math.random() - .5) * 3), 3.5, 3.5, "transparent")
                                rect.r = 255
                                rect.g = 0
                                rect.b = 0
                                rect.xmom = (Math.random() - .5) * 3
                                rect.ymom = (Math.random() - .5) * 3
                                particles.push(rect)
                                this.redcount = 0
                            }
                            if (this.greencount > 1) {
                                let rect = new Rectangle(this.drill.x - ((Math.random() - .5) * 3), this.drill.y - ((Math.random() - .5) * 3), 3.5, 3.5, "transparent")
                                rect.r = 0
                                rect.g = 255
                                rect.b = 0
                                rect.xmom = Math.random() - .5
                                rect.ymom = Math.random() - .5
                                particles.push(rect)
                                this.greencount = 0
                            }

                            if (this.head == 1) {
                                if (this.body.ymom < 0) {
                                    this.body.ymom = 0
                                }
                            }
                            if (this.dry == 0) {
                                if (this.body.ymom > -5) {
                                    // this.body.ymom += .3
                                }
                            } else {
                                if (this.body.ymom > 0) {
                                    this.body.ymom = 0
                                }
                            }
                            if (diggers.indexOf(this) == 0) {
                                this.body.frictiveMove()
                            }

                            this.fuelgauge = new Rectangle(this.body.x - 330, this.body.y - 270, 100, 20, "red")
                            this.fuelgauge.width = (this.fuel / this.maxfuel) * 100
                                // this.fuel -= .03
                            if (this.fuel < 0) {
                                this.fuel = 0
                            }
                            this.fuelgauge.r = 255
                            this.fuelgauge.g = 0
                            this.fuelgauge.b = 0

                            if (diggers.indexOf(this) == 0) {
                                // this.fuelgauge.draw()

                                // canvas_context.strokeStyle = "gray"
                                // canvas_context.strokeRect(this.fuelgauge.x-1, this.fuelgauge.y-1, 102, this.fuelgauge.height+2)

                            }
                            this.drill = new Circle(this.body.x + (Math.cos(((Math.random() * -.5) * .35) + this.angle) * 40), this.body.y + (Math.sin(((Math.random() * -.5) * .35) + this.angle) * 40), 5, "Red")
                            this.drill2 = new Circle(this.body.x + (Math.cos(((Math.random() * -.5) * .35) + this.angle + (Math.PI * .5)) * 15), this.body.y + (Math.sin(((Math.random() * -.5) * .35) + this.angle + (Math.PI * .5)) * 15), 3, "yellow")
                            this.drill3 = new Circle(this.body.x + (Math.cos(((Math.random() * -.5) * .35) + this.angle - (Math.PI * .5)) * 15), this.body.y + (Math.sin(((Math.random() * -.5) * .35) + this.angle - (Math.PI * .5)) * 15), 3, "yellow")
                            this.drill.draw()
                            this.link1 = new LineOP(this.drill, this.drill2, "yellow", 8)
                                // this.link2 = new LineOP(this.drill2, this.drill3, "yellow" , 3)
                            this.link3 = new LineOP(this.drill, this.drill3, "yellow", 8)
                            this.body.draw()
                            this.link1.draw()
                                // this.link2.draw()
                            this.link3.draw()
                                // canvas_context.fill()

                            if (diggers.indexOf(this) == 0) {
                                canvas_context.font = "20px arial"
                                    // canvas_context.fillStyle = "red"
                                    // canvas_context.fillText(`Carbon: ${Math.round(this.red)}`, this.body.x - 330, this.body.y - 330)
                                    // canvas_context.fillStyle = "green"
                                    // canvas_context.fillText(`Nitrogen: ${Math.round(this.green)}`, this.body.x - 330, this.body.y - 310)
                                    // canvas_context.fillStyle = "blue"
                                    // canvas_context.fillText(`Hydrogen: ${Math.round(this.blue)}`, this.body.x - 330, this.body.y - 290)
                                for (let t = 0; t < diggers.length; t++) {

                                    canvas_context.strokeStyle = "black"
                                    canvas_context.lineWidth = 2
                                    canvas_context.font = "20px arial"
                                    canvas_context.strokeText(`$ ${Math.round(diggers[t].money)}`, this.body.x + 260, this.body.y - 330 + (t * 20))

                                    canvas_context.font = "20px arial"
                                    canvas_context.fillStyle = diggers[t].body.color
                                    canvas_context.fillText(`$ ${Math.round(diggers[t].money)}`, this.body.x + 260, this.body.y - 330 + (t * 20))
                                }
                            }
                        }
                    }

                    class Grid {
                        constructor() {
                            this.grid = []
                            this.shape = new Shape([])
                            this.shapes = []
                            this.counter = 0
                            this.rands = rands
                            for (let t = 0; t < 100; t++) {
                                this.grid.push([])
                                for (let k = 400; k < 24000; k += 50) {
                                    this.counter++
                                        this.counter %= 49999
                                    let block = new Circle((t * 50) - 2000, k, 40, getRandomColor())
                                    block.k = k
                                    block.t = t
                                    block.r += (this.rands[`${this.counter}`] * (k / 20))

                                    this.counter++
                                        this.counter %= 49999
                                    if (this.rands[`${this.counter}`] < (.04 + (k / 1000000))) {

                                        this.counter++
                                            this.counter %= 49999
                                        block.g += (this.rands[`${this.counter}`] * (k / 20))

                                        this.counter++
                                            this.counter %= 49999
                                    }
                                    block.g += (this.rands[`${this.counter}`] * (k / 100))

                                    this.counter++
                                        this.counter %= 49999
                                    if (this.rands[`${this.counter}`] < (.02 + (k / 1000000))) {

                                        this.counter++
                                            this.counter %= 49999
                                        block.b += (this.rands[`${this.counter}`] * (k / 20))
                                        this.counter++
                                            this.counter %= 49999
                                    }
                                    block.b += (this.rands[`${this.counter}`] * (k / 180))

                                    this.counter++
                                        this.counter %= 49999
                                    this.grid[t].push(block)
                                }
                            }
                        }
                        clean() {
                            for (let t = 0; t < this.grid.length; t++) {
                                for (let k = 0; k < this.grid[t].length; k++) {
                                    if (this.grid[t][k].marked == 1) {
                                        this.grid[t].splice(k, 1)
                                    }
                                }
                            }
                        }
                        draw() {
                            if(booter.listener.clear == 1){
                                booter.listener.clear = 0
                                
                                console.log("clearing")

                            this.grid = []
                            this.shape = new Shape([])
                            this.shapes = []
                            this.counter = 0
                            this.rands = rands
                            for (let t = 0; t < 100; t++) {
                                this.grid.push([])
                                for (let k = 400; k < 24000; k += 50) {
                                    this.counter++
                                        this.counter %= 49999
                                    let block = new Circle((t * 50) - 2000, k, 40, getRandomColor())
                                    block.k = k
                                    block.t = t
                                    block.r += (this.rands[`${this.counter}`] * (k / 20))

                                    this.counter++
                                        this.counter %= 49999
                                    if (this.rands[`${this.counter}`] < (.04 + (k / 1000000))) {

                                        this.counter++
                                            this.counter %= 49999
                                        block.g += (this.rands[`${this.counter}`] * (k / 20))

                                        this.counter++
                                            this.counter %= 49999
                                    }
                                    block.g += (this.rands[`${this.counter}`] * (k / 100))

                                    this.counter++
                                        this.counter %= 49999
                                    if (this.rands[`${this.counter}`] < (.02 + (k / 1000000))) {

                                        this.counter++
                                            this.counter %= 49999
                                        block.b += (this.rands[`${this.counter}`] * (k / 20))
                                        this.counter++
                                            this.counter %= 49999
                                    }
                                    block.b += (this.rands[`${this.counter}`] * (k / 180))

                                    this.counter++
                                        this.counter %= 49999
                                    this.grid[t].push(block)
                                }
                            }


                            }
                            // this.shapes = []
                            for (let t = 0; t < this.grid.length; t++) {
                                for (let k = 0; k < this.grid[t].length; k++) {
                                    let line = new LineOP(this.grid[t][k], diggers[0].body)
                                    if (line.hypotenuse() < 600) {
                                        this.grid[t][k].draw()
                                    }
                                }
                                // this.shapes.push(new Shape(this.grid[t]))
                            }




                            // this.shape = new Shape(this.shapes)

                        }

                    }

                    let diggers = []
                    let world = new Grid()
                    diggers[0] = new Digger()
                    let fueldepot = new Rectangle(-1000000250, 250, 100, 100, "white")
                    let selldepot = new Rectangle(-10000, -10000, 200000, 200000, "white")
                    let upgradedepot = new Rectangle(-10000000, 0, 0, 0, "white")
                    let particles = []



                    DigSocketize(ws)

                    function DigSocketize(ws) {

                        // console.log("0hit")

                        // console.log("hit")
                        ws.addEventListener("message", ({
                            data
                        }) => {


                            if (JSON.parse(data).splicer >= 0) {



                                // for(let t = 0;t<world.grid.length;t++){
                                for (let k = 0; k < world.grid[JSON.parse(data).t].length; k++) {
                                    if (JSON.parse(data).t == world.grid[JSON.parse(data).t][k].t) {
                                        if (JSON.parse(data).k == world.grid[JSON.parse(data).t][k].k) {
                                            world.grid[JSON.parse(data).t][k].x = JSON.parse(data).x
                                            world.grid[JSON.parse(data).t][k].y = JSON.parse(data).y
                                        }
                                    }
                                }
                                // }


                                // world.grid[JSON.parse(data).t][JSON.parse(data).k].marked = 1

                            } else if (JSON.parse(data).diggers >= 0) {

                                // console.log("hit")

                                if (diggerIds.includes(JSON.parse(data).id)) {
                                    diggers[diggerIds.indexOf(JSON.parse(data).id)] = new Digger(JSON.parse(data))
                                } else {
                                    diggerIds.push(JSON.parse(data).id)
                                    diggers[diggerIds.length - 1] = new Digger(JSON.parse(data))
                                }

                            } else {





                                if (booter.running == 0) {
                                    return
                                }
                                textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)
                                textcanvas_context.font = "12px arial"
                                textcanvas_context.fillStyle = JSON.parse(data).color
                                if (typeof JSON.parse(data).name != "undefined") {


                                    let ypointer = 300 + textscroll
                                    let stoarr = (`(${JSON.parse(data).name}) ` + ' ' + JSON.parse(data).text).split('')
                                    let stostring = ''
                                    for (let t = 0; t < stoarr.length; t++) {
                                        const width = textcanvas_context.measureText(stostring + '' + stoarr[t]).width
                                        if (width > textcanvas.width - 12) {
                                            textcanvas_context.fillText(stostring + '' + stoarr[t], 0, ypointer)
                                            ypointer += 12
                                            textscroll += 12
                                            stostring = ''
                                        } else {
                                            stostring = stostring + "" + stoarr[t]
                                            if (t == stoarr.length - 1) {

                                                textscroll += 12
                                                textcanvas_context.fillText(stostring, 0, ypointer)
                                            }
                                        }
                                    }


                                    // textcanvas_context.fillText(`(${JSON.parse(data).name}) `+ JSON.parse(data).text, 0, 300+textscroll)


                                    console.log(JSON.parse(data).measure)
                                        // textscroll += JSON.parse(data).measure
                                }
                                // textcanvas_context.translate(0, 12)
                                // textcanvas.translate(0, 12)
                            }
                        })

                        // let json = {}
                        // json.connecting = 1

                        // ws.send(JSON.stringify(json))
                        // })

                    }

                    function main() {
                        if (booter.running == 0) {
                            return
                        }
                        canvas_context.fillStyle = "#AAAAAA"
                        canvas_context.fillRect(-10000, -10000, canvas.width * 1000, canvas.height * 1000) // refreshes the image
                        world.draw()
                        world.clean()
                            // fueldepot.draw()
                            // selldepot.draw()
                            // upgradedepot.draw()
                            // canvas_context.fillStyle = "white"
                            // canvas_context.fillText("fuel", 280, 280)
                            // canvas_context.fillText("sell", 480, 280)
                            // canvas_context.fillText("upgrade", 660, 280)
                        if (fueldepot.doesPerimeterTouch(diggers[0].body)) {
                            if (diggers[0].money >= (diggers[0].maxfuel - diggers[0].fuel)) {
                                diggers[0].money -= (diggers[0].maxfuel - diggers[0].fuel)
                                diggers[0].fuel = diggers[0].maxfuel
                            } else {
                                diggers[0].fuel += diggers[0].money
                                diggers[0].money = 0
                            }
                        }
                        if (selldepot.doesPerimeterTouch(diggers[0].body)) {
                            diggers[0].money += diggers[0].red / 100
                            diggers[0].money += diggers[0].green / 10
                            diggers[0].money += diggers[0].blue
                            diggers[0].green = 0
                            diggers[0].red = 0
                            diggers[0].blue = 0
                        }
                        if (upgradedepot.doesPerimeterTouch(diggers[0].body)) {
                            if (diggers[0].maxfuel < 10000) {
                                for (let t = 0; diggers[0].money > 100; diggers[0].money -= 100) {
                                    if (diggers[0].maxfuel < 5000) {
                                        diggers[0].maxfuel *= 1.025
                                        diggers[0].redrate *= 1.025
                                        diggers[0].greenrate *= 1.025
                                        diggers[0].bluerate *= 1.025
                                    } else {
                                        break
                                    }
                                }
                            }
                        }
                        for (let t = 0; t < diggers.length; t++) {

                            if (t == 0) {
                                if (ws.readyState == 1) {
                                    let json = {}
                                    json.diggers = 1
                                    json.x = diggers[0].body.x
                                    json.color = namer
                                    json.id = diggers[0].id
                                    json.money = diggers[0].money
                                    json.y = diggers[0].body.y
                                    json.angle = diggers[0].angle
                                    ws.send(JSON.stringify(json))
                                }
                            }
                            if (typeof diggers[t] != 'undefined') {
                                diggers[t].draw()
                            }
                        }
                        if (diggers[0].fuel > 0) {
                            control(diggers[0], 5)
                        }
                        for (let t = 0; t < particles.length; t++) {
                            particles[t].move()
                            particles[t].draw()
                            particles[t].height -= .1
                            particles[t].width -= .1
                        }
                        for (let t = 0; t < particles.length; t++) {
                            if (particles[t].height <= 0) {
                                particles.splice(t, 1)
                            } else if (particles[t].width <= 0) {
                                particles.splice(t, 1)
                            }

                        }
                    }




                } else if (booter.index == 3) {
                    booter.running = 1





                    const gamepadAPI = {
                        controller: {},
                        turbo: true,
                        connect: function(evt) {
                            if (navigator.getGamepads()[0] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[1] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[2] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[3] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            }
                            for (let i = 0; i < gamepads.length; i++) {
                                if (gamepads[i] === null) {
                                    continue;
                                }
                                if (!gamepads[i].connected) {
                                    continue;
                                }
                            }
                        },
                        disconnect: function(evt) {
                            gamepadAPI.turbo = false;
                            delete gamepadAPI.controller;
                        },
                        update: function() {
                            gamepadAPI.controller = navigator.getGamepads()[0]
                            gamepadAPI.buttonsCache = []; // clear the buttons cache
                            for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) { // move the buttons status from the previous frame to the cache
                                gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
                            }
                            gamepadAPI.buttonsStatus = []; // clear the buttons status
                            var c = gamepadAPI.controller || {}; // get the gamepad object
                            var pressed = [];
                            if (c.buttons) {
                                for (var b = 0, t = c.buttons.length; b < t; b++) { // loop through buttons and push the pressed ones to the array
                                    if (c.buttons[b].pressed) {
                                        pressed.push(gamepadAPI.buttons[b]);
                                    }
                                }
                            }
                            var axes = [];
                            if (c.axes) {
                                for (var a = 0, x = c.axes.length; a < x; a++) { // loop through axes and push their values to the array
                                    axes.push(c.axes[a].toFixed(2));
                                }
                            }
                            gamepadAPI.axesStatus = axes; // assign received values
                            gamepadAPI.buttonsStatus = pressed;
                            // console.log(pressed); // return buttons for debugging purposes
                            return pressed;
                        },
                        buttonPressed: function(button, hold) {
                            var newPress = false;
                            for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) { // loop through pressed buttons
                                if (gamepadAPI.buttonsStatus[i] == button) { // if we found the button we're looking for...
                                    newPress = true; // set the boolean variable to true
                                    if (!hold) { // if we want to check the single press
                                        for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) { // loop through the cached states from the previous frame
                                            if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                                newPress = false;
                                            }
                                        }
                                    }
                                }
                            }
                            return newPress;
                        },
                        buttons: [
                            'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
                        ],
                        buttonsCache: [],
                        buttonsStatus: [],
                        axesStatus: []
                    };
                    let canvas
                    let canvas_context
                    let keysPressed = {}
                    let FLEX_engine
                    let TIP_engine = {}
                    let XS_engine
                    let YS_engine
                    TIP_engine.x = 350
                    TIP_engine.y = 350
                    class Point {
                        constructor(x, y) {
                            this.x = x
                            this.y = y
                            this.radius = 0
                        }
                        pointDistance(point) {
                            return (new LineOP(this, point, "transparent", 0)).hypotenuse()
                        }
                    }

                    class Vector { // vector math and physics if you prefer this over vector components on circles
                        constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
                            this.xmom = xmom
                            this.ymom = ymom
                            this.object = object
                        }
                        isToward(point) {
                            let link = new LineOP(this.object, point)
                            let dis1 = link.sqrDis()
                            let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                            let link2 = new LineOP(dummy, point)
                            let dis2 = link2.sqrDis()
                            if (dis2 < dis1) {
                                return true
                            } else {
                                return false
                            }
                        }
                        rotate(angleGoal) {
                            let link = new Line(this.xmom, this.ymom, 0, 0)
                            let length = link.hypotenuse()
                            let x = (length * Math.cos(angleGoal))
                            let y = (length * Math.sin(angleGoal))
                            this.xmom = x
                            this.ymom = y
                        }
                        magnitude() {
                            return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
                        }
                        normalize(size = 1) {
                            let magnitude = this.magnitude()
                            this.xmom /= magnitude
                            this.ymom /= magnitude
                            this.xmom *= size
                            this.ymom *= size
                        }
                        multiply(vect) {
                            let point = new Point(0, 0)
                            let end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
                            return point.pointDistance(end)
                        }
                        add(vect) {
                            return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
                        }
                        subtract(vect) {
                            return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
                        }
                        divide(vect) {
                            return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
                        }
                        draw() {
                            let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                            let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
                            link.draw()
                        }
                    }
                    class Line {
                        constructor(x, y, x2, y2, color, width) {
                            this.x1 = x
                            this.y1 = y
                            this.x2 = x2
                            this.y2 = y2
                            this.color = color
                            this.width = width
                        }
                        angle() {
                            return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
                        }
                        squareDistance() {
                            let xdif = this.x1 - this.x2
                            let ydif = this.y1 - this.y2
                            let squareDistance = (xdif * xdif) + (ydif * ydif)
                            return squareDistance
                        }
                        hypotenuse() {
                            let xdif = this.x1 - this.x2
                            let ydif = this.y1 - this.y2
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x1, this.y1)
                            canvas_context.lineTo(this.x2, this.y2)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class LineOP {
                        constructor(object, target, color, width) {
                            this.object = object
                            this.target = target
                            this.color = color
                            this.width = width
                        }
                        squareDistance() {
                            let xdif = this.object.x - this.target.x
                            let ydif = this.object.y - this.target.y
                            let squareDistance = (xdif * xdif) + (ydif * ydif)
                            return squareDistance
                        }
                        hypotenuse() {
                            let xdif = this.object.x - this.target.x
                            let ydif = this.object.y - this.target.y
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                        }
                        angle() {
                            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.object.x, this.object.y)
                            canvas_context.lineTo(this.target.x, this.target.y)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class Triangle {
                        constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
                            this.x = x
                            this.y = y
                            this.color = color
                            this.length = length
                            this.x1 = this.x + this.length * leg1Ratio
                            this.x2 = this.x - this.length * leg2Ratio
                            this.tip = this.y - this.length * heightRatio
                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                            this.fill = fill
                            this.stroke = strokeWidth
                        }
                        draw() {
                            canvas_context.strokeStyle = this.color
                            canvas_context.stokeWidth = this.stroke
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x, this.y)
                            canvas_context.lineTo(this.x1, this.y)
                            canvas_context.lineTo(this.x, this.tip)
                            canvas_context.lineTo(this.x2, this.y)
                            canvas_context.lineTo(this.x, this.y)
                            if (this.fill == 1) {
                                canvas_context.fill()
                            }
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                        isPointInside(point) {
                            if (point.x <= this.x1) {
                                if (point.y >= this.tip) {
                                    if (point.y <= this.y) {
                                        if (point.x >= this.x2) {
                                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                                            this.basey = point.y - this.tip
                                            this.basex = point.x - this.x
                                            if (this.basex == 0) {
                                                return true
                                            }
                                            this.slope = this.basey / this.basex
                                            if (this.slope >= this.accept1) {
                                                return true
                                            } else if (this.slope <= this.accept2) {
                                                return true
                                            }
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Rectangle {
                        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
                            this.x = x
                            this.y = y
                            this.height = height
                            this.width = width
                            this.color = color
                            this.xmom = 0
                            this.ymom = 0
                            this.stroke = stroke
                            this.strokeWidth = strokeWidth
                            this.fill = fill
                        }
                        draw() {
                            canvas_context.fillStyle = this.color
                            canvas_context.fillRect(this.x, this.y, this.width, this.height)
                        }
                        move() {
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        isPointInside(point) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        if (point.y <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y + point.radius >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Circle {
                        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent", args = 0) {
                            if (args == 0) {
                                this.x = x
                                this.y = y
                                this.radius = radius
                                this.color = color
                                this.xmom = xmom
                                this.ymom = ymom
                                this.friction = friction
                                this.reflect = reflect
                                this.strokeWidth = strokeWidth
                                this.strokeColor = strokeColor
                                this.id = racersId

                            } else {

                                this.id = args.id
                                this.x = args.x
                                this.y = args.y
                                this.radius = args.radius
                                this.color = args.color
                                this.xmom = args.xmom
                                this.ymom = args.ymom
                                this.friction = args.friction
                                this.reflect = args.reflect
                                this.strokeWidth = args.strokeWidth
                                this.strokeColor = args.strokeColor

                            }
                        }
                        draw() {

                            if (this.radius > 30) {
                                this.small = new Circle(this.x, this.y, 20, "white")
                            }
                            canvas_context.lineWidth = this.strokeWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath();
                            if (this.radius > 0) {
                                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)

                                if (racers.includes(this)) {
                                    canvas_context.strokeStyle = "black"

                                    canvas_context.lineWidth = 4
                                    canvas_context.stroke();
                                }
                                canvas_context.fillStyle = this.color
                                canvas_context.fill()
                                canvas_context.stroke();
                            } else {
                                // console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)

                                //uh the one wirth lapjam
                            }
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            if (this == racers[0]) {
                                canvas_context.translate(-this.xmom, -this.ymom)
                            }
                        }
                        unmove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x -= this.xmom
                            this.y -= this.ymom

                            if (this == racers[0]) {
                                canvas_context.translate(this.xmom, this.ymom)
                            }
                        }
                        frictiveMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom

                            if (this == racers[0]) {
                                canvas_context.translate(-this.xmom, -this.ymom)
                            }
                            this.xmom *= this.friction
                            this.ymom *= this.friction

                        }
                        frictiveunMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.xmom /= this.friction
                            this.ymom /= this.friction
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        isPointInside(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                                return true
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                                return true
                            }
                            return false
                        }
                    }
                    class CircleRing {
                        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                            this.x = x
                            this.y = y
                            this.radius = radius
                            this.color = color
                            this.xmom = xmom
                            this.ymom = ymom
                            this.friction = friction
                            this.reflect = reflect
                            this.strokeWidth = 10
                            this.strokeColor = strokeColor
                        }
                        draw() {
                            canvas_context.lineWidth = this.strokeWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath();
                            if (this.radius > 0) {
                                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                                canvas_context.fillStyle = this.color
                                canvas_context.fill()
                                canvas_context.stroke();
                            } else {
                                console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                            }
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        unmove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        frictiveMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            this.xmom *= this.friction
                            this.ymom *= this.friction
                        }
                        frictiveunMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.xmom /= this.friction
                            this.ymom /= this.friction
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        isPointInside(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                                return true
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                                return true
                            }
                            return false
                        }
                    }
                    class Polygon {
                        constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
                            if (sides < 2) {
                                sides = 2
                            }
                            this.reflect = reflect
                            this.xmom = xmom
                            this.ymom = ymom
                            this.body = new Circle(x, y, size - (size * .293), "transparent")
                            this.nodes = []
                            this.angle = angle
                            this.size = size
                            this.color = color
                            this.angleIncrement = (Math.PI * 2) / sides
                            this.sides = sides
                            for (let t = 0; t < sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                        }
                        isPointInside(point) { // rough approximation
                            this.body.radius = this.size - (this.size * .293)
                            if (this.sides <= 2) {
                                return false
                            }
                            this.areaY = point.y - this.body.y
                            this.areaX = point.x - this.body.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                                return true
                            }
                            return false
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.body.x > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.body.x < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.body.x += this.xmom
                            this.body.y += this.ymom
                        }
                        draw() {
                            this.nodes = []
                            this.angleIncrement = (Math.PI * 2) / this.sides
                            this.body.radius = this.size - (this.size * .293)
                            for (let t = 0; t < this.sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                            canvas_context.strokeStyle = this.color
                            canvas_context.fillStyle = this.color
                            canvas_context.lineWidth = 0
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
                            for (let t = 1; t < this.nodes.length; t++) {
                                canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
                            }
                            canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
                            canvas_context.fill()
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                    }
                    class Shape {
                        constructor(shapes) {
                            this.shapes = shapes
                        }
                        draw() {
                            for (let t = 0; t < this.shapes.length; t++) {
                                this.shapes[t].draw()
                            }
                        }
                        isPointInside(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].isPointInside(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].doesPerimeterTouch(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        innerShape(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].doesPerimeterTouch(point)) {
                                    return this.shapes[t]
                                }
                            }
                            return false
                        }
                        isInsideOf(box) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (box.isPointInside(this.shapes[t])) {
                                    return true
                                }
                            }
                            return false
                        }
                        adjustByFromDisplacement(x, y) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (typeof this.shapes[t].fromRatio == "number") {
                                    this.shapes[t].x += x * this.shapes[t].fromRatio
                                    this.shapes[t].y += y * this.shapes[t].fromRatio
                                }
                            }
                        }
                        adjustByToDisplacement(x, y) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (typeof this.shapes[t].toRatio == "number") {
                                    this.shapes[t].x += x * this.shapes[t].toRatio
                                    this.shapes[t].y += y * this.shapes[t].toRatio
                                }
                            }
                        }
                        mixIn(arr) {
                            for (let t = 0; t < arr.length; t++) {
                                for (let k = 0; k < arr[t].shapes.length; k++) {
                                    this.shapes.push(arr[t].shapes[k])
                                }
                            }
                        }
                        push(object) {
                            this.shapes.push(object)
                        }
                    }

                    class Spring {
                        constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
                            if (body == 0) {
                                this.body = new Circle(x, y, radius, color)
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            } else {
                                this.body = body
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            }
                            this.gravity = gravity
                            this.width = width
                        }
                        balance() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            if (this.beam.hypotenuse() < this.length) {
                                this.body.xmom += (this.body.x - this.anchor.x) / this.length
                                this.body.ymom += (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
                            } else {
                                this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
                            }
                            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
                        }
                        draw() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            this.beam.draw()
                            this.body.draw()
                            this.anchor.draw()
                        }
                        move() {
                            this.anchor.ymom += this.gravity
                            this.anchor.move()
                        }

                    }
                    class SpringOP {
                        constructor(body, anchor, length, width = 3, color = body.color) {
                            this.body = body
                            this.anchor = anchor
                            this.beam = new LineOP(body, anchor, color, width)
                            this.length = length
                        }
                        balance() {
                            if (this.beam.hypotenuse() < this.length) {
                                this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
                                this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
                                this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
                                this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
                            } else if (this.beam.hypotenuse() > this.length) {
                                this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
                                this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
                                this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
                                this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
                            }

                            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
                        }
                        draw() {
                            this.beam.draw()
                        }
                        move() {
                            //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
                        }
                    }

                    class Color {
                        constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
                            this.hue = baseColor
                            if (red != -1 && green != -1 && blue != -1) {
                                this.r = red
                                this.g = green
                                this.b = blue
                                if (alpha != 1) {
                                    if (alpha < 1) {
                                        this.alpha = alpha
                                    } else {
                                        this.alpha = alpha / 255
                                        if (this.alpha > 1) {
                                            this.alpha = 1
                                        }
                                    }
                                }
                                if (this.r > 255) {
                                    this.r = 255
                                }
                                if (this.g > 255) {
                                    this.g = 255
                                }
                                if (this.b > 255) {
                                    this.b = 255
                                }
                                if (this.r < 0) {
                                    this.r = 0
                                }
                                if (this.g < 0) {
                                    this.g = 0
                                }
                                if (this.b < 0) {
                                    this.b = 0
                                }
                            } else {
                                this.r = 0
                                this.g = 0
                                this.b = 0
                            }
                        }
                        normalize() {
                            if (this.r > 255) {
                                this.r = 255
                            }
                            if (this.g > 255) {
                                this.g = 255
                            }
                            if (this.b > 255) {
                                this.b = 255
                            }
                            if (this.r < 0) {
                                this.r = 0
                            }
                            if (this.g < 0) {
                                this.g = 0
                            }
                            if (this.b < 0) {
                                this.b = 0
                            }
                        }
                        randomLight() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12) + 4)];
                            }
                            var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
                            return color;
                        }
                        randomDark() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12))];
                            }
                            var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
                            return color;
                        }
                        random() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 16))];
                            }
                            var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
                            return color;
                        }
                    }
                    class Softbody { //buggy, spins in place
                        constructor(x, y, radius, color, size, members = 10, memberLength = 5, force = 10, gravity = 0) {
                            this.springs = []
                            this.pin = new Circle(x, y, radius, color)
                            this.points = []
                            this.flop = 0
                            let angle = 0
                            this.size = size
                            let line = new Line((Math.cos(angle) * size), (Math.sin(angle) * size), (Math.cos(angle + ((Math.PI * 2) / members)) * size), (Math.sin(angle + ((Math.PI * 2) / members)) * size))
                            let distance = line.hypotenuse()
                            for (let t = 0; t < members; t++) {
                                let circ = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), radius, color)
                                circ.reflect = 1
                                circ.bigbody = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), distance, color)
                                circ.draw()
                                circ.touch = []
                                this.points.push(circ)
                                angle += ((Math.PI * 2) / members)
                            }

                            for (let t = 0; t < this.points.length; t++) {
                                for (let k = 0; k < this.points.length; k++) {
                                    if (t != k) {
                                        if (this.points[k].bigbody.doesPerimeterTouch(this.points[t])) {
                                            if (!this.points[k].touch.includes(t) && !this.points[t].touch.includes(k)) {
                                                let spring = new SpringOP(this.points[k], this.points[t], (size * Math.PI) / members, 2, color)
                                                this.points[k].touch.push(t)
                                                this.points[t].touch.push(k)
                                                this.springs.push(spring)
                                                spring.beam.draw()
                                            }
                                        }
                                    }
                                }
                            }

                            console.log(this)

                            // this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
                            // this.springs.push(this.spring)
                            // for (let k = 0; k < members; k++) {
                            //     this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
                            //     if (k < members - 1) {
                            //         this.springs.push(this.spring)
                            //     } else {
                            //         this.spring.anchor = this.pin
                            //         this.springs.push(this.spring)
                            //     }
                            // }
                            this.forceConstant = force
                            this.centroid = new Circle(0, 0, 10, "red")
                        }
                        circularize() {
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.springs.length; s++) {
                                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                            this.angle = 0
                            this.angleIncrement = (Math.PI * 2) / this.springs.length
                            for (let t = 0; t < this.points.length; t++) {
                                this.points[t].x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                                this.points[t].y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                                this.angle += this.angleIncrement
                            }
                        }
                        balance() {
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.points.length; s++) {
                                this.xpoint += (this.points[s].x / this.points.length)
                                this.ypoint += (this.points[s].y / this.points.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                                // this.centroid.x += TIP_engine.x / this.points.length
                                // this.centroid.y += TIP_engine.y / this.points.length
                            for (let s = 0; s < this.points.length; s++) {
                                this.link = new LineOP(this.points[s], this.centroid, 0, "transparent")
                                if (this.link.hypotenuse() != 0) {

                                    if (this.size < this.link.hypotenuse()) {
                                        this.points[s].xmom -= (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                        this.points[s].ymom -= (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                    } else {
                                        this.points[s].xmom += (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                        this.points[s].ymom += (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                    }

                                    // this.points[s].xmom += (((this.points[s].x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                                    // this.points[s].ymom += (((this.points[s].y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                                }
                            }
                            if (this.flop % 2 == 0) {
                                for (let s = 0; s < this.springs.length; s++) {
                                    this.springs[s].balance()
                                }
                            } else {
                                for (let s = this.springs.length - 1; s >= 0; s--) {
                                    this.springs[s].balance()
                                }
                            }
                            for (let s = 0; s < this.points.length; s++) {
                                this.points[s].move()
                                this.points[s].draw()
                            }
                            for (let s = 0; s < this.springs.length; s++) {
                                this.springs[s].draw()
                            }
                            this.centroid.draw()
                        }
                    }
                    class Observer {
                        constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
                            this.body = new Circle(x, y, radius, color)
                            this.color = color
                            this.ray = []
                            this.rayrange = range
                            this.globalangle = Math.PI
                            this.gapangle = angle
                            this.currentangle = 0
                            this.obstacles = []
                            this.raymake = rays
                        }
                        beam() {
                            this.currentangle = this.gapangle / 2
                            for (let k = 0; k < this.raymake; k++) {
                                this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                                let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                                ray.collided = 0
                                ray.lifespan = this.rayrange - 1
                                this.ray.push(ray)
                            }
                            for (let f = 0; f < this.rayrange; f++) {
                                for (let t = 0; t < this.ray.length; t++) {
                                    if (this.ray[t].collided < 1) {
                                        this.ray[t].move()
                                        for (let q = 0; q < this.obstacles.length; q++) {
                                            if (this.obstacles[q].isPointInside(this.ray[t])) {
                                                this.ray[t].collided = 1
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        draw() {
                            this.beam()
                            this.body.draw()
                            canvas_context.lineWidth = 1
                            canvas_context.fillStyle = this.color
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.body.x, this.body.y)
                            for (let y = 0; y < this.ray.length; y++) {
                                canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                                canvas_context.lineTo(this.body.x, this.body.y)
                            }
                            canvas_context.stroke()
                            canvas_context.fill()
                            this.ray = []
                        }
                    }

                    function setUp(canvas_pass, style = "#000000") {
                        canvas = canvas_pass
                        canvas_context = canvas.getContext('2d');
                        canvas.style.background = style
                        booter.main = main
                        document.addEventListener('keydown', (event) => {
                            keysPressed[event.key] = true;
                        });
                        document.addEventListener('keyup', (event) => {
                            delete keysPressed[event.key];
                        });
                        window.addEventListener('pointerdown', e => {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            TIP_engine.x = XS_engine
                            TIP_engine.y = YS_engine
                            TIP_engine.body = TIP_engine
                                // example usage: if(object.isPointInside(TIP_engine)){ take action }
                        });
                        window.addEventListener('pointermove', continued_stimuli);

                        window.addEventListener('pointerup', e => {
                            // window.removeEventListener("pointermove", continued_stimuli);
                        })

                        function continued_stimuli(e) {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            TIP_engine.x = XS_engine
                            TIP_engine.y = YS_engine
                            TIP_engine.body = TIP_engine
                        }
                    }

                    function gamepad_control(object, speed = 1) { // basic control for objects using the controler
                        //         console.log(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
                        if (typeof object.body != 'undefined') {
                            if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                                if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                                    object.body.x += (gamepadAPI.axesStatus[0] * speed)
                                    object.body.y += (gamepadAPI.axesStatus[1] * speed)
                                }
                            }
                        } else if (typeof object != 'undefined') {
                            if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                                if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                                    object.x += (gamepadAPI.axesStatus[0] * speed)
                                    object.y += (gamepadAPI.axesStatus[1] * speed)
                                }
                            }
                        }
                    }

                    function control(object, speed = 1) { // basic control for objects
                        if (typeof object.body != 'undefined') {
                            if (keysPressed['w']) {
                                object.body.ymom -= speed
                            }
                            if (keysPressed['d']) {
                                object.body.xmom += speed
                            }
                            if (keysPressed['s']) {
                                object.body.ymom += speed
                            }
                            if (keysPressed['a']) {
                                object.body.xmom -= speed
                            }
                        } else if (typeof object != 'undefined') {
                            if (keysPressed['w']) {
                                object.ymom -= speed
                            }
                            if (keysPressed['d']) {
                                object.xmom += speed
                            }
                            if (keysPressed['s']) {
                                object.ymom += speed
                            }
                            if (keysPressed['a']) {
                                object.xmom -= speed
                            }
                        }
                    }

                    function getRandomLightColor() { // random color that will be visible on  black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12) + 4)];
                        }
                        return color;
                    }

                    function getRandomColor() { // random color
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 16) + 0)];
                        }
                        return color;
                    }

                    function getRandomDarkColor() { // color that will be visible on a black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12))];
                        }
                        return color;
                    }

                    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
                        let limit = granularity
                        let shape_array = []
                        for (let t = 0; t < limit; t++) {
                            let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                            circ.toRatio = t / limit
                            circ.fromRatio = (limit - t) / limit
                            shape_array.push(circ)
                        }
                        return (new Shape(shape_array))
                    }

                    let setup_canvas = document.createElement('CANVAS') //getting canvas from document
                    setup_canvas.width = 700
                    setup_canvas.height = 700
                    setup_canvas.hidden = 1
                    setUp(setup_canvas) // setting up canvas refrences, starting timer. 

                    // object instantiation and creation happens here 

                    let racers = []

                    let racer = new Circle(350, 350, 5, "#FFFFFF", 0, 0, .979)
                    racers.push(racer)



                    RaceSocketize(ws)

                    function RaceSocketize(ws) {

                        // console.log("0hit")

                        // console.log("hit")
                        ws.addEventListener("message", ({
                            data
                        }) => {

                            if (JSON.parse(data).race >= 0) {

                                // console.log("hit")
                                if (JSON.parse(data).tile >= 0) {
                                    for (let t = 0; t < rainbow.bodies.length; t++) {
                                        rainbow.bodies[t].radius *= .985
                                    }
                                    rainbow.bodies.push(new Circle(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, JSON.parse(data)))
                                    rainbow.index++
                                } else {
                                    if (racersIds.includes(JSON.parse(data).id)) {
                                        racers[racersIds.indexOf(JSON.parse(data).id)] = new Circle(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, JSON.parse(data))
                                    } else {
                                        racersIds.push(JSON.parse(data).id)
                                        racers[racersIds.indexOf(JSON.parse(data).id)] = new Circle(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, JSON.parse(data))
                                    }
                                }

                            } else {


                                if (booter.running == 0) {
                                    return
                                }

                                textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)
                                textcanvas_context.font = "12px arial"
                                textcanvas_context.fillStyle = JSON.parse(data).color
                                if (typeof JSON.parse(data).name != "undefined") {


                                    let ypointer = 300 + textscroll
                                    let stoarr = (`(${JSON.parse(data).name}) ` + ' ' + JSON.parse(data).text).split('')
                                    let stostring = ''
                                    for (let t = 0; t < stoarr.length; t++) {
                                        const width = textcanvas_context.measureText(stostring + '' + stoarr[t]).width
                                        if (width > textcanvas.width - 12) {
                                            textcanvas_context.fillText(stostring + '' + stoarr[t], 0, ypointer)
                                            ypointer += 12
                                            textscroll += 12
                                            stostring = ''
                                        } else {
                                            stostring = stostring + "" + stoarr[t]
                                            if (t == stoarr.length - 1) {

                                                textscroll += 12
                                                textcanvas_context.fillText(stostring, 0, ypointer)
                                            }
                                        }
                                    }


                                    // textcanvas_context.fillText(`(${JSON.parse(data).name}) `+ JSON.parse(data).text, 0, 300+textscroll)

                                    console.log(JSON.parse(data).measure)
                                        // textscroll += JSON.parse(data).measure
                                }
                                // textcanvas_context.translate(0, 12)
                                // textcanvas.translate(0, 12)
                            }
                        })

                        // let json = {}
                        // json.connecting = 1

                        // ws.send(JSON.stringify(json))
                        // })

                    }

                    class Rainbow {
                        constructor() {
                            this.center = new Point(350, 350)
                            this.index = -1
                            this.dis = 100
                            this.angle = 0
                            this.colors = ["Red", "orange", "yellow", "#00ff00", "Cyan", "Blue", "purple"]
                            this.bodies = []
                            for (let t = 0; t < 106; t++) {
                                this.bodies.push(new Circle(this.center.x + (Math.cos(this.angle) * this.dis), this.center.y + (Math.sin(this.angle) * this.dis), 65, this.colors[this.index % 6]))
                                this.angle += .06
                                this.index++
                                    this.dis += 5
                            }
                        }
                        draw() {
                            let wet = 0
                            let wetx = 0


                            let maxer = racers[0]


                            for (let k = 0; k < racers.length; k++) {
                                for (let t = Math.max(this.index - 105, 0) + 104; t > Math.max(this.index - 105, 0); t--) {
                                    if (this.bodies[t].doesPerimeterTouch(racers[k])) {
                                        // maxer = racers[k]

                                        racers[k].touched = this.bodies[t]
                                        break
                                    }
                                }
                            }
                            for (let t = Math.max(this.index - 105, 0); t < Math.max(this.index - 105, 0) + 105; t++) {
                                if (typeof this.bodies[t] != "undefined") {
                                    this.bodies[t].draw()

                                    if (maxer.doesPerimeterTouch(this.bodies[t])) {
                                        wetx = 1
                                    }
                                    if (racers[0].doesPerimeterTouch(this.bodies[t])) {
                                        wet = 1
                                    }
                                }
                            }

                            let j = 0
                            let trap = 0
                            if (wetx == 0) {
                                this.index++
                                    this.angle += .125
                                this.dis += .3 // (Math.random()-.45)*15
                                if (this.dis > 300) {
                                    this.dis = 300
                                }
                                if (this.dis < 50) {
                                    this.dis = 50
                                }
                                // this.bodies.push(new Circle(this.center.x+(Math.cos(this.angle)*this.dis),  this.center.y+(Math.sin(this.angle)*this.dis), 45, this.colors[this.index%6] ))


                                let circl = new Circle((this.bodies[this.bodies.length - 1].x * .97) + (maxer.x * .03) + (maxer.xmom * 2.5), (this.bodies[this.bodies.length - 1].y * .97) + (maxer.y * .03) + (maxer.ymom * 2.5), 65, this.colors[this.index % 6])
                                this.bodies.push(circl)


                                let circlson = {}


                                circlson.tile = 1

                                circlson.race = 1
                                circlson.id = circl.id
                                circlson.x = circl.x
                                circlson.y = circl.y
                                circlson.radius = circl.radius
                                circlson.color = circl.color
                                circlson.xmom = circl.xmom
                                circlson.ymom = circl.ymom
                                circlson.friction = circl.friction
                                circlson.reflect = circl.reflect
                                circlson.strokeWidth = circl.strokeWidth
                                circlson.strokeColor = circl.strokeColor
                                if (racers[0] == maxer) {
                                    ws.send(JSON.stringify(circlson))
                                }

                                for (let t = 0; t < this.bodies.length; t++) {
                                    if (this.bodies.length > 200) {
                                        this.bodies[t].radius *= .985
                                    }
                                }

                                this.bodies[Math.max(this.index - 1, 0)].radius *= 1.5

                                if (maxer.doesPerimeterTouch(this.bodies[Math.max(this.index - 1, 0)])) {
                                    wet = 1
                                }

                                this.bodies[Math.max(this.index - 1, 0)].radius /= 1.5
                            }


                            while (wet == 0) {
                                trap = 1
                                j++
                                if (j > 10000) {
                                    break
                                }
                                for (let t = Math.max(this.index - 105, 0); t < Math.max(this.index - 105, 0) + 104; t++) {

                                    if (typeof this.bodies[t] != "undefined") {
                                        if (racers[0].doesPerimeterTouch(this.bodies[t])) {
                                            wet = 1
                                        }
                                    }
                                }


                                if (j == 1) {

                                    if (this.bodies.indexOf(racers[0].touched) < this.index - 60) {
                                        console.log(racers[0].touched)
                                        canvas_context.translate(racers[0].x - this.bodies[this.index - 60].x, racers[0].y - this.bodies[this.index - 60].y)
                                        racers[0].x = this.bodies[this.index - 60].x
                                        racers[0].y = this.bodies[this.index - 60].y
                                    } else {

                                        canvas_context.translate(racers[0].x - racers[0].touched.x, racers[0].y - racers[0].touched.y)
                                        racers[0].x = racers[0].touched.x
                                        racers[0].y = racers[0].touched.y

                                    }

                                }

                            }

                            if (trap == 1) {
                                racers[0].xmom *= -.7
                                racers[0].ymom *= -.7
                            }
                            // this.bodies[this.index].color = getRandomColor()
                            this.bodies[this.index].draw()
                            this.bodies[this.index].small.draw()


                            for (let k = 0; k < racers.length; k++) {
                                if (!racers[k].doesPerimeterTouch(this.bodies[Math.max(this.index, 0)])) {
                                    if (racers[k].doesPerimeterTouch(this.bodies[Math.max(this.index - 1, 0)])) {
                                        // this.index++
                                        // this.angle += .125
                                        // this.dis += .3 // (Math.random()-.45)*15
                                        // if(this.dis > 300 ){
                                        //     this.dis = 300
                                        // }
                                        // if(this.dis < 50 ){
                                        //     this.dis = 50
                                        // }
                                        // // this.bodies.push(new Circle(this.center.x+(Math.cos(this.angle)*this.dis),  this.center.y+(Math.sin(this.angle)*this.dis), 45, this.colors[this.index%6] ))
                                        // this.bodies.push(new Circle(this.bodies[this.bodies.length-1].x + (racers[0].xmom *3), this.bodies[this.bodies.length-1].y + (racers[0].ymom *3), 45, this.colors[this.index%6] ) )

                                        //     for(let t = 0; t< this.bodies.length;t++ ){
                                        //         this.bodies[t].radius*=.97
                                        //     }   
                                    }
                                }
                            }
                        }
                    }


                    let rainbow = new Rainbow()


                    function main() {
                        canvas_context.clearRect(-1000000, -1000000, canvas.width * 1000000, canvas.height * 1000000) // refreshes the image
                        gamepadAPI.update() //checks for button presses/stick movement on the connected controller)
                            // // game code goes here

                        windowspares[booter.index] = canvas
                        rainbow.draw()
                        control(racers[0], .102)
                        for (let t = 0; t < racers.length; t++) {
                            // if(t == 0 ){
                            racers[t].frictiveMove()
                                // }
                            racers[t].draw()
                        }



                        let json = {}

                        json.race = 1
                        json.id = racers[0].id
                        json.x = racers[0].x
                        json.y = racers[0].y
                        json.radius = racers[0].radius
                        json.color = racers[0].color
                        json.xmom = racers[0].xmom
                        json.ymom = racers[0].ymom
                        json.friction = racers[0].friction
                        json.reflect = racers[0].reflect
                        json.strokeWidth = racers[0].strokeWidth
                        json.strokeColor = racers[0].strokeColor
                        ws.send(JSON.stringify(json))



                    }





                } else if (booter.index == 1) {

                    let canvas
                    let canvas_context
                    let keysPressed = {}
                    let FLEX_engine
                    let TIP_engine = {}
                    let XS_engine
                    let YS_engine
                    class Point {
                        constructor(x, y) {
                            this.x = x
                            this.y = y
                            this.radius = 0
                        }
                        pointDistance(point) {
                            return (new LineOP(this, point, "transparent", 0)).hypotenuse()
                        }
                    }
                    class Line {
                        constructor(x, y, x2, y2, color, width) {
                            this.x1 = x
                            this.y1 = y
                            this.x2 = x2
                            this.y2 = y2
                            this.color = color
                            this.width = width
                        }
                        hypotenuse() {
                            let xdif = this.x1 - this.x2
                            let ydif = this.y1 - this.y2
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x1, this.y1)
                            canvas_context.lineTo(this.x2, this.y2)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class LineOP {
                        constructor(object, target, color, width) {
                            this.object = object
                            this.target = target
                            this.color = color
                            this.width = width
                        }
                        hypotenuse() {
                            let xdif = this.object.x - this.target.x
                            let ydif = this.object.y - this.target.y
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                        }
                        angle() {
                            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.object.x, this.object.y)
                            canvas_context.lineTo(this.target.x, this.target.y)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class Triangle {
                        constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
                            this.x = x
                            this.y = y
                            this.color = color
                            this.length = length
                            this.x1 = this.x + this.length * leg1Ratio
                            this.x2 = this.x - this.length * leg2Ratio
                            this.tip = this.y - this.length * heightRatio
                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                            this.fill = fill
                            this.stroke = strokeWidth
                        }
                        draw() {
                            canvas_context.strokeStyle = this.color
                            canvas_context.stokeWidth = this.stroke
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x, this.y)
                            canvas_context.lineTo(this.x1, this.y)
                            canvas_context.lineTo(this.x, this.tip)
                            canvas_context.lineTo(this.x2, this.y)
                            canvas_context.lineTo(this.x, this.y)
                            if (this.fill == 1) {
                                canvas_context.fill()
                            }
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                        isPointInside(point) {
                            if (point.x <= this.x1) {
                                if (point.y >= this.tip) {
                                    if (point.y <= this.y) {
                                        if (point.x >= this.x2) {
                                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                                            this.basey = point.y - this.tip
                                            this.basex = point.x - this.x
                                            if (this.basex == 0) {
                                                return true
                                            }
                                            this.slope = this.basey / this.basex
                                            if (this.slope >= this.accept1) {
                                                return true
                                            } else if (this.slope <= this.accept2) {
                                                return true
                                            }
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Rectangle {
                        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
                            this.x = x
                            this.y = y
                            this.height = height
                            this.width = width
                            this.color = color

                            this.r = 0 //Math.random() * 10
                            this.g = 0 //Math.random() * 10
                            this.b = 0 //Math.random() * 10
                            this.color = `rgba(${this.r},${this.g},${this.b}, 1)`
                            this.xmom = 0
                            this.ymom = 0
                            this.stroke = stroke
                            this.strokeWidth = strokeWidth
                            this.fill = fill
                        }
                        draw() {
                            this.color = `rgba(${this.r*2.5},${this.g*2.5},${this.b*2.5}, 1)`
                            canvas_context.strokeStyle = this.color
                            canvas_context.fillStyle = this.color
                            canvas_context.fillRect(this.x, this.y, this.width, this.height)
                            canvas_context.strokeRect(this.x, this.y, this.width, this.height)
                        }
                        move() {
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        isPointInside(point) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        if (point.y <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y + point.radius >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesFootTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y + point.radius >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        // if (point.y + point.radius <= this.y + this.height) {
                                        if (point.y <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesHeadTouch(point) {
                            // if (point.x + point.radius >= this.x) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        // if (point.y - point.radius <= this.y + this.height) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesLeftTouch(point) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesRightTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Circle {
                        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                            this.x = x
                            this.y = y
                            this.radius = radius
                            this.color = color
                            this.xmom = xmom
                            this.ymom = ymom
                            this.friction = friction
                            this.reflect = reflect
                            this.strokeWidth = strokeWidth
                            this.strokeColor = strokeColor
                            this.marked = 0
                        }
                        draw() {
                            canvas_context.lineWidth = this.strokeWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath();
                            if (this.radius > 0) {
                                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                                canvas_context.fillStyle = this.color
                                canvas_context.fill()
                                canvas_context.stroke();
                            } else {
                                console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                            }
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }

                            this.x += this.xmom
                            this.y += this.ymom
                            canvas_context.translate(-this.xmom, -this.ymom)
                        }
                        unmove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        frictiveMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            canvas_context.translate(-this.xmom, -this.ymom)
                            this.xmom *= this.friction
                            this.ymom *= this.friction
                        }
                        frictiveunMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.xmom /= this.friction
                            this.ymom /= this.friction
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        isPointInside(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                                return true
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                                return true
                            }
                            return false
                        }
                    }
                    class Polygon {
                        constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
                            if (sides < 2) {
                                sides = 2
                            }
                            this.reflect = reflect
                            this.xmom = xmom
                            this.ymom = ymom
                            this.body = new Circle(x, y, size - (size * .293), "transparent")
                            this.nodes = []
                            this.angle = angle
                            this.size = size
                            this.color = color
                            this.angleIncrement = (Math.PI * 2) / sides
                            this.sides = sides
                            for (let t = 0; t < sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                        }
                        isPointInside(point) { // rough approximation
                            this.body.radius = this.size - (this.size * .293)
                            if (this.sides <= 2) {
                                return false
                            }
                            this.areaY = point.y - this.body.y
                            this.areaX = point.x - this.body.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                                return true
                            }
                            return false
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.body.x > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.body.x < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.body.x += this.xmom
                            this.body.y += this.ymom
                        }
                        draw() {
                            this.nodes = []
                            this.angleIncrement = (Math.PI * 2) / this.sides
                            this.body.radius = this.size - (this.size * .293)
                            for (let t = 0; t < this.sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                            canvas_context.strokeStyle = this.color
                            canvas_context.fillStyle = this.color
                            canvas_context.lineWidth = 0
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
                            for (let t = 1; t < this.nodes.length; t++) {
                                canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
                            }
                            canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
                            canvas_context.fill()
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                    }
                    class Shape {
                        constructor(shapes) {
                            this.shapes = shapes
                        }
                        isPointInside(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].isPointInside(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].doesPerimeterTouch(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        isInsideOf(box) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (box.isPointInside(this.shapes[t])) {
                                    return true
                                }
                            }
                            return false
                        }
                        push(object) {
                            this.shapes.push(object)
                        }
                    }
                    class Spring {
                        constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
                            if (body == 0) {
                                this.body = new Circle(x, y, radius, color)
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            } else {
                                this.body = body
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            }
                            this.gravity = gravity
                            this.width = width
                        }
                        balance() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            if (this.beam.hypotenuse() < this.length) {
                                this.body.xmom += (this.body.x - this.anchor.x) / this.length
                                this.body.ymom += (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
                            } else {
                                this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
                            }
                            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
                        }
                        draw() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            this.beam.draw()
                            this.body.draw()
                            this.anchor.draw()
                        }
                        move() {
                            this.anchor.ymom += this.gravity
                            this.anchor.move()
                        }

                    }
                    class Color {
                        constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
                            this.hue = baseColor
                            if (red != -1 && green != -1 && blue != -1) {
                                this.r = red
                                this.g = green
                                this.b = blue
                                if (alpha != 1) {
                                    if (alpha < 1) {
                                        this.alpha = alpha
                                    } else {
                                        this.alpha = alpha / 255
                                        if (this.alpha > 1) {
                                            this.alpha = 1
                                        }
                                    }
                                }
                                if (this.r > 255) {
                                    this.r = 255
                                }
                                if (this.g > 255) {
                                    this.g = 255
                                }
                                if (this.b > 255) {
                                    this.b = 255
                                }
                                if (this.r < 0) {
                                    this.r = 0
                                }
                                if (this.g < 0) {
                                    this.g = 0
                                }
                                if (this.b < 0) {
                                    this.b = 0
                                }
                            } else {
                                this.r = 0
                                this.g = 0
                                this.b = 0
                            }
                        }
                        normalize() {
                            if (this.r > 255) {
                                this.r = 255
                            }
                            if (this.g > 255) {
                                this.g = 255
                            }
                            if (this.b > 255) {
                                this.b = 255
                            }
                            if (this.r < 0) {
                                this.r = 0
                            }
                            if (this.g < 0) {
                                this.g = 0
                            }
                            if (this.b < 0) {
                                this.b = 0
                            }
                        }
                        randomLight() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12) + 4)];
                            }
                            var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
                            return color;
                        }
                        randomDark() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12))];
                            }
                            var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
                            return color;
                        }
                        random() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 16))];
                            }
                            var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
                            return color;
                        }
                    }
                    class Softbody { //buggy, spins in place
                        constructor(x, y, radius, color, members = 10, memberLength = 5, force = 10, gravity = 0) {
                            this.springs = []
                            this.pin = new Circle(x, y, radius, color)
                            this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
                            this.springs.push(this.spring)
                            for (let k = 0; k < members; k++) {
                                this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
                                if (k < members - 1) {
                                    this.springs.push(this.spring)
                                } else {
                                    this.spring.anchor = this.pin
                                    this.springs.push(this.spring)
                                }
                            }
                            this.forceConstant = force
                            this.centroid = new Point(0, 0)
                        }
                        circularize() {
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.springs.length; s++) {
                                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                            this.angle = 0
                            this.angleIncrement = (Math.PI * 2) / this.springs.length
                            for (let t = 0; t < this.springs.length; t++) {
                                this.springs[t].body.x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                                this.springs[t].body.y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                                this.angle += this.angleIncrement
                            }
                        }
                        balance() {
                            for (let s = this.springs.length - 1; s >= 0; s--) {
                                this.springs[s].balance()
                            }
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.springs.length; s++) {
                                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                            for (let s = 0; s < this.springs.length; s++) {
                                this.link = new Line(this.centroid.x, this.centroid.y, this.springs[s].anchor.x, this.springs[s].anchor.y, 0, "transparent")
                                if (this.link.hypotenuse() != 0) {
                                    this.springs[s].anchor.xmom += (((this.springs[s].anchor.x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                                    this.springs[s].anchor.ymom += (((this.springs[s].anchor.y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                                }
                            }
                            for (let s = 0; s < this.springs.length; s++) {
                                this.springs[s].move()
                            }
                            for (let s = 0; s < this.springs.length; s++) {
                                this.springs[s].draw()
                            }
                        }
                    }
                    class Observer {
                        constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
                            this.body = new Circle(x, y, radius, color, 0, 0, 1, 1)
                            this.color = color
                            this.ray = []
                            this.rayrange = range
                            this.globalangle = Math.PI
                            this.gapangle = angle
                            this.currentangle = 0
                            this.obstacles = []
                            this.raymake = rays
                            this.turner = Math.floor((Math.random() - .5) * 3)
                            this.turnrate = Math.random() * .05
                        }
                        beam() {
                            this.currentangle = this.gapangle / 2
                            for (let k = 0; k < this.raymake; k++) {
                                this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                                let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                                ray.collided = 0
                                ray.lifespan = this.rayrange - 1
                                ray.move()
                                ray.move()
                                ray.move()
                                this.ray.push(ray)
                            }
                            for (let f = 0; f < this.rayrange; f++) {
                                for (let t = 0; t < this.ray.length; t++) {
                                    if (this.ray[t].collided < 1) {
                                        this.ray[t].move()
                                        for (let q = 0; q < this.obstacles.length; q++) {
                                            if (this.obstacles[q].isPointInside(this.ray[t])) {
                                                this.ray[t].collided = 1
                                                if (t > Math.floor(this.ray.length * .5)) {
                                                    this.turner = -1
                                                } else if (t < Math.floor(this.ray.length * .5)) {
                                                    this.turner = 1
                                                } else {
                                                    this.obstacles[q].marked = 1
                                                }

                                            }
                                        }
                                    }
                                }
                            }
                        }
                        draw() {
                            this.beam()
                            this.body.draw()
                            canvas_context.lineWidth = 1
                            canvas_context.fillStyle = this.color
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.body.x, this.body.y)
                            for (let y = 0; y < this.ray.length; y++) {
                                canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                                canvas_context.lineTo(this.body.x, this.body.y)
                            }
                            canvas_context.stroke()
                            canvas_context.fill()

                            this.body.xmom += (this.ray[(Math.floor(this.ray.length * .5))].xmom) / 100
                            this.body.ymom += (this.ray[(Math.floor(this.ray.length * .5))].ymom) / 100

                            if (this.turner == -1) {
                                this.globalangle += this.turnrate
                            }
                            if (this.turner == 1) {
                                this.globalangle -= this.turnrate
                            }


                            this.body.move()
                            this.ray = []
                        }
                    }

                    function setUp(canvas_pass, style = "#000000") {
                        canvas = canvas_pass
                        canvas_context = canvas.getContext('2d');
                        canvas.style.background = style
                            // window.setInterval(function () {
                        windowspares[booter.index] = canvas
                        booter.main = main
                            // }, 17)
                        document.addEventListener('keydown', (event) => {
                            keysPressed[event.key] = true;
                        });
                        document.addEventListener('keyup', (event) => {
                            delete keysPressed[event.key];
                        });
                        window.addEventListener('pointerdown', e => {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            TIP_engine.x = XS_engine
                            TIP_engine.y = YS_engine
                            TIP_engine.body = TIP_engine

                        });

                        window.addEventListener('pointermove', continued_stimuli);
                        window.addEventListener('pointerup', e => {
                            // window.removeEventListener("pointermove", continued_stimuli);
                        })

                        canvas.addEventListener('pointermove', continued_stimuli);

                        function continued_stimuli(e) {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            TIP_engine.x = XS_engine
                            TIP_engine.y = YS_engine
                            TIP_engine.body = TIP_engine

                            // let TIP_engineD = {}
                            // TIP_engineD.x = TIP_engine.x-diggers[0].body.x
                            // TIP_engineD.y = TIP_engine.y-diggers[0].body.y
                            // let link = new LineOP(diggers[0].body, TIP_engineD)
                            diggers[0].angle = (Math.atan2(375 - TIP_engine.y, 400 - TIP_engine.x)) + Math.PI


                        }
                    }

                    function control(object, speed = 1) { // basic control for objects
                        if (typeof object.body != 'undefined') {
                            if (keysPressed['w']) {
                                // if (object.dry == 1) {
                                //     object.body.ymom = -(speed * 3)
                                //     // canvas_context.translate(0, speed*100)
                                // } else {
                                if (object.head == 0) {
                                    object.body.y -= (speed)
                                    object.body.ymom -= .3
                                    canvas_context.translate(0, speed)
                                } else {
                                    object.dry = 2
                                }
                                // }
                            }
                            if (keysPressed['d']) {
                                if (object.right == 0) {
                                    object.body.x += speed
                                    canvas_context.translate(-speed, 0)
                                }
                            }
                            if (keysPressed['s']) {
                                if (object.dry == 0) {

                                    object.body.y += (speed)
                                    object.body.ymom += .3
                                    canvas_context.translate(0, -speed)

                                }
                            }
                            if (keysPressed['a']) {
                                if (object.left == 0) {
                                    object.body.x -= speed
                                    canvas_context.translate(speed, 0)
                                }
                            }
                            if (keysPressed['x']) {

                            }
                        } else if (typeof object != 'undefined') {
                            if (keysPressed['w']) {
                                object.y -= speed
                            }
                            if (keysPressed['d']) {
                                object.x += speed
                            }
                            if (keysPressed['s']) {
                                object.y += speed
                            }
                            if (keysPressed['a']) {
                                object.x -= speed
                            }
                        }
                    }

                    function getRandomLightColor() { // random color that will be visible on  black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12) + 4)];
                        }
                        return color;
                    }

                    function getRandomColor() { // random color
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 16) + 0)];
                        }
                        return color;
                    }

                    function getRandomDarkColor() { // color that will be visible on a black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12))];
                        }
                        return color;
                    }

                    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
                        let limit = granularity
                        let shape_array = []
                        for (let t = 0; t < limit; t++) {
                            let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                            shape_array.push(circ)
                        }
                        return (new Shape(shape_array))
                    }

                    let setup_canvas = document.createElement("CANVAS");
                    setup_canvas.width = 700
                    setup_canvas.height = 700
                    setup_canvas.hidden = true

                    // let together = document.getElementById('col') //getting canvas from document

                    // let cohesion = document.getElementById('coh') //getting canvas from document
                    // let separation = document.getElementById('sep') //getting canvas from document

                    setUp(setup_canvas, "#AABBBB") // setting up canvas refrences, starting timer. 

                    // object instantiation and creation happens here 

                    class Digger {
                        constructor(args = 0) {
                            if (args == 0) {

                                this.id = digId
                                this.body = new Circle(350, 350, 12, namer, 0, 0, .99)
                                this.drill = new Circle(canvas.width * .5, canvas.height * .5, 10, "yellow")
                                this.angle = 0
                                this.red = 0
                                this.green = 0
                                this.blue = 0
                                this.maxfuel = 200
                                this.fuel = 200
                                this.fuelgauge = new Rectangle(0, 0, 100, 20, "red")
                                this.fuelgauge.r = 255
                                this.fuelgauge.g = 0
                                this.fuelgauge.b = 0
                                this.redrate = 2
                                this.bluerate = .5
                                this.greenrate = 1
                                this.money = 0
                                this.greencount = 0
                                this.redcount = 0
                                this.bluecount = 0


                                this.dry = 0
                            } else {
                                // console.log("bighit")
                                this.id = args.id
                                this.body = new Circle(args.x, args.y, 12, args.color, 0, 0, .99)
                                this.angle = args.angle
                                this.drill = new Circle(args.x + (Math.cos(((Math.random() * -.5) * .35) + this.angle) * 17), args.y + (Math.sin(((Math.random() * -.5) * .35) + this.angle) * 17), 3, "yellow")
                                this.red = 0
                                this.green = 0
                                this.blue = 0
                                this.maxfuel = 200
                                this.fuel = 200
                                this.fuelgauge = new Rectangle(0, 0, 100, 20, "red")
                                this.fuelgauge.r = 255
                                this.fuelgauge.g = 0
                                this.fuelgauge.b = 0
                                this.redrate = 2
                                this.bluerate = .5
                                this.greenrate = 1
                                this.money = args.money
                                this.greencount = 0
                                this.redcount = 0
                                this.bluecount = 0


                                this.dry = 0
                            }
                        }
                        draw() {

                            if (this.dry == 2) {
                                this.dry = 1
                            } else {
                                this.dry = 0
                            }
                            this.head = 0
                            this.left = 0
                            this.right = 0
                            for (let t = 0; t < world.grid.length; t++) {
                                for (let k = 0; k < world.grid[t].length; k++) {


                                    this.line = new LineOP(world.grid[t][k], this.body)
                                    if (this.line.hypotenuse() < 600) {
                                        if (this.fuel > 0) {
                                            if (world.grid[t][k].doesPerimeterTouch(this.drill)) {

                                                if (diggers.indexOf(this) == 0) {

                                                    if (world.grid[t][k].r > 0) {
                                                        world.grid[t][k].r -= this.redrate
                                                        this.red += this.redrate
                                                        this.redcount += this.redrate
                                                    }
                                                    if (world.grid[t][k].b > 0) {
                                                        world.grid[t][k].b -= this.bluerate
                                                        this.blue += this.bluerate
                                                        this.bluecount += this.bluerate
                                                    }
                                                    if (world.grid[t][k].g > 0) {
                                                        world.grid[t][k].g -= this.greenrate
                                                        this.green += this.greenrate
                                                        this.greencount += this.greenrate
                                                    }
                                                    if (world.grid[t][k].g + world.grid[t][k].b + world.grid[t][k].r <= 0) {
                                                        world.grid[t][k].marked = 1


                                                        let json = {}
                                                        json.splicer = 1
                                                        json.k = world.grid[t][k].k
                                                        json.t = world.grid[t][k].t


                                                        ws.send(JSON.stringify(json))
                                                    }

                                                } else {

                                                    if (world.grid[t][k].r > 0) {
                                                        world.grid[t][k].r -= this.redrate * 1.1
                                                        this.red += this.redrate * 1.1
                                                        this.redcount += this.redrate * 1.1
                                                    }
                                                    if (world.grid[t][k].b > 0) {
                                                        world.grid[t][k].b -= this.bluerate * 1.1
                                                        this.blue += this.bluerate * 1.1
                                                        this.bluecount += this.bluerate * 1.1
                                                    }
                                                    if (world.grid[t][k].g > 0) {
                                                        world.grid[t][k].g -= this.greenrate * 1.1
                                                        this.green += this.greenrate * 1.1
                                                        this.greencount += this.greenrate * 1.1
                                                    }
                                                    if (world.grid[t][k].g + world.grid[t][k].b + world.grid[t][k].r <= 0) {

                                                        let json = {}
                                                        json.splicer = 1
                                                        json.k = world.grid[t][k].k
                                                        json.t = world.grid[t][k].t


                                                        world.grid[t][k].marked = 1
                                                    }
                                                }
                                            }
                                        }
                                        if (world.grid[t][k].doesFootTouch(this.body)) {
                                            this.dry = 1
                                        }
                                        if (world.grid[t][k].doesHeadTouch(this.body)) {
                                            this.head = 1
                                        }
                                        if (world.grid[t][k].doesRightTouch(this.body)) {
                                            this.right = 1
                                        }
                                        if (world.grid[t][k].doesLeftTouch(this.body)) {
                                            this.left = 1
                                        }
                                    }
                                }
                            }
                            if (this.bluecount > 1) {
                                let rect = new Rectangle(this.drill.x - ((Math.random() - .5) * 3), this.drill.y - ((Math.random() - .5) * 3), 3.5, 3.5, "transparent")
                                rect.r = 0
                                rect.g = 0
                                rect.b = 255
                                rect.xmom = (Math.random() - .5) * 3
                                rect.ymom = (Math.random() - .5) * 3
                                particles.push(rect)
                                this.bluecount = 0
                            }
                            if (this.redcount > 1) {
                                let rect = new Rectangle(this.drill.x - ((Math.random() - .5) * 3), this.drill.y - ((Math.random() - .5) * 3), 3.5, 3.5, "transparent")
                                rect.r = 255
                                rect.g = 0
                                rect.b = 0
                                rect.xmom = (Math.random() - .5) * 3
                                rect.ymom = (Math.random() - .5) * 3
                                particles.push(rect)
                                this.redcount = 0
                            }
                            if (this.greencount > 1) {
                                let rect = new Rectangle(this.drill.x - ((Math.random() - .5) * 3), this.drill.y - ((Math.random() - .5) * 3), 3.5, 3.5, "transparent")
                                rect.r = 0
                                rect.g = 255
                                rect.b = 0
                                rect.xmom = Math.random() - .5
                                rect.ymom = Math.random() - .5
                                particles.push(rect)
                                this.greencount = 0
                            }

                            if (this.head == 1) {
                                if (this.body.ymom < 0) {
                                    this.body.ymom = 0
                                }
                            }
                            if (this.dry == 0) {
                                if (this.body.ymom > -5) {
                                    this.body.ymom += .3
                                }
                            } else {
                                if (this.body.ymom > 0) {
                                    this.body.ymom = 0
                                }
                            }
                            if (diggers.indexOf(this) == 0) {
                                this.body.frictiveMove()
                            }

                            this.fuelgauge = new Rectangle(this.body.x - 330, this.body.y - 270, 100, 20, "red")
                            this.fuelgauge.width = (this.fuel / this.maxfuel) * 100
                                // this.fuel -= .03
                            if (this.fuel < 0) {
                                this.fuel = 0
                            }
                            this.fuelgauge.r = 255
                            this.fuelgauge.g = 0
                            this.fuelgauge.b = 0

                            if (diggers.indexOf(this) == 0) {
                                // this.fuelgauge.draw()

                                // canvas_context.strokeStyle = "gray"
                                // canvas_context.strokeRect(this.fuelgauge.x-1, this.fuelgauge.y-1, 102, this.fuelgauge.height+2)

                            }
                            this.drill = new Circle(this.body.x + (Math.cos(((Math.random() * -.5) * .35) + this.angle) * 17), this.body.y + (Math.sin(((Math.random() * -.5) * .35) + this.angle) * 17), 3, "yellow")
                            this.drill2 = new Circle(this.body.x + (Math.cos(((Math.random() * -.5) * .35) + this.angle + (Math.PI * .5)) * 15), this.body.y + (Math.sin(((Math.random() * -.5) * .35) + this.angle + (Math.PI * .5)) * 15), 3, "yellow")
                            this.drill3 = new Circle(this.body.x + (Math.cos(((Math.random() * -.5) * .35) + this.angle - (Math.PI * .5)) * 15), this.body.y + (Math.sin(((Math.random() * -.5) * .35) + this.angle - (Math.PI * .5)) * 15), 3, "yellow")
                            this.drill.draw()
                            this.link1 = new LineOP(this.drill, this.drill2, "yellow", 8)
                                // this.link2 = new LineOP(this.drill2, this.drill3, "yellow" , 3)
                            this.link3 = new LineOP(this.drill, this.drill3, "yellow", 8)
                            this.body.draw()
                            this.link1.draw()
                                // this.link2.draw()
                            this.link3.draw()
                                // canvas_context.fill()

                            if (diggers.indexOf(this) == 0) {
                                canvas_context.font = "20px arial"
                                    // canvas_context.fillStyle = "red"
                                    // canvas_context.fillText(`Carbon: ${Math.round(this.red)}`, this.body.x - 330, this.body.y - 330)
                                    // canvas_context.fillStyle = "green"
                                    // canvas_context.fillText(`Nitrogen: ${Math.round(this.green)}`, this.body.x - 330, this.body.y - 310)
                                    // canvas_context.fillStyle = "blue"
                                    // canvas_context.fillText(`Hydrogen: ${Math.round(this.blue)}`, this.body.x - 330, this.body.y - 290)
                                for (let t = 0; t < diggers.length; t++) {

                                    canvas_context.strokeStyle = "black"
                                    canvas_context.lineWidth = 2
                                    canvas_context.font = "20px arial"
                                    canvas_context.strokeText(`$ ${Math.round(diggers[t].money)}`, this.body.x + 260, this.body.y - 330 + (t * 20))

                                    canvas_context.font = "20px arial"
                                    canvas_context.fillStyle = diggers[t].body.color
                                    canvas_context.fillText(`$ ${Math.round(diggers[t].money)}`, this.body.x + 260, this.body.y - 330 + (t * 20))
                                }
                            }
                        }
                    }

                    class Grid {
                        constructor() {
                            this.grid = []
                            this.shape = new Shape([])
                            this.shapes = []
                            this.counter = 0
                            this.rands = rands
                            for (let t = 0; t < 100; t++) {
                                this.grid.push([])
                                for (let k = 400; k < 24000; k += 50) {
                                    this.counter++
                                        this.counter %= 49999
                                    let block = new Rectangle((t * 50) - 2000, k, 50, 50, getRandomColor())
                                    block.k = k
                                    block.t = t
                                    block.r += (this.rands[`${this.counter}`] * (k / 20))

                                    this.counter++
                                        this.counter %= 49999
                                    if (this.rands[`${this.counter}`] < (.04 + (k / 1000000))) {

                                        this.counter++
                                            this.counter %= 49999
                                        block.g += (this.rands[`${this.counter}`] * (k / 20))

                                        this.counter++
                                            this.counter %= 49999
                                    }
                                    block.g += (this.rands[`${this.counter}`] * (k / 100))

                                    this.counter++
                                        this.counter %= 49999
                                    if (this.rands[`${this.counter}`] < (.02 + (k / 1000000))) {

                                        this.counter++
                                            this.counter %= 49999
                                        block.b += (this.rands[`${this.counter}`] * (k / 20))
                                        this.counter++
                                            this.counter %= 49999
                                    }
                                    block.b += (this.rands[`${this.counter}`] * (k / 180))

                                    this.counter++
                                        this.counter %= 49999
                                    this.grid[t].push(block)
                                }
                            }
                        }
                        clean() {
                            for (let t = 0; t < this.grid.length; t++) {
                                for (let k = 0; k < this.grid[t].length; k++) {
                                    if (this.grid[t][k].marked == 1) {
                                        this.grid[t].splice(k, 1)
                                    }
                                }
                            }
                        }
                        draw() {


                            if(booter.listener.clear == 1){
                                booter.listener.clear = 0
                                
                            this.grid = []
                            this.shape = new Shape([])
                            this.shapes = []
                            this.counter = 0
                            this.rands = rands
                            for (let t = 0; t < 100; t++) {
                                this.grid.push([])
                                for (let k = 400; k < 24000; k += 50) {
                                    this.counter++
                                        this.counter %= 49999
                                    let block = new Rectangle((t * 50) - 2000, k, 50, 50, getRandomColor())
                                    block.k = k
                                    block.t = t
                                    block.r += (this.rands[`${this.counter}`] * (k / 20))

                                    this.counter++
                                        this.counter %= 49999
                                    if (this.rands[`${this.counter}`] < (.04 + (k / 1000000))) {

                                        this.counter++
                                            this.counter %= 49999
                                        block.g += (this.rands[`${this.counter}`] * (k / 20))

                                        this.counter++
                                            this.counter %= 49999
                                    }
                                    block.g += (this.rands[`${this.counter}`] * (k / 100))

                                    this.counter++
                                        this.counter %= 49999
                                    if (this.rands[`${this.counter}`] < (.02 + (k / 1000000))) {

                                        this.counter++
                                            this.counter %= 49999
                                        block.b += (this.rands[`${this.counter}`] * (k / 20))
                                        this.counter++
                                            this.counter %= 49999
                                    }
                                    block.b += (this.rands[`${this.counter}`] * (k / 180))

                                    this.counter++
                                        this.counter %= 49999
                                    this.grid[t].push(block)
                                }
                            }
                            }
                            // this.shapes = []
                            for (let t = 0; t < this.grid.length; t++) {
                                for (let k = 0; k < this.grid[t].length; k++) {
                                    let line = new LineOP(this.grid[t][k], diggers[0].body)
                                    if (line.hypotenuse() < 600) {
                                        this.grid[t][k].draw()
                                    }
                                }
                                // this.shapes.push(new Shape(this.grid[t]))
                            }




                            // this.shape = new Shape(this.shapes)

                        }

                    }

                    let diggers = []
                    let world = new Grid()
                    diggers[0] = new Digger()
                    let fueldepot = new Rectangle(-1000000250, 250, 100, 100, "white")
                    let selldepot = new Rectangle(-10000, -10000, 200000, 200000, "white")
                    let upgradedepot = new Rectangle(-10000000, 0, 0, 0, "white")
                    let particles = []



                    DigSocketize(ws)

                    function DigSocketize(ws) {

                        // console.log("0hit")

                        // console.log("hit")
                        ws.addEventListener("message", ({
                            data
                        }) => {


                            if (JSON.parse(data).splicer >= 0) {



                                // for(let t = 0;t<world.grid.length;t++){
                                for (let k = 0; k < world.grid[JSON.parse(data).t].length; k++) {
                                    if (JSON.parse(data).t == world.grid[JSON.parse(data).t][k].t) {
                                        if (JSON.parse(data).k == world.grid[JSON.parse(data).t][k].k) {
                                            world.grid[JSON.parse(data).t][k].marked = 1
                                        }
                                    }
                                }
                                // }


                                // world.grid[JSON.parse(data).t][JSON.parse(data).k].marked = 1

                            } else if (JSON.parse(data).diggers >= 0) {

                                // console.log("hit")

                                if (diggerIds.includes(JSON.parse(data).id)) {
                                    diggers[diggerIds.indexOf(JSON.parse(data).id)] = new Digger(JSON.parse(data))
                                } else {
                                    diggerIds.push(JSON.parse(data).id)
                                    diggers[diggerIds.length - 1] = new Digger(JSON.parse(data))
                                }

                            } else {





                                if (booter.running == 0) {
                                    return
                                }

                                textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)
                                textcanvas_context.font = "12px arial"
                                textcanvas_context.fillStyle = JSON.parse(data).color
                                if (typeof JSON.parse(data).name != "undefined") {


                                    let ypointer = 300 + textscroll
                                    let stoarr = (`(${JSON.parse(data).name}) ` + ' ' + JSON.parse(data).text).split('')
                                    let stostring = ''
                                    for (let t = 0; t < stoarr.length; t++) {
                                        const width = textcanvas_context.measureText(stostring + '' + stoarr[t]).width
                                        if (width > textcanvas.width - 12) {
                                            textcanvas_context.fillText(stostring + '' + stoarr[t], 0, ypointer)
                                            ypointer += 12
                                            textscroll += 12
                                            stostring = ''
                                        } else {
                                            stostring = stostring + "" + stoarr[t]
                                            if (t == stoarr.length - 1) {

                                                textscroll += 12
                                                textcanvas_context.fillText(stostring, 0, ypointer)
                                            }
                                        }
                                    }


                                    // textcanvas_context.fillText(`(${JSON.parse(data).name}) `+ JSON.parse(data).text, 0, 300+textscroll)

                                    console.log(JSON.parse(data).measure)
                                        // textscroll += JSON.parse(data).measure
                                }
                                // textcanvas_context.translate(0, 12)
                                // textcanvas.translate(0, 12)
                            }
                        })

                        // let json = {}
                        // json.connecting = 1

                        // ws.send(JSON.stringify(json))
                        // })

                    }

                    function main() {
                        if (booter.running == 0) {
                            return
                        }
                        canvas_context.fillStyle = "#AAAAAA"
                        canvas_context.fillRect(-10000, -10000, canvas.width * 1000, canvas.height * 1000) // refreshes the image
                        world.draw()
                        world.clean()
                            // fueldepot.draw()
                            // selldepot.draw()
                            // upgradedepot.draw()
                            // canvas_context.fillStyle = "white"
                            // canvas_context.fillText("fuel", 280, 280)
                            // canvas_context.fillText("sell", 480, 280)
                            // canvas_context.fillText("upgrade", 660, 280)
                        if (fueldepot.doesPerimeterTouch(diggers[0].body)) {
                            if (diggers[0].money >= (diggers[0].maxfuel - diggers[0].fuel)) {
                                diggers[0].money -= (diggers[0].maxfuel - diggers[0].fuel)
                                diggers[0].fuel = diggers[0].maxfuel
                            } else {
                                diggers[0].fuel += diggers[0].money
                                diggers[0].money = 0
                            }
                        }
                        if (selldepot.doesPerimeterTouch(diggers[0].body)) {
                            diggers[0].money += diggers[0].red / 100
                            diggers[0].money += diggers[0].green / 10
                            diggers[0].money += diggers[0].blue
                            diggers[0].green = 0
                            diggers[0].red = 0
                            diggers[0].blue = 0
                        }
                        if (upgradedepot.doesPerimeterTouch(diggers[0].body)) {
                            if (diggers[0].maxfuel < 10000) {
                                for (let t = 0; diggers[0].money > 100; diggers[0].money -= 100) {
                                    if (diggers[0].maxfuel < 5000) {
                                        diggers[0].maxfuel *= 1.025
                                        diggers[0].redrate *= 1.025
                                        diggers[0].greenrate *= 1.025
                                        diggers[0].bluerate *= 1.025
                                    } else {
                                        break
                                    }
                                }
                            }
                        }
                        for (let t = 0; t < diggers.length; t++) {

                            if (t == 0) {
                                if (ws.readyState == 1) {
                                    let json = {}
                                    json.diggers = 1
                                    json.x = diggers[0].body.x
                                    json.color = namer
                                    json.id = diggers[0].id
                                    json.money = diggers[0].money
                                    json.y = diggers[0].body.y
                                    json.angle = diggers[0].angle
                                    ws.send(JSON.stringify(json))
                                }
                            }
                            if (typeof diggers[t] != 'undefined') {
                                diggers[t].draw()
                            }
                        }
                        if (diggers[0].fuel > 0) {
                            control(diggers[0], 5)
                        }
                        for (let t = 0; t < particles.length; t++) {
                            particles[t].move()
                            particles[t].draw()
                            particles[t].height -= .1
                            particles[t].width -= .1
                        }
                        for (let t = 0; t < particles.length; t++) {
                            if (particles[t].height <= 0) {
                                particles.splice(t, 1)
                            } else if (particles[t].width <= 0) {
                                particles.splice(t, 1)
                            }

                        }
                    }




                } else if (booter.index == 0) {
                    this.running = 1


                    // const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
                    // for(let t = 0;t<10000000;t++){
                    //     squaretable[`${t}`] = Math.sqrt(t)
                    //     if(t > 999){
                    //         t+=9
                    //     }
                    // }
                    // let song = new Audio()
                    // song.src = '' // 'http://ditzbitz.com/frog.mp3'
                    const gamepadAPI = {
                        controller: {},
                        turbo: true,
                        connect: function(evt) {
                            if (navigator.getGamepads()[0] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[1] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[2] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[3] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            }
                            for (let i = 0; i < gamepads.length; i++) {
                                if (gamepads[i] === null) {
                                    continue;
                                }
                                if (!gamepads[i].connected) {
                                    continue;
                                }
                            }
                        },
                        disconnect: function(evt) {
                            gamepadAPI.turbo = false;
                            delete gamepadAPI.controller;
                        },
                        update: function() {
                            gamepadAPI.controller = navigator.getGamepads()[0]
                            gamepadAPI.buttonsCache = []; // clear the buttons cache
                            for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) { // move the buttons status from the previous frame to the cache
                                gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
                            }
                            gamepadAPI.buttonsStatus = []; // clear the buttons status
                            var c = gamepadAPI.controller || {}; // get the gamepad object
                            var pressed = [];
                            if (c.buttons) {
                                for (var b = 0, t = c.buttons.length; b < t; b++) { // loop through buttons and push the pressed ones to the array
                                    if (c.buttons[b].pressed) {
                                        pressed.push(gamepadAPI.buttons[b]);
                                    }
                                }
                            }
                            var axes = [];
                            if (c.axes) {
                                for (var a = 0, x = c.axes.length; a < x; a++) { // loop through axes and push their values to the array
                                    axes.push(c.axes[a].toFixed(2));
                                }
                            }
                            gamepadAPI.axesStatus = axes; // assign received values
                            gamepadAPI.buttonsStatus = pressed;
                            // //console.log(pressed); // return buttons for debugging purposes
                            return pressed;
                        },
                        buttonPressed: function(button, hold) {
                            var newPress = false;
                            for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) { // loop through pressed buttons
                                if (gamepadAPI.buttonsStatus[i] == button) { // if we found the button we're looking for...
                                    newPress = true; // set the boolean variable to true
                                    if (!hold) { // if we want to check the single press
                                        for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) { // loop through the cached states from the previous frame
                                            if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                                newPress = false;
                                            }
                                        }
                                    }
                                }
                            }
                            return newPress;
                        },
                        buttons: [
                            'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
                        ],
                        buttonsCache: [],
                        buttonsStatus: [],
                        axesStatus: []
                    };
                    let canvas
                    let canvas_context
                    let keysPressed = {}
                    let FLEX_engine
                        // let TIP_engine = {}
                    let XS_engine
                    let YS_engine
                        // TIP_engine.x = 350
                        // TIP_engine.y = 350
                    class Point {
                        constructor(x, y) {
                            this.x = x
                            this.y = y
                            this.radius = 0
                        }
                        pointDistance(point) {
                            return (new LineOP(this, point, "transparent", 0)).hypotenuse()
                        }
                    }

                    class Vector { // vector math and physics if you prefer this over vector components on circles
                        constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
                            this.xmom = xmom
                            this.ymom = ymom
                            this.object = object
                        }
                        isToward(point) {
                            let link = new LineOP(this.object, point)
                            let dis1 = link.squareDistance()
                            let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                            let link2 = new LineOP(dummy, point)
                            let dis2 = link2.squareDistance()
                            if (dis2 < dis1) {
                                return true
                            } else {
                                return false
                            }
                        }
                        rotate(angleGoal) {
                            let link = new Line(this.xmom, this.ymom, 0, 0)
                            let length = link.hypotenuse()
                            let x = (length * Math.cos(angleGoal))
                            let y = (length * Math.sin(angleGoal))
                            this.xmom = x
                            this.ymom = y
                        }
                        magnitude() {
                            return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
                        }
                        normalize(size = 1) {
                            let magnitude = this.magnitude()
                            this.xmom /= magnitude
                            this.ymom /= magnitude
                            this.xmom *= size
                            this.ymom *= size
                        }
                        multiply(vect) {
                            let point = new Point(0, 0)
                            let end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
                            return point.pointDistance(end)
                        }
                        add(vect) {
                            return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
                        }
                        subtract(vect) {
                            return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
                        }
                        divide(vect) {
                            return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
                        }
                        draw() {
                            let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                            let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
                            link.draw()
                        }
                    }
                    class Line {
                        constructor(x, y, x2, y2, color, width) {
                            this.x1 = x
                            this.y1 = y
                            this.x2 = x2
                            this.y2 = y2
                            this.color = color
                            this.width = width
                        }
                        angle() {
                            return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
                        }
                        squareDistance() {
                            let xdif = this.x1 - this.x2
                            let ydif = this.y1 - this.y2
                            let squareDistance = (xdif * xdif) + (ydif * ydif)
                            return squareDistance
                        }
                        hypotenuse() {
                            let xdif = this.x1 - this.x2
                            let ydif = this.y1 - this.y2
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                                // if(hypotenuse < 10000000-1){
                                //     if(hypotenuse > 1000){
                                //         return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                //     }else{
                                //     return squaretable[`${Math.round(hypotenuse)}`]
                                //     }
                                // }else{
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                            // }
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x1, this.y1)
                            canvas_context.lineTo(this.x2, this.y2)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class LineOP {
                        constructor(object, target, color, width) {
                            this.object = object
                            this.target = target
                            this.color = color
                            this.width = width
                        }
                        squareDistance() {
                            let xdif = this.object.x - this.target.x
                            let ydif = this.object.y - this.target.y
                            let squareDistance = (xdif * xdif) + (ydif * ydif)
                            return squareDistance
                        }
                        hypotenuse() {
                            let xdif = this.object.x - this.target.x
                            let ydif = this.object.y - this.target.y
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                                // if(hypotenuse < 10000000-1){
                                //     if(hypotenuse > 1000){
                                //         return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                //     }else{
                                //     return squaretable[`${Math.round(hypotenuse)}`]
                                //     }
                                // }else{
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                            // }
                        }
                        angle() {
                            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.object.x, this.object.y)
                            canvas_context.lineTo(this.target.x, this.target.y)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class Triangle {
                        constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
                            this.x = x
                            this.y = y
                            this.color = color
                            this.length = length
                            this.x1 = this.x + this.length * leg1Ratio
                            this.x2 = this.x - this.length * leg2Ratio
                            this.tip = this.y - this.length * heightRatio
                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                            this.fill = fill
                            this.stroke = strokeWidth
                        }
                        draw() {
                            canvas_context.strokeStyle = this.color
                            canvas_context.stokeWidth = this.stroke
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x, this.y)
                            canvas_context.lineTo(this.x1, this.y)
                            canvas_context.lineTo(this.x, this.tip)
                            canvas_context.lineTo(this.x2, this.y)
                            canvas_context.lineTo(this.x, this.y)
                            if (this.fill == 1) {
                                canvas_context.fill()
                            }
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                        isPointInside(point) {
                            if (point.x <= this.x1) {
                                if (point.y >= this.tip) {
                                    if (point.y <= this.y) {
                                        if (point.x >= this.x2) {
                                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                                            this.basey = point.y - this.tip
                                            this.basex = point.x - this.x
                                            if (this.basex == 0) {
                                                return true
                                            }
                                            this.slope = this.basey / this.basex
                                            if (this.slope >= this.accept1) {
                                                return true
                                            } else if (this.slope <= this.accept2) {
                                                return true
                                            }
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Rectangle {
                        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
                            this.x = x
                            this.y = y
                            this.height = height
                            this.width = width
                            this.color = color
                            this.xmom = 0
                            this.ymom = 0
                            this.stroke = stroke
                            this.strokeWidth = strokeWidth
                            this.fill = fill
                            this.t = 0
                            this.k = 0
                        }
                        draw() {
                            canvas_context.fillStyle = this.color
                            canvas_context.fillRect(this.x, this.y, this.width, this.height)
                        }
                        move() {
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        isPointInside(point) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        if (point.y <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y + point.radius >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class RectangleGrad {
                        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
                            this.x = x
                            this.y = y
                            this.height = height
                            this.width = width
                            this.color = color
                            this.xmom = 0
                            this.ymom = 0
                            this.stroke = stroke
                            this.strokeWidth = strokeWidth
                            this.fill = fill
                            let grad = canvas_context.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);

                            for (let t = 0; t < 10000; t++) {
                                grad.addColorStop(t / 10000, getRandomFrogColor() + '44');
                            }
                            this.grad = grad
                        }
                        draw() {
                            canvas_context.fillStyle = this.grad
                            canvas_context.fillRect(this.x, this.y, this.width, this.height)
                        }
                        move() {
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        isPointInside(point) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        if (point.y <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y + point.radius >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Circle {
                        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                            this.x = x
                            this.y = y
                            this.radius = radius
                            this.color = color
                            this.xmom = xmom
                            this.ymom = ymom
                            this.friction = friction
                            this.reflect = reflect
                            this.strokeWidth = strokeWidth
                            this.strokeColor = strokeColor
                        }
                        draw() {
                            canvas_context.lineWidth = this.strokeWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath();
                            if (this.radius > 0) {
                                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                                canvas_context.fillStyle = this.color
                                canvas_context.fill()
                                canvas_context.stroke();
                            } else {
                                //console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                            }
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            canvas_context.translate(-this.xmom, -this.ymom)
                        }
                        unmove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        frictiveMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            this.xmom *= this.friction
                            this.ymom *= this.friction
                        }
                        frictiveunMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.xmom /= this.friction
                            this.ymom /= this.friction
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        isPointInside(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                                return true
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                                return true
                            }
                            return false
                        }
                    }
                    class CircleRing {
                        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                            this.x = x
                            this.y = y
                            this.radius = radius
                            this.color = color
                            this.xmom = xmom
                            this.ymom = ymom
                            this.friction = friction
                            this.reflect = reflect
                            this.strokeWidth = 10
                            this.strokeColor = strokeColor
                        }
                        draw() {
                            canvas_context.lineWidth = this.strokeWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath();
                            if (this.radius > 0) {
                                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                                canvas_context.fillStyle = this.color
                                canvas_context.fill()
                                canvas_context.stroke();
                            } else {
                                //console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                            }
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        unmove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        frictiveMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            this.xmom *= this.friction
                            this.ymom *= this.friction
                        }
                        frictiveunMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.xmom /= this.friction
                            this.ymom /= this.friction
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        isPointInside(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                                return true
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                                return true
                            }
                            return false
                        }
                    }
                    class Polygon {
                        constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
                            if (sides < 2) {
                                sides = 2
                            }
                            this.reflect = reflect
                            this.xmom = xmom
                            this.ymom = ymom
                            this.body = new Circle(x, y, size - (size * .293), "transparent")
                            this.nodes = []
                            this.angle = angle
                            this.size = size
                            this.color = color
                            this.angleIncrement = (Math.PI * 2) / sides
                            this.sides = sides
                            for (let t = 0; t < sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                        }
                        isPointInside(point) { // rough approximation
                            this.body.radius = this.size - (this.size * .293)
                            if (this.sides <= 2) {
                                return false
                            }
                            this.areaY = point.y - this.body.y
                            this.areaX = point.x - this.body.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                                return true
                            }
                            return false
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.body.x > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.body.x < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.body.x += this.xmom
                            this.body.y += this.ymom
                        }
                        draw() {
                            this.nodes = []
                            this.angleIncrement = (Math.PI * 2) / this.sides
                            this.body.radius = this.size - (this.size * .293)
                            for (let t = 0; t < this.sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                            canvas_context.strokeStyle = this.color
                            canvas_context.fillStyle = this.color
                            canvas_context.lineWidth = 0
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
                            for (let t = 1; t < this.nodes.length; t++) {
                                canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
                            }
                            canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
                            canvas_context.fill()
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                    }
                    class Shape {
                        constructor(shapes) {
                            this.shapes = shapes
                        }
                        draw() {
                            for (let t = 0; t < this.shapes.length; t++) {
                                this.shapes[t].draw()
                            }
                        }
                        isPointInside(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].isPointInside(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].doesPerimeterTouch(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        innerShape(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].doesPerimeterTouch(point)) {
                                    return this.shapes[t]
                                }
                            }
                            return false
                        }
                        isInsideOf(box) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (box.isPointInside(this.shapes[t])) {
                                    return true
                                }
                            }
                            return false
                        }
                        adjustByFromDisplacement(x, y) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (typeof this.shapes[t].fromRatio == "number") {
                                    this.shapes[t].x += x * this.shapes[t].fromRatio
                                    this.shapes[t].y += y * this.shapes[t].fromRatio
                                }
                            }
                        }
                        adjustByToDisplacement(x, y) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (typeof this.shapes[t].toRatio == "number") {
                                    this.shapes[t].x += x * this.shapes[t].toRatio
                                    this.shapes[t].y += y * this.shapes[t].toRatio
                                }
                            }
                        }
                        mixIn(arr) {
                            for (let t = 0; t < arr.length; t++) {
                                for (let k = 0; k < arr[t].shapes.length; k++) {
                                    this.shapes.push(arr[t].shapes[k])
                                }
                            }
                        }
                        push(object) {
                            this.shapes.push(object)
                        }
                    }

                    class Spring {
                        constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
                            if (body == 0) {
                                this.body = new Circle(x, y, radius, color)
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            } else {
                                this.body = body
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            }
                            this.gravity = gravity
                            this.width = width
                        }
                        balance() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            if (this.beam.hypotenuse() < this.length) {
                                this.body.xmom += (this.body.x - this.anchor.x) / this.length
                                this.body.ymom += (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
                            } else {
                                this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
                            }
                            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
                        }
                        draw() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            this.beam.draw()
                            this.body.draw()
                            this.anchor.draw()
                        }
                        move() {
                            this.anchor.ymom += this.gravity
                            this.anchor.move()
                        }

                    }
                    class SpringOP {
                        constructor(body, anchor, length, width = 3, color = body.color) {
                            this.body = body
                            this.anchor = anchor
                            this.beam = new LineOP(body, anchor, color, width)
                            this.length = length
                        }
                        balance() {
                            if (this.beam.hypotenuse() < this.length) {
                                this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
                                this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
                                this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
                                this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
                            } else if (this.beam.hypotenuse() > this.length) {
                                this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
                                this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
                                this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
                                this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
                            }

                            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
                        }
                        draw() {
                            this.beam.draw()
                        }
                        move() {
                            //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
                        }
                    }

                    class Color {
                        constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
                            this.hue = baseColor
                            if (red != -1 && green != -1 && blue != -1) {
                                this.r = red
                                this.g = green
                                this.b = blue
                                if (alpha != 1) {
                                    if (alpha < 1) {
                                        this.alpha = alpha
                                    } else {
                                        this.alpha = alpha / 255
                                        if (this.alpha > 1) {
                                            this.alpha = 1
                                        }
                                    }
                                }
                                if (this.r > 255) {
                                    this.r = 255
                                }
                                if (this.g > 255) {
                                    this.g = 255
                                }
                                if (this.b > 255) {
                                    this.b = 255
                                }
                                if (this.r < 0) {
                                    this.r = 0
                                }
                                if (this.g < 0) {
                                    this.g = 0
                                }
                                if (this.b < 0) {
                                    this.b = 0
                                }
                            } else {
                                this.r = 0
                                this.g = 0
                                this.b = 0
                            }
                        }
                        normalize() {
                            if (this.r > 255) {
                                this.r = 255
                            }
                            if (this.g > 255) {
                                this.g = 255
                            }
                            if (this.b > 255) {
                                this.b = 255
                            }
                            if (this.r < 0) {
                                this.r = 0
                            }
                            if (this.g < 0) {
                                this.g = 0
                            }
                            if (this.b < 0) {
                                this.b = 0
                            }
                        }
                        randomLight() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12) + 4)];
                            }
                            var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
                            return color;
                        }
                        randomDark() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12))];
                            }
                            var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
                            return color;
                        }
                        random() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 16))];
                            }
                            var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
                            return color;
                        }
                    }
                    class Softbody { //buggy, spins in place
                        constructor(x, y, radius, color, size, members = 10, memberLength = 5, force = 10, gravity = 0) {
                            this.springs = []
                            this.pin = new Circle(x, y, radius, color)
                            this.points = []
                            this.flop = 0
                            let angle = 0
                            this.size = size
                            let line = new Line((Math.cos(angle) * size), (Math.sin(angle) * size), (Math.cos(angle + ((Math.PI * 2) / members)) * size), (Math.sin(angle + ((Math.PI * 2) / members)) * size))
                            let distance = line.hypotenuse()
                            for (let t = 0; t < members; t++) {
                                let circ = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), radius, color)
                                circ.reflect = 1
                                circ.bigbody = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), distance, color)
                                circ.draw()
                                circ.touch = []
                                this.points.push(circ)
                                angle += ((Math.PI * 2) / members)
                            }

                            for (let t = 0; t < this.points.length; t++) {
                                for (let k = 0; k < this.points.length; k++) {
                                    if (t != k) {
                                        if (this.points[k].bigbody.doesPerimeterTouch(this.points[t])) {
                                            if (!this.points[k].touch.includes(t) && !this.points[t].touch.includes(k)) {
                                                let spring = new SpringOP(this.points[k], this.points[t], (size * Math.PI) / members, 2, color)
                                                this.points[k].touch.push(t)
                                                this.points[t].touch.push(k)
                                                this.springs.push(spring)
                                                spring.beam.draw()
                                            }
                                        }
                                    }
                                }
                            }

                            //console.log(this)

                            // this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
                            // this.springs.push(this.spring)
                            // for (let k = 0; k < members; k++) {
                            //     this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
                            //     if (k < members - 1) {
                            //         this.springs.push(this.spring)
                            //     } else {
                            //         this.spring.anchor = this.pin
                            //         this.springs.push(this.spring)
                            //     }
                            // }
                            this.forceConstant = force
                            this.centroid = new Circle(0, 0, 10, "red")
                        }
                        circularize() {
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.springs.length; s++) {
                                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                            this.angle = 0
                            this.angleIncrement = (Math.PI * 2) / this.springs.length
                            for (let t = 0; t < this.points.length; t++) {
                                this.points[t].x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                                this.points[t].y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                                this.angle += this.angleIncrement
                            }
                        }
                        balance() {
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.points.length; s++) {
                                this.xpoint += (this.points[s].x / this.points.length)
                                this.ypoint += (this.points[s].y / this.points.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                                // this.centroid.x += TIP_engine.x / this.points.length
                                // this.centroid.y += TIP_engine.y / this.points.length
                            for (let s = 0; s < this.points.length; s++) {
                                this.link = new LineOP(this.points[s], this.centroid, 0, "transparent")
                                if (this.link.hypotenuse() != 0) {

                                    if (this.size < this.link.hypotenuse()) {
                                        this.points[s].xmom -= (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                        this.points[s].ymom -= (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                    } else {
                                        this.points[s].xmom += (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                        this.points[s].ymom += (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                    }

                                    // this.points[s].xmom += (((this.points[s].x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                                    // this.points[s].ymom += (((this.points[s].y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                                }
                            }
                            if (this.flop % 2 == 0) {
                                for (let s = 0; s < this.springs.length; s++) {
                                    this.springs[s].balance()
                                }
                            } else {
                                for (let s = this.springs.length - 1; s >= 0; s--) {
                                    this.springs[s].balance()
                                }
                            }
                            for (let s = 0; s < this.points.length; s++) {
                                this.points[s].move()
                                this.points[s].draw()
                            }
                            for (let s = 0; s < this.springs.length; s++) {
                                this.springs[s].draw()
                            }
                            this.centroid.draw()
                        }
                    }
                    class Observer {
                        constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
                            this.body = new Circle(x, y, radius, color)
                            this.color = color
                            this.ray = []
                            this.rayrange = range
                            this.globalangle = Math.PI
                            this.gapangle = angle
                            this.currentangle = 0
                            this.obstacles = []
                            this.raymake = rays
                        }
                        beam() {
                            this.currentangle = this.gapangle / 2
                            for (let k = 0; k < this.raymake; k++) {
                                this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                                let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                                ray.collided = 0
                                ray.lifespan = this.rayrange - 1
                                this.ray.push(ray)
                            }
                            for (let f = 0; f < this.rayrange; f++) {
                                for (let t = 0; t < this.ray.length; t++) {
                                    if (this.ray[t].collided < 1) {
                                        this.ray[t].move()
                                        for (let q = 0; q < this.obstacles.length; q++) {
                                            if (this.obstacles[q].isPointInside(this.ray[t])) {
                                                this.ray[t].collided = 1
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        draw() {
                            this.beam()
                            this.body.draw()
                            canvas_context.lineWidth = 1
                            canvas_context.fillStyle = this.color
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.body.x, this.body.y)
                            for (let y = 0; y < this.ray.length; y++) {
                                canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                                canvas_context.lineTo(this.body.x, this.body.y)
                            }
                            canvas_context.stroke()
                            canvas_context.fill()
                            this.ray = []
                        }
                    }

                    function setUp(canvas_pass, style = "#000000") {
                        canvas = canvas_pass
                        canvas_context = canvas.getContext('2d');
                        canvas.style.background = style

                        booter.main = main
                        document.addEventListener('keydown', (event) => {
                            keysPressed[event.key] = true;
                        });
                        document.addEventListener('keyup', (event) => {
                            delete keysPressed[event.key];
                        });
                        window.addEventListener('pointerdown', e => {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            // TIP_engine.x = XS_engine
                            // TIP_engine.y = YS_engine
                            // TIP_engine.body = TIP_engine
                            if (timed == 0) {
                                // if(buttontimeb.isPointInside(TIP_engine)){
                                //     timed = 1
                                //     time = new Date()
                                //     moment = time.getTime()

                                //     tadpoles[0] = new BullFrog()

                                //         for(let t = 0;t<312000;t++){
                                //             flies.push(new Fly())

                                //         if(Math.random()<.1){
                                //             flies[t].body.y-=16000
                                //             flies[t].body.radius*=3
                                //         }
                                //         if(Math.random()<.1){
                                //             flies[t].body.y-=16000
                                //             flies[t].body.radius*=3
                                //         }
                                //         if(Math.random()<.1){
                                //             flies[t].body.y-=16000
                                //             flies[t].body.radius*=1.5
                                //         }
                                //         }
                                // }
                                if (buttonzenb.isPointInside(TIP_engine)) {
                                    timed = -1

                                    tadpoles[0] = new BullFrog()

                                    for (let t = 0; t < 312000; t++) {
                                        flies.push(new Fly())

                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 3
                                        }
                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 3
                                        }
                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 1.5
                                        }
                                    }
                                }

                                // if(buttontimeg.isPointInside(TIP_engine)){
                                //     timed = 1
                                //     time = new Date()
                                //     moment = time.getTime()

                                //     tadpoles[0] = new GlideFrog()   

                                //     for(let t = 0;t<312000;t++){
                                //         flies.push(new Fly())

                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=3
                                //     }
                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=3
                                //     }
                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=1.5
                                //     }
                                //     }
                                // }
                                if (buttonzeng.isPointInside(TIP_engine)) {
                                    timed = -1

                                    tadpoles[0] = new GlideFrog()

                                    for (let t = 0; t < 312000; t++) {
                                        flies.push(new Fly())

                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 3
                                        }
                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 3
                                        }
                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 1.5
                                        }
                                    }
                                }


                                // if(buttontimef.isPointInside(TIP_engine)){
                                //     timed = 1
                                //     time = new Date()
                                //     moment = time.getTime()

                                //     tadpoles[0] = new Frog()           

                                //     for(let t = 0;t<312000;t++){
                                //         flies.push(new Fly())

                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=3
                                //     }
                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=3
                                //     }
                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=1.5
                                //     }
                                //     }
                                // }
                                if (buttonzenf.isPointInside(TIP_engine)) {
                                    timed = -1
                                    tadpoles[0] = new Frog()

                                    for (let t = 0; t < 312000; t++) {
                                        flies.push(new Fly())

                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 3
                                        }
                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 3
                                        }
                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 1.5
                                        }
                                    }
                                }

                                // if(buttontimep.isPointInside(TIP_engine)){
                                //     timed = 1
                                //     time = new Date()
                                //     moment = time.getTime()

                                //     tadpoles[0] = new PygmyFrog()    

                                //     for(let t = 0;t<312000;t++){
                                //         flies.push(new Fly())

                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=3
                                //     }
                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=3
                                //     }
                                //     if(Math.random()<.1){
                                //         flies[t].body.y-=16000
                                //         flies[t].body.radius*=1.5
                                //     }
                                //     }
                                // }
                                if (buttonzenp.isPointInside(TIP_engine)) {
                                    timed = -1
                                    tadpoles[0] = new PygmyFrog()

                                    for (let t = 0; t < 312000; t++) {
                                        flies.push(new Fly())

                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 3
                                        }
                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 3
                                        }
                                        if (Math.random() < .1) {
                                            flies[t].body.y -= 16000
                                            flies[t].body.radius *= 1.5
                                        }
                                    }
                                }
                            }
                            // example usage: if(object.isPointInside(TIP_engine)){ take action }
                        });
                        window.addEventListener('pointermove', continued_stimuli);

                        window.addEventListener('pointerup', e => {
                            // window.removeEventListener("pointermove", continued_stimuli);
                        })

                        function continued_stimuli(e) {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            // TIP_engine.x = XS_engine
                            // TIP_engine.y = YS_engine
                            // TIP_engine.body = TIP_engine
                        }
                    }

                    function gamepad_control(object, speed = 1) { // basic control for objects using the controler
                        //         //console.log(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
                        if (typeof object.body != 'undefined') {
                            if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                                if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                                    object.body.x += (gamepadAPI.axesStatus[0] * speed)
                                    object.body.y += (gamepadAPI.axesStatus[1] * speed)
                                }
                            }
                        } else if (typeof object != 'undefined') {
                            if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                                if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                                    object.x += (gamepadAPI.axesStatus[0] * speed)
                                    object.y += (gamepadAPI.axesStatus[1] * speed)
                                }
                            }
                        }
                    }

                    function control(object, speed = 1) { // basic control for objects
                        if (typeof object.body != 'undefined') {
                            if (keysPressed['w']) {
                                object.body.y -= speed
                            }
                            if (keysPressed['d']) {
                                object.body.x += speed
                            }
                            if (keysPressed['s']) {
                                object.body.y += speed
                            }
                            if (keysPressed['a']) {
                                object.body.x -= speed
                            }
                        } else if (typeof object != 'undefined') {
                            if (keysPressed['w']) {
                                object.y -= speed
                            }
                            if (keysPressed['d']) {
                                object.x += speed
                            }
                            if (keysPressed['s']) {
                                object.y += speed
                            }
                            if (keysPressed['a']) {
                                object.x -= speed
                            }
                        }
                    }

                    function getRandomFrogColor() { // random color that will be visible on  black background
                        var letters = '0123456789ABCDEF';
                        var color = '#22';
                        for (var i = 0; i < 2; i++) {
                            color += letters[(Math.floor(Math.random() * 12) + 4)];
                        }
                        for (var i = 0; i < 2; i++) {
                            color += letters[(Math.floor(Math.random() * 12) + 4)];
                        }

                        return color;
                    }

                    function getRandomLightColor() { // random color that will be visible on  black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12) + 4)];
                        }
                        return color;
                    }

                    function getRandomColor() { // random color
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 16) + 0)];
                        }
                        return color;
                    }

                    function getRandomDarkColor() { // color that will be visible on a black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12))];
                        }
                        return color;
                    }

                    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
                        let limit = granularity
                        let shape_array = []
                        for (let t = 0; t < limit; t++) {
                            let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                            circ.toRatio = t / limit
                            circ.fromRatio = (limit - t) / limit
                            shape_array.push(circ)
                        }
                        return (new Shape(shape_array))
                    }

                    let setup_canvas = document.createElement("CANVAS");
                    setup_canvas.width = 700
                    setup_canvas.height = 700
                    setup_canvas.hidden = true

                    setUp(setup_canvas) // setting up canvas refrences, starting timer. 

                    // object instantiation and creation happens here 

                    class Frog {
                        constructor(args = 0) {
                            if (args == 0) {
                                this.id = frogid
                                this.type = 3
                                this.flies = 0
                                this.color = namer
                                this.angle = 0
                                this.body = new Circle(350, 350, 5, this.color)
                                this.guide = new Circle(353, 350, 3, this.color)
                                this.tongue = new Circle(353, 350, 3, getRandomColor())
                                this.guidedis = 3
                                this.links = []
                                this.eye1 = new Circle(350, 350, 1.1, 'black')
                                this.eye2 = new Circle(350, 350, 1.1, 'black')
                                this.leg1 = new Circle(350, 350, 3, this.color)
                                this.leg2 = new Circle(350, 350, 3, this.color)
                                this.leg1x = new Circle(350, 350, 2, this.color)
                                this.leg2x = new Circle(350, 350, 2, this.color)
                                this.leg1link = new LineOP(this.body, this.leg1, this.color, 4)
                                this.leg2link = new LineOP(this.body, this.leg2, this.color, 4)
                                this.leg1xlink = new LineOP(this.leg1x, this.leg1, this.color, 2.5)
                                this.leg2xlink = new LineOP(this.leg2x, this.leg2, this.color, 2.5)
                                this.leg3 = new Circle(350, 350, 3, this.color)
                                this.leg4 = new Circle(350, 350, 3, this.color)
                                this.leg3x = new Circle(350, 350, 2, this.color)
                                this.leg4x = new Circle(350, 350, 2, this.color)
                                this.leg3link = new LineOP(this.body, this.leg3, this.color, 4)
                                this.leg4link = new LineOP(this.body, this.leg4, this.color, 4)
                                this.leg3xlink = new LineOP(this.leg3x, this.leg3, this.color, 2.5)
                                this.leg4xlink = new LineOP(this.leg4x, this.leg4, this.color, 2.5)
                                this.tonguelink = new LineOP(this.body, this.tongue, this.tongue.color, 2.5)
                                this.combo = 0
                                this.spindle = 1
                                this.timeratio = .8
                                this.tonguedis = 2.9
                                this.tonguemom = 0
                                this.scale = 1
                                this.scores = []
                                this.score = 0
                            } else {
                                this.flies = args.flies
                                this.color = args.color
                                this.angle = args.angle
                                this.body = new Circle(args.x, args.y, 5, this.color)
                                this.guide = new Circle(353, 350, 3, this.color)
                                this.tongue = new Circle(353, 350, 3, getRandomColor())
                                this.guidedis = 3
                                this.links = []
                                this.eye1 = new Circle(350, 350, 1.1, 'black')
                                this.eye2 = new Circle(350, 350, 1.1, 'black')
                                this.leg1 = new Circle(350, 350, 3, this.color)
                                this.leg2 = new Circle(350, 350, 3, this.color)
                                this.leg1x = new Circle(350, 350, 2, this.color)
                                this.leg2x = new Circle(350, 350, 2, this.color)
                                this.leg1link = new LineOP(this.body, this.leg1, this.color, 4)
                                this.leg2link = new LineOP(this.body, this.leg2, this.color, 4)
                                this.leg1xlink = new LineOP(this.leg1x, this.leg1, this.color, 2.5)
                                this.leg2xlink = new LineOP(this.leg2x, this.leg2, this.color, 2.5)
                                this.leg3 = new Circle(350, 350, 3, this.color)
                                this.leg4 = new Circle(350, 350, 3, this.color)
                                this.leg3x = new Circle(350, 350, 2, this.color)
                                this.leg4x = new Circle(350, 350, 2, this.color)
                                this.leg3link = new LineOP(this.body, this.leg3, this.color, 4)
                                this.leg4link = new LineOP(this.body, this.leg4, this.color, 4)
                                this.leg3xlink = new LineOP(this.leg3x, this.leg3, this.color, 2.5)
                                this.leg4xlink = new LineOP(this.leg4x, this.leg4, this.color, 2.5)
                                this.tonguelink = new LineOP(this.body, this.tongue, this.tongue.color, 2.5)
                                this.combo = 0
                                this.spindle = args.spindle
                                this.timeratio = args.timeratio
                                this.tonguedis = args.tonguedis
                                this.tonguemom = 0
                                this.scale = 1
                                this.scores = []
                                this.score = args.score


                                this.guidedis = 3 + (Math.min(this.flies, 1200) * .12345) * .3
                                this.body.radius = 5 + (Math.min(this.flies, 1200) * .12345) * .3
                                this.eye2.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.eye1.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.leg1.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg2x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg3x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg4x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.tongue.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .09

                                this.leg1link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                                this.leg3link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15


                            }
                        }
                        draw() {
                            for (let t = 0; t < this.scores.length; t++) {
                                this.scores[t].draw()
                            }
                            if (this.tonguedis < 3) {
                                this.tonguedis = 3
                                if (tadpoles.indexOf(this) == 0) {
                                    if (keysPressed[' '] || keysPressed['e'] || keysPressed['l']) {
                                        this.tonguemom = this.guidedis * 5
                                    }
                                }
                            }
                            this.tonguedis += this.tonguemom
                            this.tonguedis *= .93
                            this.tonguedis -= 1
                            this.tonguemom *= .91


                            if (tadpoles.indexOf(this) == 0) {
                                this.body.move()
                            }
                            if (keysPressed['w'] || !water.isPointInside(this.body)) {
                                if (keysPressed['w']) {
                                    if (tadpoles.indexOf(this) == 0) {
                                        this.timeratio = .92 + ((Math.cos(this.spindle)) * .15)
                                        this.spindle += .1
                                    }
                                }
                            }
                            if (!water.isPointInside(this.body)) {
                                this.body.ymom += .08
                            }

                            this.guide.x = (Math.cos(this.angle) * this.guidedis) + this.body.x
                            this.guide.y = (Math.sin(this.angle) * this.guidedis) + this.body.y
                            this.tongue.x = (Math.cos(this.angle) * this.tonguedis) + this.body.x
                            this.tongue.y = (Math.sin(this.angle) * this.tonguedis) + this.body.y

                            this.tongue.draw()
                            this.tonguelink.draw()
                            this.body.draw()
                            this.eye1.x = (Math.cos(this.angle - .58) * this.guidedis) + this.body.x
                            this.eye1.y = (Math.sin(this.angle - .58) * this.guidedis) + this.body.y
                            this.eye2.x = (Math.cos(this.angle + .58) * this.guidedis) + this.body.x
                            this.eye2.y = (Math.sin(this.angle + .58) * this.guidedis) + this.body.y
                            this.leg1.x = (Math.cos(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.x
                            this.leg1.y = (Math.sin(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.y
                            this.leg2.x = (Math.cos(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.x
                            this.leg2.y = (Math.sin(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.y
                            this.leg1x.x = (Math.cos(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.x
                            this.leg1x.y = (Math.sin(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.y
                            this.leg2x.x = (Math.cos(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.x
                            this.leg2x.y = (Math.sin(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.y
                            this.leg3.x = this.body.x - (Math.cos(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg3.y = this.body.y - (Math.sin(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg4.x = this.body.x - (Math.cos(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg4.y = this.body.y - (Math.sin(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg3x.x = this.body.x - (Math.cos(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg3x.y = this.body.y - (Math.sin(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg4x.x = this.body.x - (Math.cos(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg4x.y = this.body.y - (Math.sin(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)

                            if (tadpoles.indexOf(this) == 0) {
                                if (keysPressed['d']) {
                                    this.angle += .055
                                }
                                if (keysPressed['a']) {
                                    this.angle -= .055
                                }
                            }
                            if (keysPressed['w'] && water.isPointInside(this.body)) {
                                if (tadpoles.indexOf(this) == 0) {
                                    this.combo = 0
                                    this.scores = []
                                    this.body.xmom = (this.body.xmom * .95) + (((this.guide.x - this.body.x) * 1.45) * .07)
                                    this.body.ymom = (this.body.ymom * .95) + (((this.guide.y - this.body.y) * 1.45) * .07)
                                }
                            } else {
                                if (water.isPointInside(this.body)) {
                                    this.body.xmom *= .98
                                    this.body.ymom *= .98
                                }
                            }
                            // this.guide.draw()
                            this.leg1.draw()
                            this.leg2.draw()
                            this.leg1x.draw()
                            this.leg2x.draw()
                            this.leg1link.draw()
                            this.leg2link.draw()
                            this.leg1xlink.draw()
                            this.leg2xlink.draw()
                            this.leg3.draw()
                            this.leg4.draw()
                            this.leg3x.draw()
                            this.leg4x.draw()
                            this.leg3link.draw()
                            this.leg4link.draw()
                            this.leg3xlink.draw()
                            this.leg4xlink.draw()
                            this.tonguebeam = castBetween(this.body, this.tongue, (this.body.radius + 1) * 3, this.tongue.radius * 1.7)
                            this.tonguelink.width = this.tongue.radius
                            if(globalListener.execute == 1){
globalListener.execute = 0
                        for(let t =0;t<globalListener.num;t++){
                       this.eat(flies[0], 0)
}
                     }

                        for (let t = 0; t < flies.length; t++) {
                                if (flies[t].link.squareDistance() < (700 * 700) / tadpoles[0].scale) {
                                    if (this.tonguebeam.doesPerimeterTouch(flies[t].body)) {
                                        this.eat(flies[t], t)
                                        t--
                                    }
                                }
                            }
                            if (floor.isPointInside(this.body)) {
                                this.body.ymom *= -1.5
                                if (tadpoles.indexOf(this) == 0) {
                                    this.body.move()
                                }
                            }



                            this.foot1 = new Foot(this.leg1x, this.leg1xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new Foot(this.leg2x, this.leg2xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new Foot(this.leg3x, this.leg3xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new Foot(this.leg4x, this.leg4xlink.angle(), .7)
                            this.foot1.draw()

                            this.eye1.draw()
                            this.eye2.draw()
                        }
                        eat(fly, t) {
                            this.flies++

                                this.combo++
                                this.score += this.combo
                            this.scores.push(new Text(fly.body.x, fly.body.y, this.combo))
                            flies.splice(t, 1)
                            if (this.body.radius < 30) {


                                this.guidedis = 3 + (Math.min(this.flies, 1200) * .12345) * .3
                                this.body.radius = 5 + (Math.min(this.flies, 1200) * .12345) * .3
                                this.eye2.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.eye1.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.leg1.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg2x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg3x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg4x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.tongue.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .09

                                this.leg1link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                                this.leg3link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                                if (tadpoles.indexOf(this) == 0) {
                                    canvas_context.translate(tadpoles[0].body.x, tadpoles[0].body.y)
                                    canvas_context.scale(1 / this.scale, 1 / this.scale)
                                    this.scale *= .9989
                                    canvas_context.scale(this.scale, this.scale)
                                    canvas_context.translate(-tadpoles[0].body.x, -tadpoles[0].body.y)
                                }
                                flies.push(new Fly())
                            }
                        }
                    }

                    class GlideFoot {
                        constructor(root, angle, step) {
                            this.body = root
                            this.toes = []
                            this.angle = angle - step
                            this.step = step
                            for (let t = 0; t < 3; t++) {
                                let toe = new Circle(this.body.x + (Math.cos(this.angle) * this.body.radius * 2), this.body.y + (Math.sin(this.angle) * this.body.radius * 2), this.body.radius * .5, this.body.color)
                                let link = new LineOP(toe, this.body, this.body.color + "BB", toe.radius * .5)
                                this.angle += this.step
                                this.toes.push(toe)
                                this.toes.push(link)
                            }

                        }
                        draw() {
                            for (let t = 0; t < this.toes.length; t++) {
                                this.toes[t].draw()
                            }
                        }
                    }


                    class BullFoot {
                        constructor(root, angle, step) {
                            this.body = root
                            this.toes = []
                            this.angle = angle - step
                            this.step = step
                            for (let t = 0; t < 3; t++) {
                                let toe = new Circle(this.body.x + (Math.cos(this.angle) * this.body.radius * 1.8), this.body.y + (Math.sin(this.angle) * this.body.radius * 1.8), this.body.radius * .3, this.body.color)
                                let link = new LineOP(toe, this.body, this.body.color + "BB", toe.radius * .9)
                                this.angle += this.step
                                this.toes.push(toe)
                                this.toes.push(link)
                            }

                        }
                        draw() {
                            for (let t = 0; t < this.toes.length; t++) {
                                this.toes[t].draw()
                            }
                        }
                    }


                    class Foot {
                        constructor(root, angle, step) {
                            this.body = root
                            this.toes = []
                            this.angle = angle - step
                            this.step = step
                            for (let t = 0; t < 3; t++) {
                                let toe = new Circle(this.body.x + (Math.cos(this.angle) * this.body.radius * 1.8), this.body.y + (Math.sin(this.angle) * this.body.radius * 1.8), this.body.radius * .8, this.body.color)
                                let link = new LineOP(toe, this.body, this.body.color + "BB", toe.radius * .9)
                                this.angle += this.step
                                this.toes.push(toe)
                                this.toes.push(link)
                            }

                        }
                        draw() {
                            for (let t = 0; t < this.toes.length; t++) {
                                this.toes[t].draw()
                            }
                        }
                    }

                    class PygmyFoot {
                        constructor(root, angle, step) {
                            this.body = root
                            this.toes = []
                            this.angle = angle - step
                            this.step = step
                            for (let t = 0; t < 3; t++) {
                                let toe = new Circle(this.body.x + (Math.cos(this.angle) * this.body.radius * 2.1), this.body.y + (Math.sin(this.angle) * this.body.radius * 2.1), this.body.radius * .2, this.body.color)
                                let link = new LineOP(toe, this.body, this.body.color + "BB", toe.radius * .9)
                                this.angle += this.step
                                this.toes.push(toe)
                                this.toes.push(link)
                            }

                        }
                        draw() {
                            for (let t = 0; t < this.toes.length; t++) {
                                this.toes[t].draw()
                            }
                        }
                    }


                    class PygmyFrog {
                        constructor(args = 0) {
                            if (args == 0) {
                                this.id = frogid
                                this.type = 4
                                this.flies = 0
                                this.color = namer
                                this.angle = 0
                                this.body = new Circle(350, 350, 3, this.color)
                                this.guide = new Circle(353, 350, 2, this.color)
                                this.tongue = new Circle(353, 350, 2, getRandomColor())
                                this.guidedis = 3
                                this.links = []
                                this.eye1 = new Circle(350, 350, 1.1, 'black')
                                this.eye2 = new Circle(350, 350, 1.1, 'black')
                                this.leg1 = new Circle(350, 350, 2, this.color)
                                this.leg2 = new Circle(350, 350, 2, this.color)
                                this.leg1x = new Circle(350, 350, 1.5, this.color)
                                this.leg2x = new Circle(350, 350, 1.5, this.color)
                                this.leg1link = new LineOP(this.body, this.leg1, this.color, 4)
                                this.leg2link = new LineOP(this.body, this.leg2, this.color, 4)
                                this.leg1xlink = new LineOP(this.leg1x, this.leg1, this.color, 2.5)
                                this.leg2xlink = new LineOP(this.leg2x, this.leg2, this.color, 2.5)
                                this.leg3 = new Circle(350, 350, 2, this.color)
                                this.leg4 = new Circle(350, 350, 2, this.color)
                                this.leg3x = new Circle(350, 350, 1.5, this.color)
                                this.leg4x = new Circle(350, 350, 1.5, this.color)
                                this.leg3link = new LineOP(this.body, this.leg3, this.color, 2.5)
                                this.leg4link = new LineOP(this.body, this.leg4, this.color, 2.5)
                                this.leg3xlink = new LineOP(this.leg3x, this.leg3, this.color, 1)
                                this.leg4xlink = new LineOP(this.leg4x, this.leg4, this.color, 1)
                                this.tonguelink = new LineOP(this.body, this.tongue, this.tongue.color, 1.5)
                                this.combo = 0
                                this.spindle = 1
                                this.timeratio = .8
                                this.tonguedis = 2.9
                                this.tonguemom = 0
                                this.scale = 1
                                this.scores = []
                                this.score = 0
                            } else {

                                this.flies = args.flies
                                this.color = args.color
                                this.angle = args.angle
                                this.body = new Circle(args.x, args.y, 3, this.color)
                                this.guide = new Circle(353, 350, 2, this.color)
                                this.tongue = new Circle(353, 350, 2, getRandomColor())
                                this.guidedis = 3
                                this.links = []
                                this.eye1 = new Circle(350, 350, 1.1, 'black')
                                this.eye2 = new Circle(350, 350, 1.1, 'black')
                                this.leg1 = new Circle(350, 350, 2, this.color)
                                this.leg2 = new Circle(350, 350, 2, this.color)
                                this.leg1x = new Circle(350, 350, 1.5, this.color)
                                this.leg2x = new Circle(350, 350, 1.5, this.color)
                                this.leg1link = new LineOP(this.body, this.leg1, this.color, 4)
                                this.leg2link = new LineOP(this.body, this.leg2, this.color, 4)
                                this.leg1xlink = new LineOP(this.leg1x, this.leg1, this.color, 2.5)
                                this.leg2xlink = new LineOP(this.leg2x, this.leg2, this.color, 2.5)
                                this.leg3 = new Circle(350, 350, 2, this.color)
                                this.leg4 = new Circle(350, 350, 2, this.color)
                                this.leg3x = new Circle(350, 350, 1.5, this.color)
                                this.leg4x = new Circle(350, 350, 1.5, this.color)
                                this.leg3link = new LineOP(this.body, this.leg3, this.color, 2.5)
                                this.leg4link = new LineOP(this.body, this.leg4, this.color, 2.5)
                                this.leg3xlink = new LineOP(this.leg3x, this.leg3, this.color, 1)
                                this.leg4xlink = new LineOP(this.leg4x, this.leg4, this.color, 1)
                                this.tonguelink = new LineOP(this.body, this.tongue, this.tongue.color, 1.5)
                                this.combo = 0
                                this.spindle = args.spindle
                                this.timeratio = args.timeratio
                                this.tonguedis = args.tonguedis
                                this.tonguemom = 0
                                this.scale = 1
                                this.scores = []
                                this.score = args.score



                                this.guidedis = 3 + (Math.min(this.flies, 1200) * .12345) * .3
                                this.body.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.eye2.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.eye1.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.leg1.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1x.radius = 1.5 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg2x.radius = 1.5 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg3x.radius = 1.5 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg4x.radius = 1.5 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.tongue.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09

                                this.leg1link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                                this.leg3link.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4link.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3xlink.width = 1 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4xlink.width = 1 + (Math.min(this.flies, 1200) * .12345) * .15

                            }
                        }
                        draw() {
                            for (let t = 0; t < this.scores.length; t++) {
                                this.scores[t].draw()
                            }
                            if (this.tonguedis < 3) {
                                this.tonguedis = 3
                                if (tadpoles.indexOf(this) == 0) {
                                    if (keysPressed[' '] || keysPressed['e'] || keysPressed['l']) {
                                        this.tonguemom = this.guidedis * 5
                                    }
                                }
                            }
                            this.tonguedis += this.tonguemom
                            this.tonguedis *= .93
                            this.tonguedis -= 1
                            this.tonguemom *= .91
                            if (tadpoles.indexOf(this) == 0) {
                                this.body.move()
                            }
                            if (keysPressed['w'] || !water.isPointInside(this.body)) {
                                if (keysPressed['w']) {
                                    if (tadpoles.indexOf(this) == 0) {
                                        this.timeratio = .92 + ((Math.cos(this.spindle)) * .15)
                                        this.spindle += .1
                                    }
                                }
                            }
                            if (!water.isPointInside(this.body)) {
                                this.body.ymom += .08
                            }


                            this.guide.x = (Math.cos(this.angle) * this.guidedis) + this.body.x
                            this.guide.y = (Math.sin(this.angle) * this.guidedis) + this.body.y
                            this.tongue.x = (Math.cos(this.angle) * this.tonguedis) + this.body.x
                            this.tongue.y = (Math.sin(this.angle) * this.tonguedis) + this.body.y

                            this.tongue.draw()
                            this.tonguelink.draw()
                            this.body.draw()
                            this.eye1.x = (Math.cos(this.angle - .58) * this.guidedis * .5) + this.body.x
                            this.eye1.y = (Math.sin(this.angle - .58) * this.guidedis * .5) + this.body.y
                            this.eye2.x = (Math.cos(this.angle + .58) * this.guidedis * .5) + this.body.x
                            this.eye2.y = (Math.sin(this.angle + .58) * this.guidedis * .5) + this.body.y
                            this.leg1.x = (Math.cos(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 2.3) + this.body.x
                            this.leg1.y = (Math.sin(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 2.3) + this.body.y
                            this.leg2.x = (Math.cos(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 2.3) + this.body.x
                            this.leg2.y = (Math.sin(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 2.3) + this.body.y
                            this.leg1x.x = (Math.cos(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 3.8) + this.body.x
                            this.leg1x.y = (Math.sin(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 3.8) + this.body.y
                            this.leg2x.x = (Math.cos(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 3.8) + this.body.x
                            this.leg2x.y = (Math.sin(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 3.8) + this.body.y
                            this.leg3.x = this.body.x - (Math.cos(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 2.3)
                            this.leg3.y = this.body.y - (Math.sin(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 2.3)
                            this.leg4.x = this.body.x - (Math.cos(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 2.3)
                            this.leg4.y = this.body.y - (Math.sin(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 2.3)
                            this.leg3x.x = this.body.x - (Math.cos(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 3.8)
                            this.leg3x.y = this.body.y - (Math.sin(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 3.8)
                            this.leg4x.x = this.body.x - (Math.cos(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 3.8)
                            this.leg4x.y = this.body.y - (Math.sin(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 3.8)

                            if (tadpoles.indexOf(this) == 0) {
                                if (keysPressed['d']) {
                                    this.angle += .075
                                }
                                if (keysPressed['a']) {
                                    this.angle -= .075
                                }
                            }

                            if (keysPressed['w'] && water.isPointInside(this.body)) {
                                if (tadpoles.indexOf(this) == 0) {
                                    this.combo = 0
                                    this.scores = []
                                    this.body.xmom = (this.body.xmom * .95) + (((this.guide.x - this.body.x) * 1.85) * .09)
                                    this.body.ymom = (this.body.ymom * .95) + (((this.guide.y - this.body.y) * 1.85) * .09)
                                }
                            } else {
                                if (water.isPointInside(this.body)) {
                                    this.body.xmom *= .99
                                    this.body.ymom *= .99
                                }
                            }
                            // this.guide.draw()
                            this.leg1.draw()
                            this.leg2.draw()
                            this.leg1x.draw()
                            this.leg2x.draw()
                            this.leg1link.draw()
                            this.leg2link.draw()
                            this.leg1xlink.draw()
                            this.leg2xlink.draw()
                            this.leg3.draw()
                            this.leg4.draw()
                            this.leg3x.draw()
                            this.leg4x.draw()
                            this.leg3link.draw()
                            this.leg4link.draw()
                            this.leg3xlink.draw()
                            this.leg4xlink.draw()
                            this.tonguebeam = castBetween(this.body, this.tongue, (this.body.radius + 3) * 5, this.tongue.radius * 2.7)
                            this.tonguelink.width = this.tongue.radius
                            if(globalListener.execute == 1){
globalListener.execute = 0
                        for(let t =0;t<globalListener.num;t++){
                       this.eat(flies[0], 0)
}
                     }

                        for (let t = 0; t < flies.length; t++) {
                                if (flies[t].link.squareDistance() < (700 * 700) / tadpoles[0].scale) {
                                    if (this.tonguebeam.doesPerimeterTouch(flies[t].body)) {
                                        this.eat(flies[t], t)
                                        t--
                                    }
                                }
                            }
                            if (floor.isPointInside(this.body)) {
                                this.body.ymom *= -1.5
                                if (tadpoles.indexOf(this) == 0) {
                                    this.body.move()
                                }
                            }



                            this.foot1 = new PygmyFoot(this.leg1x, this.leg1xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new PygmyFoot(this.leg2x, this.leg2xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new PygmyFoot(this.leg3x, this.leg3xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new PygmyFoot(this.leg4x, this.leg4xlink.angle(), .7)
                            this.foot1.draw()

                            this.eye1.draw()
                            this.eye2.draw()
                        }
                        eat(fly, t) {
                            this.flies++

                                this.combo++
                                this.score += this.combo
                            this.scores.push(new Text(fly.body.x, fly.body.y, this.combo))
                            flies.splice(t, 1)
                            if (this.body.radius < 20) {



                                this.guidedis = 3 + (Math.min(this.flies, 1200) * .12345) * .3
                                this.body.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.eye2.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.eye1.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.leg1.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1x.radius = 1.5 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg2x.radius = 1.5 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg3x.radius = 1.5 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg4x.radius = 1.5 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.tongue.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09

                                this.leg1link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                                this.leg3link.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4link.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3xlink.width = 1 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4xlink.width = 1 + (Math.min(this.flies, 1200) * .12345) * .15

                                if (tadpoles.indexOf(this) == 0) {
                                    canvas_context.translate(tadpoles[0].body.x, tadpoles[0].body.y)
                                    canvas_context.scale(1 / this.scale, 1 / this.scale)
                                    this.scale *= .9989
                                    canvas_context.scale(this.scale, this.scale)
                                    canvas_context.translate(-tadpoles[0].body.x, -tadpoles[0].body.y)
                                }
                                flies.push(new Fly())
                            }
                        }
                    }


                    class BullFrog {
                        constructor(args = 0) {
                            if (args == 0) {
                                this.id = frogid
                                this.type = 1
                                this.flies = 0
                                this.color = namer
                                this.angle = 0
                                this.body = new Circle(350, 350, 8, this.color)
                                this.guide = new Circle(353, 350, 3, this.color)
                                this.tongue = new Circle(353, 350, 5, getRandomColor())
                                this.guidedis = 3
                                this.links = []
                                this.eye1 = new Circle(350, 350, 1.1, 'black')
                                this.eye2 = new Circle(350, 350, 1.1, 'black')
                                this.leg1 = new Circle(350, 350, 3, this.color)
                                this.leg2 = new Circle(350, 350, 3, this.color)
                                this.leg1x = new Circle(350, 350, 2, this.color)
                                this.leg2x = new Circle(350, 350, 2, this.color)
                                this.leg1link = new LineOP(this.body, this.leg1, this.color, 4)
                                this.leg2link = new LineOP(this.body, this.leg2, this.color, 4)
                                this.leg1xlink = new LineOP(this.leg1x, this.leg1, this.color, 2.5)
                                this.leg2xlink = new LineOP(this.leg2x, this.leg2, this.color, 2.5)
                                this.leg3 = new Circle(350, 350, 3, this.color)
                                this.leg4 = new Circle(350, 350, 3, this.color)
                                this.leg3x = new Circle(350, 350, 2, this.color)
                                this.leg4x = new Circle(350, 350, 2, this.color)
                                this.leg3link = new LineOP(this.body, this.leg3, this.color, 4)
                                this.leg4link = new LineOP(this.body, this.leg4, this.color, 4)
                                this.leg3xlink = new LineOP(this.leg3x, this.leg3, this.color, 2.5)
                                this.leg4xlink = new LineOP(this.leg4x, this.leg4, this.color, 2.5)
                                this.tonguelink = new LineOP(this.body, this.tongue, this.tongue.color, 2.5)
                                this.combo = 0
                                this.spindle = 1
                                this.timeratio = .8
                                this.tonguedis = 2.9
                                this.tonguemom = 0
                                this.scale = 1
                                this.scores = []
                                this.score = 0
                            } else {

                                this.flies = args.flies
                                this.color = args.color
                                this.angle = args.angle
                                this.body = new Circle(args.x, args.y, 8, this.color)
                                this.guide = new Circle(353, 350, 3, this.color)
                                this.tongue = new Circle(353, 350, 5, args.tonguecolor)
                                this.guidedis = 3
                                this.links = []
                                this.eye1 = new Circle(350, 350, 1.1, 'black')
                                this.eye2 = new Circle(350, 350, 1.1, 'black')
                                this.leg1 = new Circle(350, 350, 3, this.color)
                                this.leg2 = new Circle(350, 350, 3, this.color)
                                this.leg1x = new Circle(350, 350, 2, this.color)
                                this.leg2x = new Circle(350, 350, 2, this.color)
                                this.leg1link = new LineOP(this.body, this.leg1, this.color, 4)
                                this.leg2link = new LineOP(this.body, this.leg2, this.color, 4)
                                this.leg1xlink = new LineOP(this.leg1x, this.leg1, this.color, 2.5)
                                this.leg2xlink = new LineOP(this.leg2x, this.leg2, this.color, 2.5)
                                this.leg3 = new Circle(350, 350, 3, this.color)
                                this.leg4 = new Circle(350, 350, 3, this.color)
                                this.leg3x = new Circle(350, 350, 2, this.color)
                                this.leg4x = new Circle(350, 350, 2, this.color)
                                this.leg3link = new LineOP(this.body, this.leg3, this.color, 4)
                                this.leg4link = new LineOP(this.body, this.leg4, this.color, 4)
                                this.leg3xlink = new LineOP(this.leg3x, this.leg3, this.color, 2.5)
                                this.leg4xlink = new LineOP(this.leg4x, this.leg4, this.color, 2.5)
                                this.tonguelink = new LineOP(this.body, this.tongue, this.tongue.color, 2.5)
                                this.combo = 0
                                this.spindle = args.spindle
                                this.timeratio = args.timeratio
                                this.tonguedis = args.tonguedis
                                this.tonguemom = 0
                                this.scale = 1
                                this.scores = []
                                this.score = args.score



                                this.guidedis = 3 + (Math.min(this.flies, 1200) * .12345) * .28
                                this.body.radius = 8 + (Math.min(this.flies, 1200) * .12345) * .7
                                this.eye2.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.eye1.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.leg1.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg2x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg3x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg4x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.tongue.radius = 5 + (Math.min(this.flies, 1200) * .12345) * .13

                                this.leg1link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                                this.leg3link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                            }
                        }
                        draw() {
                            for (let t = 0; t < this.scores.length; t++) {
                                this.scores[t].draw()
                            }
                            if (this.tonguedis < 3) {
                                this.tonguedis = 3

                                if (tadpoles.indexOf(this) == 0) {
                                    if (keysPressed[' '] || keysPressed['e'] || keysPressed['l']) {
                                        if (tadpoles.indexOf(this) == 0) {

                                            this.tonguemom = this.guidedis * 5
                                        }
                                    }
                                }
                            }
                            this.tonguedis += this.tonguemom
                            this.tonguedis *= .95
                            this.tonguedis -= 1
                            this.tonguemom *= .90
                            if (tadpoles.indexOf(this) == 0) {
                                this.body.move()
                            }
                            if (tadpoles.indexOf(this) == 0) {
                                if (keysPressed['w'] || !water.isPointInside(this.body)) {
                                    if (keysPressed['w']) {
                                        this.timeratio = .92 + ((Math.cos(this.spindle)) * .15)
                                        this.spindle += .1
                                    }
                                }
                            }
                            if (!water.isPointInside(this.body)) {
                                this.body.ymom += .08
                            }

                            this.guide.x = (Math.cos(this.angle) * this.guidedis) + this.body.x
                            this.guide.y = (Math.sin(this.angle) * this.guidedis) + this.body.y
                            this.tongue.x = (Math.cos(this.angle) * this.tonguedis) + this.body.x
                            this.tongue.y = (Math.sin(this.angle) * this.tonguedis) + this.body.y

                            this.tongue.draw()
                            this.tonguelink.draw()
                            this.body.draw()
                            this.eye1.x = (Math.cos(this.angle - .58) * this.guidedis * 1.1) + this.body.x
                            this.eye1.y = (Math.sin(this.angle - .58) * this.guidedis * 1.1) + this.body.y
                            this.eye2.x = (Math.cos(this.angle + .58) * this.guidedis * 1.1) + this.body.x
                            this.eye2.y = (Math.sin(this.angle + .58) * this.guidedis * 1.1) + this.body.y
                            this.leg1.x = (Math.cos(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.x
                            this.leg1.y = (Math.sin(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.y
                            this.leg2.x = (Math.cos(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.x
                            this.leg2.y = (Math.sin(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.y
                            this.leg1x.x = (Math.cos(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.x
                            this.leg1x.y = (Math.sin(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.y
                            this.leg2x.x = (Math.cos(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.x
                            this.leg2x.y = (Math.sin(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.y
                            this.leg3.x = this.body.x - (Math.cos(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg3.y = this.body.y - (Math.sin(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg4.x = this.body.x - (Math.cos(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg4.y = this.body.y - (Math.sin(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg3x.x = this.body.x - (Math.cos(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg3x.y = this.body.y - (Math.sin(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg4x.x = this.body.x - (Math.cos(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg4x.y = this.body.y - (Math.sin(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)


                            if (tadpoles.indexOf(this) == 0) {
                                if (keysPressed['d']) {
                                    this.angle += .055
                                }
                                if (keysPressed['a']) {
                                    this.angle -= .055
                                }
                            }
                            if (keysPressed['w'] && water.isPointInside(this.body)) {

                                if (tadpoles.indexOf(this) == 0) {
                                    this.combo = 0
                                    this.scores = []
                                    this.body.xmom = (this.body.xmom * .95) + (((this.guide.x - this.body.x) * 1.45) * .07)
                                    this.body.ymom = (this.body.ymom * .95) + (((this.guide.y - this.body.y) * 1.45) * .07)
                                }
                            } else {
                                if (water.isPointInside(this.body)) {
                                    this.body.xmom *= .98
                                    this.body.ymom *= .98
                                }
                            }
                            // this.guide.draw()
                            this.leg1.draw()
                            this.leg2.draw()
                            this.leg1x.draw()
                            this.leg2x.draw()
                            this.leg1link.draw()
                            this.leg2link.draw()
                            this.leg1xlink.draw()
                            this.leg2xlink.draw()
                            this.leg3.draw()
                            this.leg4.draw()
                            this.leg3x.draw()
                            this.leg4x.draw()
                            this.leg3link.draw()
                            this.leg4link.draw()
                            this.leg3xlink.draw()
                            this.leg4xlink.draw()
                            this.tonguebeam = castBetween(this.body, this.tongue, (this.body.radius + 1) * 3, this.tongue.radius * 1.41)
                            this.tonguelink.width = this.tongue.radius
                            if(globalListener.execute == 1){
globalListener.execute = 0
                        for(let t =0;t<globalListener.num;t++){
                       this.eat(flies[0], 0)
}
                     }

                        for (let t = 0; t < flies.length; t++) {
                                if (flies[t].link.squareDistance() < (700 * 700) / tadpoles[0].scale) {
                                    if (this.tonguebeam.doesPerimeterTouch(flies[t].body)) {
                                        this.eat(flies[t], t)
                                        t--
                                    } else if (this.body.doesPerimeterTouch(flies[t].body)) {
                                        this.eat(flies[t], t)
                                        t--
                                    }
                                }
                            }
                            if (floor.isPointInside(this.body)) {
                                this.body.ymom *= -1.5
                                if (tadpoles.indexOf(this) == 0) {
                                    this.body.move()
                                }
                            }


                            this.foot1 = new BullFoot(this.leg1x, this.leg1xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new BullFoot(this.leg2x, this.leg2xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new BullFoot(this.leg3x, this.leg3xlink.angle(), .7)
                            this.foot1.draw()

                            this.foot1 = new BullFoot(this.leg4x, this.leg4xlink.angle(), .7)
                            this.foot1.draw()

                            this.eye1.draw()
                            this.eye2.draw()
                        }
                        eat(fly, t) {
                            this.flies++

                                this.combo++
                                this.score += this.combo
                            this.scores.push(new Text(fly.body.x, fly.body.y, this.combo))
                            flies.splice(t, 1)
                            if (this.body.radius < 50) {




                                this.guidedis = 3 + (Math.min(this.flies, 1200) * .12345) * .28
                                this.body.radius = 8 + (Math.min(this.flies, 1200) * .12345) * .7
                                this.eye2.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.eye1.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.leg1.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg2x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg3x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.leg4x.radius = 2 + (Math.min(this.flies, 1200) * .12345) * .09
                                this.tongue.radius = 5 + (Math.min(this.flies, 1200) * .12345) * .13

                                this.leg1link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                                this.leg3link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4link.width = 4 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4xlink.width = 2.5 + (Math.min(this.flies, 1200) * .12345) * .15

                                if (tadpoles.indexOf(this) == 0) {
                                    canvas_context.translate(tadpoles[0].body.x, tadpoles[0].body.y)
                                    canvas_context.scale(1 / this.scale, 1 / this.scale)
                                    this.scale *= .9989
                                    canvas_context.scale(this.scale, this.scale)
                                    canvas_context.translate(-tadpoles[0].body.x, -tadpoles[0].body.y)
                                }
                                flies.push(new Fly())
                            }
                        }
                    }


                    class GlideFrog {
                        constructor(args = 0) {
                            if (args == 0) {

                                this.id = frogid
                                this.type = 2
                                this.flies = 0
                                this.color = namer
                                this.angle = 0
                                this.body = new Circle(350, 350, 4, this.color)
                                this.guide = new Circle(353, 350, 3, this.color)
                                this.tongue = new Circle(353, 350, 3, getRandomColor())
                                this.guidedis = 3
                                this.links = []
                                this.eye1 = new Circle(350, 350, 1.1, 'black')
                                this.eye2 = new Circle(350, 350, 1.1, 'black')
                                this.leg1 = new Circle(350, 350, 3, this.color)
                                this.leg2 = new Circle(350, 350, 3, this.color)
                                this.leg1x = new Circle(350, 350, 5, this.color)
                                this.leg2x = new Circle(350, 350, 5, this.color)
                                this.leg1link = new LineOP(this.body, this.leg1, this.color, 4)
                                this.leg2link = new LineOP(this.body, this.leg2, this.color, 4)
                                this.leg1xlink = new LineOP(this.leg1x, this.leg1, this.color, 3.5)
                                this.leg2xlink = new LineOP(this.leg2x, this.leg2, this.color, 3.5)
                                this.leg3 = new Circle(350, 350, 3, this.color)
                                this.leg4 = new Circle(350, 350, 3, this.color)
                                this.leg3x = new Circle(350, 350, 5, this.color)
                                this.leg4x = new Circle(350, 350, 5, this.color)
                                this.leg3link = new LineOP(this.body, this.leg3, this.color, 5)
                                this.leg4link = new LineOP(this.body, this.leg4, this.color, 5)
                                this.leg3xlink = new LineOP(this.leg3x, this.leg3, this.color, 3.5)
                                this.leg4xlink = new LineOP(this.leg4x, this.leg4, this.color, 3.5)
                                this.tonguelink = new LineOP(this.body, this.tongue, this.tongue.color, 2.5)
                                this.combo = 0
                                this.spindle = 1
                                this.timeratio = .95
                                this.tonguedis = 2.9
                                this.tonguemom = 0
                                this.scale = 1
                                this.scores = []
                                this.score = 0

                            } else {

                                this.flies = args.flies
                                this.color = args.color
                                this.angle = args.angle
                                this.body = new Circle(args.x, args.y, 4, args.color)
                                this.guide = new Circle(353, 350, 3, this.color)
                                this.tongue = new Circle(353, 350, 3, args.tonguecolor)
                                this.guidedis = 3
                                this.links = []
                                this.eye1 = new Circle(350, 350, 1.1, 'black')
                                this.eye2 = new Circle(350, 350, 1.1, 'black')
                                this.leg1 = new Circle(350, 350, 3, this.color)
                                this.leg2 = new Circle(350, 350, 3, this.color)
                                this.leg1x = new Circle(350, 350, 5, this.color)
                                this.leg2x = new Circle(350, 350, 5, this.color)
                                this.leg1link = new LineOP(this.body, this.leg1, this.color, 4)
                                this.leg2link = new LineOP(this.body, this.leg2, this.color, 4)
                                this.leg1xlink = new LineOP(this.leg1x, this.leg1, this.color, 3.5)
                                this.leg2xlink = new LineOP(this.leg2x, this.leg2, this.color, 3.5)
                                this.leg3 = new Circle(350, 350, 3, this.color)
                                this.leg4 = new Circle(350, 350, 3, this.color)
                                this.leg3x = new Circle(350, 350, 5, this.color)
                                this.leg4x = new Circle(350, 350, 5, this.color)
                                this.leg3link = new LineOP(this.body, this.leg3, this.color, 5)
                                this.leg4link = new LineOP(this.body, this.leg4, this.color, 5)
                                this.leg3xlink = new LineOP(this.leg3x, this.leg3, this.color, 3.5)
                                this.leg4xlink = new LineOP(this.leg4x, this.leg4, this.color, 3.5)
                                this.tonguelink = new LineOP(this.body, this.tongue, this.tongue.color, 2.5)
                                this.combo = 0
                                this.spindle = args.spindle
                                this.timeratio = args.timeratio
                                this.tonguedis = args.tonguedis
                                this.tonguemom = 0
                                this.scale = 1
                                this.scores = []
                                this.score = args.score
                            }
                        }
                        draw() {
                            for (let t = 0; t < this.scores.length; t++) {
                                this.scores[t].draw()
                            }
                            if (this.tonguedis < 3) {
                                this.tonguedis = 3
                                if (tadpoles.indexOf(this) == 0) {
                                    if (keysPressed[' '] || keysPressed['e'] || keysPressed['l']) {
                                        this.tonguemom = this.guidedis * 4
                                    }
                                }
                            }
                            this.tonguedis += this.tonguemom
                            this.tonguedis *= .93
                            this.tonguedis -= 1
                            this.tonguemom *= .91
                            if (tadpoles.indexOf(this) == 0) {
                                this.body.move()
                            }

                            if (keysPressed['w'] || !water.isPointInside(this.body)) {
                                if (keysPressed['w']) {

                                    if (tadpoles.indexOf(this) == 0) {
                                        if (water.isPointInside(this.body)) {
                                            this.timeratio = .95 + ((Math.cos(this.spindle)) * .13)
                                            this.spindle += .1
                                        }
                                    }
                                }
                            }
                            if (!water.isPointInside(this.body)) {
                                this.body.ymom += .08
                                if (keysPressed['w']) {

                                    if (tadpoles.indexOf(this) == 0) {
                                        this.body.ymom -= .05
                                    }
                                }
                            }

                            this.guide.x = (Math.cos(this.angle) * this.guidedis) + this.body.x
                            this.guide.y = (Math.sin(this.angle) * this.guidedis) + this.body.y
                            this.tongue.x = (Math.cos(this.angle) * this.tonguedis) + this.body.x
                            this.tongue.y = (Math.sin(this.angle) * this.tonguedis) + this.body.y

                            this.tongue.draw()
                            this.tonguelink.draw()
                            this.body.draw()
                            this.eye1.x = (Math.cos(this.angle - .58) * this.guidedis * .8) + this.body.x
                            this.eye1.y = (Math.sin(this.angle - .58) * this.guidedis * .8) + this.body.y
                            this.eye2.x = (Math.cos(this.angle + .58) * this.guidedis * .8) + this.body.x
                            this.eye2.y = (Math.sin(this.angle + .58) * this.guidedis * .8) + this.body.y
                            this.leg1.x = (Math.cos(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.x
                            this.leg1.y = (Math.sin(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.y
                            this.leg2.x = (Math.cos(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.x
                            this.leg2.y = (Math.sin(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4) + this.body.y
                            this.leg1x.x = (Math.cos(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.x
                            this.leg1x.y = (Math.sin(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.y
                            this.leg2x.x = (Math.cos(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.x
                            this.leg2x.y = (Math.sin(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6) + this.body.y
                            this.leg3.x = this.body.x - (Math.cos(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg3.y = this.body.y - (Math.sin(this.angle - (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg4.x = this.body.x - (Math.cos(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg4.y = this.body.y - (Math.sin(this.angle + (Math.PI * (.6666 * this.timeratio))) * this.guidedis * 4)
                            this.leg3x.x = this.body.x - (Math.cos(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg3x.y = this.body.y - (Math.sin(this.angle - (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg4x.x = this.body.x - (Math.cos(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)
                            this.leg4x.y = this.body.y - (Math.sin(this.angle + (Math.PI * (.9 * (this.timeratio * this.timeratio)))) * this.guidedis * 6)

                            if (tadpoles.indexOf(this) == 0) {
                                if (keysPressed['d']) {
                                    this.angle += .055
                                }
                                if (keysPressed['a']) {
                                    this.angle -= .055
                                }
                            }

                            if (keysPressed['w'] && water.isPointInside(this.body)) {

                                if (tadpoles.indexOf(this) == 0) {
                                    this.combo = 0
                                    this.scores = []
                                    this.body.xmom = (this.body.xmom * .95) + (((this.guide.x - this.body.x) * 1.45) * .07)
                                    this.body.ymom = (this.body.ymom * .95) + (((this.guide.y - this.body.y) * 1.45) * .07)
                                }
                            } else {
                                if (water.isPointInside(this.body)) {
                                    this.body.xmom *= .98
                                    this.body.ymom *= .98
                                }
                            }
                            // this.guide.draw()
                            this.leg1.draw()
                            this.leg2.draw()
                            this.leg1x.draw()
                            this.leg2x.draw()
                            this.leg1link.draw()
                            this.leg2link.draw()
                            this.leg1xlink.draw()
                            this.leg2xlink.draw()
                            this.leg3.draw()
                            this.leg4.draw()
                            this.leg3x.draw()
                            this.leg4x.draw()
                            this.leg3link.draw()
                            this.leg4link.draw()
                            this.leg3xlink.draw()
                            this.leg4xlink.draw()
                            this.tonguebeam = castBetween(this.body, this.tongue, (this.body.radius + 2) * 3.5, this.tongue.radius * 1.41)
                            this.tonguelink.width = this.tongue.radius
                            if(globalListener.execute == 1){
globalListener.execute = 0
                        for(let t =0;t<globalListener.num;t++){
                       this.eat(flies[0], 0)
}
                     }

                        for (let t = 0; t < flies.length; t++) {
                                if (flies[t].link.squareDistance() < (700 * 700) / tadpoles[0].scale) {
                                    if (this.tonguebeam.doesPerimeterTouch(flies[t].body)) {
                                        this.eat(flies[t], t)
                                        t--
                                    }
                                }
                            }
                            if (floor.isPointInside(this.body)) {
                                this.body.ymom *= -1.5

                                if (tadpoles.indexOf(this) == 0) {
                                    this.body.move()
                                }
                            }


                            this.foot1 = new GlideFoot(this.leg1x, this.leg1xlink.angle(), .5)
                            this.foot1.draw()

                            this.foot1 = new GlideFoot(this.leg2x, this.leg2xlink.angle(), .5)
                            this.foot1.draw()

                            this.foot1 = new GlideFoot(this.leg3x, this.leg3xlink.angle(), .5)
                            this.foot1.draw()

                            this.foot1 = new GlideFoot(this.leg4x, this.leg4xlink.angle(), .5)
                            this.foot1.draw()

                            this.eye1.draw()
                            this.eye2.draw()
                        }
                        eat(fly, t) {
                            this.flies++
                                this.combo++
                                this.score += this.combo
                            this.scores.push(new Text(fly.body.x, fly.body.y, this.combo))
                            flies.splice(t, 1)
                            if (this.body.radius < 30) {










                                this.guidedis = 3 + (Math.min(this.flies, 1200) * .12345) * .31
                                this.body.radius = 4 + (Math.min(this.flies, 1200) * .12345) * .28
                                this.eye2.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.eye1.radius = 1.1 + (Math.min(this.flies, 1200) * .12345) * .03
                                this.leg1.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg2.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg3.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg4.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .15
                                this.leg1x.radius = 5 + (Math.min(this.flies, 1200) * .12345) * .19
                                this.leg2x.radius = 5 + (Math.min(this.flies, 1200) * .12345) * .19
                                this.leg3x.radius = 5 + (Math.min(this.flies, 1200) * .12345) * .19
                                this.leg4x.radius = 5 + (Math.min(this.flies, 1200) * .12345) * .19
                                this.tongue.radius = 3 + (Math.min(this.flies, 1200) * .12345) * .19

                                this.leg1link.width = 5 + (Math.min(this.flies, 1200) * .12345) * .22
                                this.leg2link.width = 5 + (Math.min(this.flies, 1200) * .12345) * .22
                                this.leg2xlink.width = 3.5 + (Math.min(this.flies, 1200) * .12345) * .22
                                this.leg1xlink.width = 3.5 + (Math.min(this.flies, 1200) * .12345) * .22

                                this.leg3link.width = 5 + (Math.min(this.flies, 1200) * .12345) * .22
                                this.leg4link.width = 5 + (Math.min(this.flies, 1200) * .12345) * .22
                                this.leg3xlink.width = 3.5 + (Math.min(this.flies, 1200) * .12345) * .22
                                this.leg4xlink.width = 3.5 + (Math.min(this.flies, 1200) * .12345) * .22
                                if (tadpoles.indexOf(this) == 0) {
                                    canvas_context.translate(tadpoles[0].body.x, tadpoles[0].body.y)
                                    canvas_context.scale(1 / this.scale, 1 / this.scale)
                                    this.scale *= .9989
                                    canvas_context.scale(this.scale, this.scale)
                                    canvas_context.translate(-tadpoles[0].body.x, -tadpoles[0].body.y)
                                }
                                flies.push(new Fly())
                            }
                        }
                    }

                    class Text {
                        constructor(x, y, num) {
                            this.x = x
                            this.y = y
                            this.num = num
                            this.color = `rgb(${255}, ${255-num*10}, ${num*2})`
                        }
                        draw() {
                            canvas_context.fillStyle = this.color
                            let size = 20 / tadpoles[0].scale
                            canvas_context.font = `${size}px arial`
                            canvas_context.fillText(this.num, this.x, this.y)
                        }
                    }

                    class Fly {
                        constructor() {
                            this.body = new Circle(-125300 + (Math.random() * 250000), -16000 + (Math.random() * 16350), 3, getRandomLightColor())
                            this.link = new LineOP(this.body, tadpoles[0].body, "transparent", 0)
                            this.mag = Math.random() * 5
                        }
                        draw() {
                            this.body.x += (Math.random() - .5) * this.mag
                            this.body.y += (Math.random() - .5) * this.mag
                            if (water.isPointInside(this.body)) {

                                this.body.y = -10
                            }
                            this.body.draw()
                        }
                    }


                    tadpoles[0] = new GlideFrog()
                    let flies = []
                    let floor = new Rectangle(-1000000, 2350, 2000000, 100000, "#FFFFAA")

                    let timed = 0
                    let water = new Rectangle(-1000000, 350, 2000000, 100000, "#00AAFF44")
                    let grader = new RectangleGrad(-1000000, -100000, 2000000, 200000, "red")

                    let time = new Date()
                    let moment = time.getTime()
                    let buttonzenb = new Rectangle(100, 100, 190, 100, "#00ff00")
                    let buttonzeng = new Rectangle(100, 250, 190, 100, "#00ff00")
                    let buttonzenf = new Rectangle(100, 400, 190, 100, "#00ff00")
                    let buttonzenp = new Rectangle(100, 550, 190, 100, "#00ff00")
                    let buttontimeb = new Rectangle(490, 100, 190, 100, "red")
                    let buttontimeg = new Rectangle(490, 250, 190, 100, "red")
                    let buttontimef = new Rectangle(490, 400, 190, 100, "red")
                    let buttontimep = new Rectangle(490, 550, 199, 100, "red")
                    let scorer = 0

                    let mute = 0

                    let frogIds = [frogid]
                    FrogSocketize(ws)

                    function FrogSocketize(ws) {

                        // ws.addEventListener("open", () => {
                        ws.addEventListener("message", ({
                            data
                        }) => {
                            if (JSON.parse(data).flies >= 0) {
                                // //console.log("hit")

                                if (frogIds.includes(JSON.parse(data).id)) {
                                    if (JSON.parse(data).frog == 1) {
                                        if (JSON.parse(data).type == 1) {
                                            tadpoles[frogIds.indexOf(JSON.parse(data).id)] = new BullFrog(JSON.parse(data))
                                        } else if (JSON.parse(data).type == 2) {
                                            tadpoles[frogIds.indexOf(JSON.parse(data).id)] = new GlideFrog(JSON.parse(data))
                                        } else if (JSON.parse(data).type == 3) {
                                            tadpoles[frogIds.indexOf(JSON.parse(data).id)] = new Frog(JSON.parse(data))
                                        } else if (JSON.parse(data).type == 4) {
                                            tadpoles[frogIds.indexOf(JSON.parse(data).id)] = new PygmyFrog(JSON.parse(data))
                                        }
                                    }

                                } else {

                                    frogIds.push(JSON.parse(data).id)

                                    if (JSON.parse(data).frog == 1) {
                                        if (JSON.parse(data).type == 1) {
                                            tadpoles[frogIds.length - 1] = new BullFrog(JSON.parse(data))
                                        } else if (JSON.parse(data).type == 2) {
                                            tadpoles[frogIds.length - 1] = new GlideFrog(JSON.parse(data))
                                        } else if (JSON.parse(data).type == 3) {
                                            tadpoles[frogIds.length - 1] = new Frog(JSON.parse(data))
                                        } else if (JSON.parse(data).type == 4) {
                                            tadpoles[frogIds.length - 1] = new PygmyFrog(JSON.parse(data))
                                        }
                                    }
                                }


                                // //console.log(tadpoles)
                            } else {



                                if (booter.running == 0) {
                                    return
                                }
                                textcanvas_context.font = "12px arial"
                                textcanvas_context.fillStyle = JSON.parse(data).color
                                if (typeof JSON.parse(data).name != "undefined") {


                                    textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)
                                    let ypointer = 300 + textscroll
                                    let stoarr = (`(${JSON.parse(data).name}) ` + ' ' + JSON.parse(data).text).split('')
                                    let stostring = ''
                                    for (let t = 0; t < stoarr.length; t++) {
                                        const width = textcanvas_context.measureText(stostring + '' + stoarr[t]).width
                                        if (width > textcanvas.width - 12) {
                                            textcanvas_context.fillText(stostring + '' + stoarr[t], 0, ypointer)
                                            ypointer += 12
                                            textscroll += 12
                                            stostring = ''
                                        } else {
                                            stostring = stostring + "" + stoarr[t]
                                            if (t == stoarr.length - 1) {

                                                textscroll += 12
                                                textcanvas_context.fillText(stostring, 0, ypointer)
                                            }
                                        }
                                    }


                                    // textcanvas_context.fillText(`(${JSON.parse(data).name}) `+ JSON.parse(data).text, 0, 300+textscroll)

                                    console.log(JSON.parse(data).measure)
                                        // textscroll += JSON.parse(data).measure
                                }
                                // textcanvas_context.translate(0, 12)
                                // textcanvas.translate(0, 12)
                            }
                        })

                        let json = {}
                        json.connecting = 1

                        ws.send(JSON.stringify(json))
                            // })

                    }

                    function main() {
                        if (booter.running == 0) {
                            return
                        }
                        windowspares[booter.index] = canvas
                            // if(keysPressed['Escape']){
                            //     canvas_context.clearRect(-1000000, -10000000, canvas.width*1000000, canvas.height*1000000)  
                            //     timed = 0
                            // }
                            // if(mute == 0){
                            //     song.play()
                            // }else{
                            //     song.pause()
                            // }

                        if (keysPressed['m']) {
                            mute = 1
                        }
                        if (keysPressed['p']) {
                            mute = 0
                        }
                        if (timed != 0) {

                            canvas_context.clearRect(-1000000, -10000000, canvas.width * 1000000, canvas.height * 1000000) // refreshes the image



                            grader.draw()
                            gamepadAPI.update() //checks for button presses/stick movement on the connected controller)
                                // // game code goes here
                            for (let t = 0; t < tadpoles.length; t++) {
                                if (t == 0) {
                                    if (ws.readyState == 1) {
                                        let json = {}
                                        json.frog = 1
                                        json.x = tadpoles[0].body.x
                                        json.color = tadpoles[0].color
                                        json.id = tadpoles[0].id
                                        json.score = tadpoles[0].score
                                        json.type = tadpoles[0].type
                                        json.y = tadpoles[0].body.y
                                        json.angle = tadpoles[0].angle
                                        json.flies = tadpoles[0].flies
                                        json.spindle = tadpoles[0].spindle
                                        json.timeratio = tadpoles[0].timeratio
                                        json.tonguedis = tadpoles[0].tonguedis
                                        json.tonguecolor = tadpoles[0].tongue.color
                                        ws.send(JSON.stringify(json))
                                    }
                                } else {
                                    //   //console.log(tadpoles[t])
                                }
                                tadpoles[t].draw()
                            }
                    //         if(globalListener.execute == 1){
globalListener.execute = 0
                    //     this.flies = globalListener.num
                    //    this.eat(flies[0], 0)
                    //  }

                        for (let t = 0; t < flies.length; t++) {
                                if (flies[t].link.squareDistance() < (700 * 700) / tadpoles[0].scale) {
                                    flies[t].draw()
                                }
                            }
                            water.draw()
                            floor.draw()

                            let size = 20 / tadpoles[0].scale
                            canvas_context.font = `${size}px arial`
                            for (let t = 0; t < tadpoles.length; t++) {

                                canvas_context.fillStyle = tadpoles[t].body.color
                                canvas_context.fillText(tadpoles[t].score, tadpoles[0].body.x - (330 / tadpoles[0].scale), tadpoles[0].body.y - (330 / tadpoles[0].scale) + (t * size))
                            }

                            if (timed == 1) {
                                let time = new Date()
                                if (time.getTime() - moment > 300000) {
                                    canvas_context.fillText("You got " + scorer, tadpoles[0].body.x - (330 / tadpoles[0].scale), tadpoles[0].body.y - (310 / tadpoles[0].scale))

                                } else {
                                    scorer = tadpoles[0].score
                                    canvas_context.fillText(Math.max(0, Math.round((300000 - (time.getTime() - moment)) / 1000)), tadpoles[0].body.x - (330 / tadpoles[0].scale), tadpoles[0].body.y - (310 / tadpoles[0].scale))
                                }
                            }
                        } else {
                            // buttontimeb.draw()
                            buttonzenb.draw()
                                // buttontimeg.draw()
                            buttonzeng.draw()
                                // buttontimef.draw()
                            buttonzenf.draw()
                                // buttontimep.draw()
                            buttonzenp.draw()
                            let size = 20 / tadpoles[0].scale
                            canvas_context.font = `${size}px arial`
                            canvas_context.fillStyle = "black"
                            canvas_context.fillText("Play Bullfrog", 120, 150)
                            canvas_context.fillStyle = "white"
                                // canvas_context.fillText("Timed Frog", 520, 450)
                            canvas_context.fillStyle = "black"
                            canvas_context.fillText("Play Glidefrog", 120, 300)
                            canvas_context.fillStyle = "white"
                                // canvas_context.fillText("Timed Glidefrog", 520, 300)
                            canvas_context.fillStyle = "black"
                            canvas_context.fillText("Play Frog", 120, 450)
                            canvas_context.fillStyle = "white"
                                // canvas_context.fillText("Timed Bullfrog", 520, 150)

                            canvas_context.fillStyle = "black"
                            canvas_context.fillText("Play Pygmy Frog", 120, 600)
                            canvas_context.fillStyle = "white"
                                // canvas_context.fillText("Timed Pygmy Frog", 510, 600)

                        }
                    }

                } else if (booter.index == 1) {


                    this.running = 1

                    const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
                    for (let t = 0; t < 1; t++) {
                        squaretable[`${t}`] = Math.sqrt(t)
                        if (t > 999) {
                            t += 9
                        }
                    }
                    const gamepadAPI = {
                        controller: {},
                        turbo: true,
                        connect: function(evt) {
                            if (navigator.getGamepads()[0] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[1] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[2] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            } else if (navigator.getGamepads()[3] != null) {
                                gamepadAPI.controller = navigator.getGamepads()[0]
                                gamepadAPI.turbo = true;
                            }
                            for (let i = 0; i < gamepads.length; i++) {
                                if (gamepads[i] === null) {
                                    continue;
                                }
                                if (!gamepads[i].connected) {
                                    continue;
                                }
                            }
                        },
                        disconnect: function(evt) {
                            gamepadAPI.turbo = false;
                            delete gamepadAPI.controller;
                        },
                        update: function() {
                            gamepadAPI.controller = navigator.getGamepads()[0]
                            gamepadAPI.buttonsCache = []; // clear the buttons cache
                            for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) { // move the buttons status from the previous frame to the cache
                                gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
                            }
                            gamepadAPI.buttonsStatus = []; // clear the buttons status
                            var c = gamepadAPI.controller || {}; // get the gamepad object
                            var pressed = [];
                            if (c.buttons) {
                                for (var b = 0, t = c.buttons.length; b < t; b++) { // loop through buttons and push the pressed ones to the array
                                    if (c.buttons[b].pressed) {
                                        pressed.push(gamepadAPI.buttons[b]);
                                    }
                                }
                            }
                            var axes = [];
                            if (c.axes) {
                                for (var a = 0, x = c.axes.length; a < x; a++) { // loop through axes and push their values to the array
                                    axes.push(c.axes[a].toFixed(2));
                                }
                            }
                            gamepadAPI.axesStatus = axes; // assign received values
                            gamepadAPI.buttonsStatus = pressed;
                            // //console.log(pressed); // return buttons for debugging purposes
                            return pressed;
                        },
                        buttonPressed: function(button, hold) {
                            var newPress = false;
                            for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) { // loop through pressed buttons
                                if (gamepadAPI.buttonsStatus[i] == button) { // if we found the button we're looking for...
                                    newPress = true; // set the boolean variable to true
                                    if (!hold) { // if we want to check the single press
                                        for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) { // loop through the cached states from the previous frame
                                            if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                                newPress = false;
                                            }
                                        }
                                    }
                                }
                            }
                            return newPress;
                        },
                        buttons: [
                            'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
                        ],
                        buttonsCache: [],
                        buttonsStatus: [],
                        axesStatus: []
                    };
                    let canvas
                    let canvas_context
                    let keysPressed = {}
                    let FLEX_engine
                        // let TIP_engine = {}
                    let XS_engine
                    let YS_engine
                        // TIP_engine.x = 350
                        // TIP_engine.y = 350
                    class Point {
                        constructor(x, y) {
                            this.x = x
                            this.y = y
                            this.radius = 0
                        }
                        pointDistance(point) {
                            return (new LineOP(this, point, "transparent", 0)).hypotenuse()
                        }
                    }

                    class Vector { // vector math and physics if you prefer this over vector components on circles
                        constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
                            this.xmom = xmom
                            this.ymom = ymom
                            this.object = object
                        }
                        isToward(point) {
                            let link = new LineOP(this.object, point)
                            let dis1 = link.sqrDis()
                            let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                            let link2 = new LineOP(dummy, point)
                            let dis2 = link2.sqrDis()
                            if (dis2 < dis1) {
                                return true
                            } else {
                                return false
                            }
                        }
                        rotate(angleGoal) {
                            let link = new Line(this.xmom, this.ymom, 0, 0)
                            let length = link.hypotenuse()
                            let x = (length * Math.cos(angleGoal))
                            let y = (length * Math.sin(angleGoal))
                            this.xmom = x
                            this.ymom = y
                        }
                        magnitude() {
                            return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
                        }
                        normalize(size = 1) {
                            let magnitude = this.magnitude()
                            this.xmom /= magnitude
                            this.ymom /= magnitude
                            this.xmom *= size
                            this.ymom *= size
                        }
                        multiply(vect) {
                            let point = new Point(0, 0)
                            let end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
                            return point.pointDistance(end)
                        }
                        add(vect) {
                            return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
                        }
                        subtract(vect) {
                            return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
                        }
                        divide(vect) {
                            return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
                        }
                        draw() {
                            let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                            let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
                            link.draw()
                        }
                    }
                    class Line {
                        constructor(x, y, x2, y2, color, width) {
                            this.x1 = x
                            this.y1 = y
                            this.x2 = x2
                            this.y2 = y2
                            this.color = color
                            this.width = width
                        }
                        angle() {
                            return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
                        }
                        squareDistance() {
                            let xdif = this.x1 - this.x2
                            let ydif = this.y1 - this.y2
                            let squareDistance = (xdif * xdif) + (ydif * ydif)
                            return squareDistance
                        }
                        hypotenuse() {
                            let xdif = this.x1 - this.x2
                            let ydif = this.y1 - this.y2
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x1, this.y1)
                            canvas_context.lineTo(this.x2, this.y2)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class LineOP {
                        constructor(object, target, color, width) {
                            this.object = object
                            this.target = target
                            this.color = color
                            this.width = width
                        }
                        squareDistance() {
                            let xdif = this.object.x - this.target.x
                            let ydif = this.object.y - this.target.y
                            let squareDistance = (xdif * xdif) + (ydif * ydif)
                            return squareDistance
                        }
                        hypotenuse() {
                            let xdif = this.object.x - this.target.x
                            let ydif = this.object.y - this.target.y
                            let hypotenuse = (xdif * xdif) + (ydif * ydif)
                            if (hypotenuse < 10000000 - 1) {
                                if (hypotenuse > 1000) {
                                    return squaretable[`${Math.round(10*Math.round((hypotenuse*.1)))}`]
                                } else {
                                    return squaretable[`${Math.round(hypotenuse)}`]
                                }
                            } else {
                                return Math.sqrt(hypotenuse)
                            }
                        }
                        angle() {
                            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
                        }
                        draw() {
                            let linewidthstorage = canvas_context.lineWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.lineWidth = this.width
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.object.x, this.object.y)
                            canvas_context.lineTo(this.target.x, this.target.y)
                            canvas_context.stroke()
                            canvas_context.lineWidth = linewidthstorage
                        }
                    }
                    class Triangle {
                        constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
                            this.x = x
                            this.y = y
                            this.color = color
                            this.length = length
                            this.x1 = this.x + this.length * leg1Ratio
                            this.x2 = this.x - this.length * leg2Ratio
                            this.tip = this.y - this.length * heightRatio
                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                            this.fill = fill
                            this.stroke = strokeWidth
                        }
                        draw() {
                            canvas_context.strokeStyle = this.color
                            canvas_context.stokeWidth = this.stroke
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.x, this.y)
                            canvas_context.lineTo(this.x1, this.y)
                            canvas_context.lineTo(this.x, this.tip)
                            canvas_context.lineTo(this.x2, this.y)
                            canvas_context.lineTo(this.x, this.y)
                            if (this.fill == 1) {
                                canvas_context.fill()
                            }
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                        isPointInside(point) {
                            if (point.x <= this.x1) {
                                if (point.y >= this.tip) {
                                    if (point.y <= this.y) {
                                        if (point.x >= this.x2) {
                                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                                            this.basey = point.y - this.tip
                                            this.basex = point.x - this.x
                                            if (this.basex == 0) {
                                                return true
                                            }
                                            this.slope = this.basey / this.basex
                                            if (this.slope >= this.accept1) {
                                                return true
                                            } else if (this.slope <= this.accept2) {
                                                return true
                                            }
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Rectangle {
                        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
                            this.x = x
                            this.y = y
                            this.height = height
                            this.width = width
                            this.color = color
                            this.xmom = 0
                            this.ymom = 0
                            this.stroke = stroke
                            this.strokeWidth = strokeWidth
                            this.fill = fill
                        }
                        draw() {
                            canvas_context.fillStyle = this.color
                            canvas_context.fillRect(this.x, this.y, this.width, this.height)
                        }
                        move() {
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        isPointInside(point) {
                            if (point.x >= this.x) {
                                if (point.y >= this.y) {
                                    if (point.x <= this.x + this.width) {
                                        if (point.y <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            if (point.x + point.radius >= this.x) {
                                if (point.y + point.radius >= this.y) {
                                    if (point.x - point.radius <= this.x + this.width) {
                                        if (point.y - point.radius <= this.y + this.height) {
                                            return true
                                        }
                                    }
                                }
                            }
                            return false
                        }
                    }
                    class Circle {
                        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                            this.x = x
                            this.y = y
                            this.radius = radius
                            this.color = color
                            this.xmom = xmom
                            this.ymom = ymom
                            this.friction = friction
                            this.reflect = reflect
                            this.strokeWidth = strokeWidth
                            this.strokeColor = strokeColor
                        }
                        draw() {
                            canvas_context.lineWidth = this.strokeWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath();
                            if (this.radius > 0) {
                                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                                canvas_context.fillStyle = this.color
                                canvas_context.fill()
                                canvas_context.stroke();
                            } else {
                                // //console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                            }
                        }

                        moveloop() {
                            if (this.x < 0) {
                                this.x = canvas.width - .0001
                            }
                            if (this.x > canvas.width) {
                                this.x = .001
                            }
                            if (this.y < 0) {
                                this.y = canvas.height - .0001
                            }
                            if (this.y > canvas.height) {
                                this.y = .001
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        unmove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        frictiveMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            this.xmom *= this.friction
                            this.ymom *= this.friction
                        }
                        frictiveunMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.xmom /= this.friction
                            this.ymom /= this.friction
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        isPointInside(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                                return true
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                                return true
                            }
                            return false
                        }
                    }
                    class CircleRing {
                        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                            this.x = x
                            this.y = y
                            this.radius = radius
                            this.color = color
                            this.xmom = xmom
                            this.ymom = ymom
                            this.friction = friction
                            this.reflect = reflect
                            this.strokeWidth = 10
                            this.strokeColor = strokeColor
                        }
                        draw() {
                            canvas_context.lineWidth = this.strokeWidth
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath();
                            if (this.radius > 0) {
                                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                                canvas_context.fillStyle = this.color
                                canvas_context.fill()
                                canvas_context.stroke();
                            } else {
                                //console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                            }
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                        }
                        unmove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        frictiveMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.x += this.xmom
                            this.y += this.ymom
                            this.xmom *= this.friction
                            this.ymom *= this.friction
                        }
                        frictiveunMove() {
                            if (this.reflect == 1) {
                                if (this.x + this.radius > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y + this.radius > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.x - this.radius < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.y - this.radius < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.xmom /= this.friction
                            this.ymom /= this.friction
                            this.x -= this.xmom
                            this.y -= this.ymom
                        }
                        isPointInside(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                                return true
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            this.areaY = point.y - this.y
                            this.areaX = point.x - this.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                                return true
                            }
                            return false
                        }
                    }
                    class Polygon {
                        constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
                            if (sides < 2) {
                                sides = 2
                            }
                            this.reflect = reflect
                            this.xmom = xmom
                            this.ymom = ymom
                            this.body = new Circle(x, y, size - (size * .293), "transparent")
                            this.nodes = []
                            this.angle = angle
                            this.size = size
                            this.color = color
                            this.angleIncrement = (Math.PI * 2) / sides
                            this.sides = sides
                            for (let t = 0; t < sides; t++) {
                                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                this.nodes.push(node)
                                this.angle += this.angleIncrement
                            }
                        }
                        isPointInside(point) { // rough approximation
                            this.body.radius = this.size - (this.size * .293)
                            if (this.sides <= 2) {
                                return false
                            }
                            this.areaY = point.y - this.body.y
                            this.areaX = point.x - this.body.x
                            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                                return true
                            }
                            return false
                        }
                        move() {
                            if (this.reflect == 1) {
                                if (this.body.x > canvas.width) {
                                    if (this.xmom > 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y > canvas.height) {
                                    if (this.ymom > 0) {
                                        this.ymom *= -1
                                    }
                                }
                                if (this.body.x < 0) {
                                    if (this.xmom < 0) {
                                        this.xmom *= -1
                                    }
                                }
                                if (this.body.y < 0) {
                                    if (this.ymom < 0) {
                                        this.ymom *= -1
                                    }
                                }
                            }
                            this.body.x += this.xmom
                            this.body.y += this.ymom
                        }
                        draw(nodes) {
                            this.nodes = [...nodes]
                                // this.nodes = []
                                // this.angleIncrement = (Math.PI * 2) / this.sides
                                // this.body.radius = this.size - (this.size * .293)
                                // for (let t = 0; t < this.sides; t++) {
                                //     let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                                //     this.nodes.push(node)
                                //     this.angle += this.angleIncrement
                                // }
                            canvas_context.strokeStyle = this.color
                            canvas_context.fillStyle = this.color
                            canvas_context.lineWidth = 0
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
                            for (let t = 1; t < this.nodes.length; t++) {
                                canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
                            }
                            canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
                            canvas_context.fill()
                            canvas_context.stroke()
                            canvas_context.closePath()
                        }
                    }
                    class Shape {
                        constructor(shapes) {
                            this.shapes = shapes
                        }
                        draw() {
                            for (let t = 0; t < this.shapes.length; t++) {
                                this.shapes[t].draw()
                            }
                        }
                        isPointInside(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].isPointInside(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        doesPerimeterTouch(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].doesPerimeterTouch(point)) {
                                    return true
                                }
                            }
                            return false
                        }
                        innerShape(point) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (this.shapes[t].doesPerimeterTouch(point)) {
                                    return this.shapes[t]
                                }
                            }
                            return false
                        }
                        isInsideOf(box) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (box.isPointInside(this.shapes[t])) {
                                    return true
                                }
                            }
                            return false
                        }
                        adjustByFromDisplacement(x, y) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (typeof this.shapes[t].fromRatio == "number") {
                                    this.shapes[t].x += x * this.shapes[t].fromRatio
                                    this.shapes[t].y += y * this.shapes[t].fromRatio
                                }
                            }
                        }
                        adjustByToDisplacement(x, y) {
                            for (let t = 0; t < this.shapes.length; t++) {
                                if (typeof this.shapes[t].toRatio == "number") {
                                    this.shapes[t].x += x * this.shapes[t].toRatio
                                    this.shapes[t].y += y * this.shapes[t].toRatio
                                }
                            }
                        }
                        mixIn(arr) {
                            for (let t = 0; t < arr.length; t++) {
                                for (let k = 0; k < arr[t].shapes.length; k++) {
                                    this.shapes.push(arr[t].shapes[k])
                                }
                            }
                        }
                        push(object) {
                            this.shapes.push(object)
                        }
                    }

                    class Spring {
                        constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
                            if (body == 0) {
                                this.body = new Circle(x, y, radius, color)
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            } else {
                                this.body = body
                                this.anchor = new Circle(x, y, radius, color)
                                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                                this.length = length
                            }
                            this.gravity = gravity
                            this.width = width
                        }
                        balance() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            if (this.beam.hypotenuse() < this.length) {
                                this.body.xmom += (this.body.x - this.anchor.x) / this.length
                                this.body.ymom += (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
                            } else {
                                this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                                this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                                this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                                this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
                            }
                            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
                        }
                        draw() {
                            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                            this.beam.draw()
                            this.body.draw()
                            this.anchor.draw()
                        }
                        move() {
                            this.anchor.ymom += this.gravity
                            this.anchor.move()
                        }

                    }
                    class SpringOP {
                        constructor(body, anchor, length, width = 3, color = body.color) {
                            this.body = body
                            this.anchor = anchor
                            this.beam = new LineOP(body, anchor, color, width)
                            this.length = length
                        }
                        balance() {
                            if (this.beam.hypotenuse() < this.length) {
                                this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
                                this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
                                this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
                                this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
                            } else if (this.beam.hypotenuse() > this.length) {
                                this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
                                this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
                                this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
                                this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
                            }

                            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
                        }
                        draw() {
                            this.beam.draw()
                        }
                        move() {
                            //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
                        }
                    }

                    class Color {
                        constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
                            this.hue = baseColor
                            if (red != -1 && green != -1 && blue != -1) {
                                this.r = red
                                this.g = green
                                this.b = blue
                                if (alpha != 1) {
                                    if (alpha < 1) {
                                        this.alpha = alpha
                                    } else {
                                        this.alpha = alpha / 255
                                        if (this.alpha > 1) {
                                            this.alpha = 1
                                        }
                                    }
                                }
                                if (this.r > 255) {
                                    this.r = 255
                                }
                                if (this.g > 255) {
                                    this.g = 255
                                }
                                if (this.b > 255) {
                                    this.b = 255
                                }
                                if (this.r < 0) {
                                    this.r = 0
                                }
                                if (this.g < 0) {
                                    this.g = 0
                                }
                                if (this.b < 0) {
                                    this.b = 0
                                }
                            } else {
                                this.r = 0
                                this.g = 0
                                this.b = 0
                            }
                        }
                        normalize() {
                            if (this.r > 255) {
                                this.r = 255
                            }
                            if (this.g > 255) {
                                this.g = 255
                            }
                            if (this.b > 255) {
                                this.b = 255
                            }
                            if (this.r < 0) {
                                this.r = 0
                            }
                            if (this.g < 0) {
                                this.g = 0
                            }
                            if (this.b < 0) {
                                this.b = 0
                            }
                        }
                        randomLight() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12) + 4)];
                            }
                            var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
                            return color;
                        }
                        randomDark() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 12))];
                            }
                            var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
                            return color;
                        }
                        random() {
                            var letters = '0123456789ABCDEF';
                            var hash = '#';
                            for (var i = 0; i < 6; i++) {
                                hash += letters[(Math.floor(Math.random() * 16))];
                            }
                            var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
                            return color;
                        }
                    }
                    class Softbody { //buggy, spins in place
                        constructor(x, y, radius, color, size, members = 10, memberLength = 5, force = 10, gravity = 0) {
                            this.springs = []
                            this.pin = new Circle(x, y, radius, color)
                            this.points = []
                            this.flop = 0
                            let angle = 0
                            this.size = size
                            let line = new Line((Math.cos(angle) * size), (Math.sin(angle) * size), (Math.cos(angle + ((Math.PI * 2) / members)) * size), (Math.sin(angle + ((Math.PI * 2) / members)) * size))
                            let distance = line.hypotenuse()
                            for (let t = 0; t < members; t++) {
                                let circ = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), radius, color)
                                circ.reflect = 1
                                circ.bigbody = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), distance, color)
                                circ.draw()
                                circ.touch = []
                                this.points.push(circ)
                                angle += ((Math.PI * 2) / members)
                            }

                            for (let t = 0; t < this.points.length; t++) {
                                for (let k = 0; k < this.points.length; k++) {
                                    if (t != k) {
                                        if (this.points[k].bigbody.doesPerimeterTouch(this.points[t])) {
                                            if (!this.points[k].touch.includes(t) && !this.points[t].touch.includes(k)) {
                                                let spring = new SpringOP(this.points[k], this.points[t], (size * Math.PI) / members, 2, color)
                                                this.points[k].touch.push(t)
                                                this.points[t].touch.push(k)
                                                this.springs.push(spring)
                                                spring.beam.draw()
                                            }
                                        }
                                    }
                                }
                            }

                            // //console.log(this)

                            // this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
                            // this.springs.push(this.spring)
                            // for (let k = 0; k < members; k++) {
                            //     this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
                            //     if (k < members - 1) {
                            //         this.springs.push(this.spring)
                            //     } else {
                            //         this.spring.anchor = this.pin
                            //         this.springs.push(this.spring)
                            //     }
                            // }
                            this.forceConstant = force
                            this.centroid = new Circle(0, 0, 10, "red")
                        }
                        circularize() {
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.springs.length; s++) {
                                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                            this.angle = 0
                            this.angleIncrement = (Math.PI * 2) / this.springs.length
                            for (let t = 0; t < this.points.length; t++) {
                                this.points[t].x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                                this.points[t].y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                                this.angle += this.angleIncrement
                            }
                        }
                        balance() {
                            this.xpoint = 0
                            this.ypoint = 0
                            for (let s = 0; s < this.points.length; s++) {
                                this.xpoint += (this.points[s].x / this.points.length)
                                this.ypoint += (this.points[s].y / this.points.length)
                            }
                            this.centroid.x = this.xpoint
                            this.centroid.y = this.ypoint
                                // this.centroid.x += TIP_engine.x / this.points.length
                                // this.centroid.y += TIP_engine.y / this.points.length
                            for (let s = 0; s < this.points.length; s++) {
                                this.link = new LineOP(this.points[s], this.centroid, 0, "transparent")
                                if (this.link.hypotenuse() != 0) {

                                    if (this.size < this.link.hypotenuse()) {
                                        this.points[s].xmom -= (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                        this.points[s].ymom -= (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                    } else {
                                        this.points[s].xmom += (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                        this.points[s].ymom += (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                                    }

                                    // this.points[s].xmom += (((this.points[s].x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                                    // this.points[s].ymom += (((this.points[s].y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                                }
                            }
                            if (this.flop % 2 == 0) {
                                for (let s = 0; s < this.springs.length; s++) {
                                    this.springs[s].balance()
                                }
                            } else {
                                for (let s = this.springs.length - 1; s >= 0; s--) {
                                    this.springs[s].balance()
                                }
                            }
                            for (let s = 0; s < this.points.length; s++) {
                                this.points[s].move()
                                this.points[s].draw()
                            }
                            for (let s = 0; s < this.springs.length; s++) {
                                this.springs[s].draw()
                            }
                            this.centroid.draw()
                        }
                    }
                    class Observer {
                        constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
                            this.body = new Circle(x, y, radius, color)
                            this.color = color
                            this.ray = []
                            this.rayrange = range
                            this.globalangle = Math.PI
                            this.gapangle = angle
                            this.currentangle = 0
                            this.obstacles = []
                            this.raymake = rays
                        }
                        beam() {
                            this.currentangle = this.gapangle / 2
                            for (let k = 0; k < this.raymake; k++) {
                                this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                                let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                                ray.collided = 0
                                ray.lifespan = this.rayrange - 1
                                this.ray.push(ray)
                            }
                            for (let f = 0; f < this.rayrange; f++) {
                                for (let t = 0; t < this.ray.length; t++) {
                                    if (this.ray[t].collided < 1) {
                                        this.ray[t].move()
                                        for (let q = 0; q < this.obstacles.length; q++) {
                                            if (this.obstacles[q].isPointInside(this.ray[t])) {
                                                this.ray[t].collided = 1
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        draw() {
                            this.beam()
                            this.body.draw()
                            canvas_context.lineWidth = 1
                            canvas_context.fillStyle = this.color
                            canvas_context.strokeStyle = this.color
                            canvas_context.beginPath()
                            canvas_context.moveTo(this.body.x, this.body.y)
                            for (let y = 0; y < this.ray.length; y++) {
                                canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                                canvas_context.lineTo(this.body.x, this.body.y)
                            }
                            canvas_context.stroke()
                            canvas_context.fill()
                            this.ray = []
                        }
                    }

                    function setUp(canvas_pass, style = "#000000") {
                        canvas = canvas_pass
                        canvas_context = canvas.getContext('2d');
                        canvas.style.background = style
                        booter.main = main
                        document.addEventListener('keydown', (event) => {
                            keysPressed[event.key] = true;
                        });
                        document.addEventListener('keyup', (event) => {
                            delete keysPressed[event.key];
                        });
                        window.addEventListener('pointerdown', e => {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            // TIP_engine.x = XS_engine
                            // TIP_engine.y = YS_engine
                            // TIP_engine.body = TIP_engine
                            // example usage: if(object.isPointInside(TIP_engine)){ take action }
                        });
                        window.addEventListener('pointermove', continued_stimuli);

                        window.addEventListener('pointerup', e => {
                            // window.removeEventListener("pointermove", continued_stimuli);
                        })

                        function continued_stimuli(e) {
                            FLEX_engine = canvas.getBoundingClientRect();
                            XS_engine = e.clientX - FLEX_engine.left;
                            YS_engine = e.clientY - FLEX_engine.top;
                            // TIP_engine.x = XS_engine
                            // TIP_engine.y = YS_engine
                            // TIP_engine.body = TIP_engine
                        }
                    }

                    function gamepad_control(object, speed = 1) { // basic control for objects using the controler
                        //         //console.log(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
                        if (typeof object.body != 'undefined') {
                            if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                                if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                                    object.body.x += (gamepadAPI.axesStatus[0] * speed)
                                    object.body.y += (gamepadAPI.axesStatus[1] * speed)
                                }
                            }
                        } else if (typeof object != 'undefined') {
                            if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                                if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                                    object.x += (gamepadAPI.axesStatus[0] * speed)
                                    object.y += (gamepadAPI.axesStatus[1] * speed)
                                }
                            }
                        }
                    }

                    function control(object, speed = 1) { // basic control for objects
                        if (typeof object.body != 'undefined') {
                            if (keysPressed['w']) {
                                object.body.y -= speed
                            }
                            if (keysPressed['d']) {
                                object.body.x += speed
                            }
                            if (keysPressed['s']) {
                                object.body.y += speed
                            }
                            if (keysPressed['a']) {
                                object.body.x -= speed
                            }
                        } else if (typeof object != 'undefined') {
                            if (keysPressed['w']) {
                                object.y -= speed
                            }
                            if (keysPressed['d']) {
                                object.x += speed
                            }
                            if (keysPressed['s']) {
                                object.y += speed
                            }
                            if (keysPressed['a']) {
                                object.x -= speed
                            }
                        }
                    }

                    function getRandomLightColor() { // random color that will be visible on  black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 12) + 4)];
                        }
                        return color;
                    }

                    function getRandomColor() { // random color
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 16) + 0)];
                        }
                        return color;
                    }

                    function getRandomDarkColor() { // color that will be visible on a black background
                        var letters = '0123456789ABCDEF';
                        var color = '#';
                        for (var i = 0; i < 6; i++) {
                            color += letters[(Math.floor(Math.random() * 9))];
                        }
                        return color;
                    }

                    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
                        let limit = granularity
                        let shape_array = []
                        for (let t = 0; t < limit; t++) {
                            let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                            circ.toRatio = t / limit
                            circ.fromRatio = (limit - t) / limit
                            shape_array.push(circ)
                        }
                        return (new Shape(shape_array))
                    }

                    let setup_canvas = document.createElement("CANVAS"); //getting canvas from document
                    setup_canvas.width = 1280
                    setup_canvas.height = 720
                    setup_canvas.hidden = true
                    setUp(setup_canvas) // setting up canvas refrences, starting timer. 

                    // object instantiation and creation happens here 

                    class Eovlight {
                        constructor(x, y, r, g, b, radius) {
                            this.r = r
                            this.g = g
                            this.b = b
                            this.parent = {}
                            this.children = []
                            this.body = new Circle(x, y, radius, `rgb(${this.r}, ${this.g}, ${this.b})`, (Math.random() - .5), Math.random() - .5)
                            this.health = (Math.random() * 11) + 100
                            this.maxhealth = this.health
                            this.attack = (Math.random() * 1) + 1
                            this.healthbar = new Rectangle(this.body.x - this.body.radius, this.body.y - this.body.radius * 1.5, this.body.radius * 2, this.body.radius * .1, `rgb(${255-((this.health/this.maxhealth)*255)}, ${((this.health/this.maxhealth)*255)}, 0)`)
                        }
                        reproduce() {
                            let eov = new Eovlight(this.body.x, this.body.y, this.r + ((Math.random() - .5) * 35), this.g + ((Math.random() - .5) * 35), this.b + ((Math.random() - .5) * 35), this.body.radius + ((Math.random() - .4) * 3.2))
                            eov.attack = this.attack + ((Math.random() - .6) * .2)
                            eov.health = this.maxhealth + ((Math.random() - .6) * 20)
                            eov.maxhealth = eov.health
                            eov.parent = this

                            // eov.body.xmom =( (eov.body.xmom *.4) + (this.body.xmom*.6))*1.4
                            // eov.body.ymom = ((eov.body.ymom *.4) + (this.body.ymom*.6))*1.4
                            this.children.push(eov)
                            lights.push(eov)
                                // //console.log(lights)
                        }
                        rep() {

                            if (this.repmark == 1) {
                                this.reproduce()
                                this.repmark = 0
                            }
                        }
                        draw() {
                            for (let t = 0; t < lights.length; t++) {
                                if (this != lights[t]) {
                                    if (this.children.includes(lights[t]) || lights[t] == this.parent || lights[t].parent == this.parent) {
                                        continue
                                    }
                                    if (this.body.doesPerimeterTouch(lights[t].body)) {
                                        this.health -= lights[t].attack
                                        if (this.health < 0) {
                                            lights[t].repmark = 1
                                        }
                                        lights[t].health -= this.attack
                                        if (lights[t].health < 0) {
                                            this.repmark = 1
                                        }
                                    }
                                }

                            }
                            for (let t = 0; t < foods.length; t++) {
                                if (this.body.doesPerimeterTouch(foods[t])) {
                                    foods.splice(t, 1)
                                    this.reproduce()
                                }
                            }

                            if (this.health <= 0) {
                                this.marked = 1
                            }

                            if (this.health < this.maxhealth) {
                                this.health *= 1.01
                            }
                            this.healthbar = new Rectangle(this.body.x - this.body.radius, this.body.y - this.body.radius * 1.5, (this.body.radius * 2) * (this.health / this.maxhealth), this.body.radius * .1, `rgb(${255-((this.health/this.maxhealth)*255)}, ${((this.health/this.maxhealth)*255)}, 0)`)

                            canvas_context.font = '8px arial'
                            canvas_context.fillStyle = "white"
                            canvas_context.fillText(Math.round(this.health) + '/' + Math.round(this.maxhealth), this.body.x - this.body.radius, this.body.y - this.body.radius * 1.9)
                            canvas_context.fillText(Math.round((this.attack * 10)) / 10, this.body.x - this.body.radius, this.body.y - this.body.radius * 2.9)
                            this.body.moveloop()
                            this.body.draw()
                            this.healthbar.draw()

                        }
                        clean() {

                            if (this.health <= 0) {
                                this.marked = 1
                            }

                            if (this.marked == 1) {
                                lights.splice(lights.indexOf(this), 1)
                            }
                        }
                    }


                    let lights = []
                    for (let t = 0; t < 20; t++) {
                        lights.push(new Eovlight(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 255, Math.random() * 255, Math.random() * 255, (Math.random() * 1) + 8))
                    }

                    let foods = []

                    for (let t = 0; t < 20; t++) {
                        let food = new Circle(Math.random() * canvas.width, Math.random() * canvas.height, 3, "white")
                        foods.push(food)
                    }

                    function main() {

                        if (booter.running == 0) {
                            return
                        }
                        canvas_context.clearRect(0, 0, canvas.width, canvas.height) // refreshes the image
                        gamepadAPI.update() //checks for button presses/stick movement on the connected controller)
                            // // game code goes here
                        windowspares[booter.index] = canvas
                        if (Math.random() < .05) {

                            let food = new Circle(Math.random() * canvas.width, Math.random() * canvas.height, 3, "white")
                            foods.push(food)
                        }
                        for (let t = 0; t < foods.length; t++) {
                            foods[t].draw()
                        }
                        for (let t = 0; t < lights.length; t++) {
                            if (lights[t].body.radius < 1) {
                                lights[t].body.radius = 1
                            }
                            lights[t].draw()
                        }
                        for (let t = 0; t < lights.length; t++) {
                            if (Math.random() < .0100) {
                                lights[t].rep()
                            }
                        }
                        for (let t = 0; t < lights.length; t++) {
                            lights[t].clean()
                        }

                    }
                }
            }

            print() {
                canvas_context.measureText(this.name)
                canvas_context.font = "10px arial"
                canvas_context.fillStyle = "#FFFFFF"
                let xdif = canvas_context.measureText(this.name).width
                canvas_context.fillText(this.name, this.body.x - xdif * .5, this.body.y - this.body.radius * 1.1)
            }
            draw() {
                this.body.draw()

                if (this.running == 1) {
                    this.main()
                    if (windowspares[this.index].width > 0) {
                        if (this.index == 2) {
                            canvas_context.drawImage(windowspares[this.index], 0, textscroll, windowspares[this.index].width, 360, this.window.x, this.window.y, this.window.width, this.window.height)

                        } else {
                            canvas_context.drawImage(windowspares[this.index], 0, 0, windowspares[this.index].width, windowspares[this.index].height, this.window.x, this.window.y, this.window.width, this.window.height)

                        }
                        this.window.draw()
                    }
                }
                if (this.marked == 1) {

                    if (this.index != 2) {
                        this.move(TIP_engine)
                    }
                    if (this.ran == 0) {
                        this.ran = 1
                        this.run(this)
                        this.window = new Rectangle(100, 100, 256, 144, "transparent")

                        if (this.index == 0 || this.index == 1 || this.index == 3 || this.index == 4 || this.index == 5) {
                            this.window = new Rectangle(10, 10, 700, 700, "transparent")

                        }
                        if (this.index == 2) {
                            this.window = new Rectangle(710, 360, 1280 - 710, 360, "transparent")
                            windowspares[this.index] = textcanvas
                            this.main = this.body.draw
                        }
                    } else {
                        this.running = 1
                    }
                }
            }
        }




        for (let t = 0; t < 6; t++) {
            let icon = new Icon(1100, 40 + t * 65)
            icon.index = t
            icons.push(icon)
        }


        class Scores {
            constructor() {

            }
        }

        let text = ''

        // if(keysPressed['s']){
        //     chat.send(text)


        function main() {
            canvas_context.clearRect(0, 0, canvas.width, canvas.height) // refreshes the image
            gamepadAPI.update() //checks for button presses/stick movement on the connected controller)
                // // game code goes here
            for (let t = 0; t < icons.length; t++) {
                if(rands[1] > 0){
                icons[t].draw()
                }
            }
            for (let t = 0; t < icons.length; t++) {
                if(rands[1] > 0){
                icons[t].print()
                }
            }
            // if(keysPressed['t']){
            if (typing == 0) {
                if (enterlock == 1) {
                    typing = 1
                    enterlock = 0
                }
            }

            icons[2].marked = 1
            if (typing == 1) {


                textcanvas_context.font = "14px arial"
                textcanvas_context.fillStyle = "white"
                textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)
                textcanvas_context.fillStyle = "#FF000022"
                textcanvas_context.fillRect(0, 320 + textscroll, 1000, 40)
                textcanvas_context.fillStyle = "white"
                textcanvas_context.fillText(textstring, 0, 344 + textscroll)


                if (keysPressed['Enter']) {
                    if (textstring.length > 1) {
                        if (alpha == true) {
                            globalListener.command = textstring
                        }

            globalListener.listen()
                        let tson = {}
                        tson.color = namer
                        tson.name = namer
                        tson.text = textstring
                        textcanvas_context.font = "12px arial"
                        tson.size = 0

                        let metrics = textcanvas_context.measureText(textstring);
                        let fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                        let actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                        tson.measure = fontHeight + 1
                        typing = 0
                        enterlock = 0

                        textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)

                        ws.send(JSON.stringify(tson))
                        tson = JSON.stringify(tson)



                        textcanvas_context.fillStyle = JSON.parse(tson).color


                        let ypointer = 300 + textscroll
                        let stoarr = (`(You) ` + ' ' + JSON.parse(tson).text).split('')
                        let stostring = ''
                        for (let t = 0; t < stoarr.length; t++) {
                            const width = textcanvas_context.measureText(stostring + '' + stoarr[t]).width
                            if (width > textcanvas.width - 12) {
                                textcanvas_context.fillText(stostring + '' + stoarr[t], 0, ypointer)
                                ypointer += 12
                                textscroll += 12
                                stostring = ''
                            } else {
                                stostring = stostring + "" + stoarr[t]
                                if (t == stoarr.length - 1) {

                                    textscroll += 12
                                    textcanvas_context.fillText(stostring, 0, ypointer)
                                }
                            }
                        }


                        // textcanvas_context.fillText(`(${JSON.parse(data).name}) `+ JSON.parse(data).text, 0, 300+textscroll)

                        console.log(JSON.parse(tson).measure)
                            // textscroll += JSON.parse(tson).measure






                        // textcanvas_context.fillText(`(You) `+ JSON.parse(tson).text, 0, 300+textscroll)

                        textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)


                        console.log(JSON.parse(tson).measure)
                            // textscroll +=  JSON.parse(tson).measure

                        // textcanvas_context.translate(0, 12)

                        textstring = ''
                    }
                }
            }
        }

        let namer = getRandomLightColor()


        // let clamp = {}

        //     for(let t = 0;t<50000;t++){
        //         clamp[`${t}`] = Math.random() 
        //     }

        // console.log(JSON.stringify(clamp))




    })
</script>
<div>

    <ul>
        <div id="dog-image-container" class="canvas">
            <canvas id="canvas" width="1280" height="720" class="canvas"></canvas>
            <canvas id="textcanvas" width="640" height="360" class="canvas"></canvas>
            <canvas hidden id="xcanvas" width="1280" height="720" class="canvas"></canvas>
        </div>
    </ul>
</div>



</htm